###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                08/Apr/2013  11:22:12 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Com #
#                          ponents\osal\common\OSAL.c                         #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0 #
#                          \Projects\zstack\Samples\WSN_sensors\CC2530DB\..\. #
#                          .\..\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ     #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DRTR_NWK -DBLINK_LEDS) -f "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wConfig.cfg" (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Co #
#                          mponents\osal\common\OSAL.c" -D ZTOOL_P1 -D        #
#                          MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC -D           #
#                          LCD_SUPPORTED=DEBUG -lC "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\RouterEB\List\"   #
#                          -lA "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3. #
#                          0\Projects\zstack\Samples\WSN_sensors\CC2530DB\Rou #
#                          terEB\List\" --diag_suppress Pe001,Pa010 -o        #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\WSN_sensors\CC2530DB\RouterE #
#                          B\Obj\" -e --require_prototypes --no_unroll        #
#                          --no_inline --no_tbaa --debug --core=plain         #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\" -I "C:\Texas    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\SOURCE\" -I    #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\WSN_sensors\CC2530DB\..\..\. #
#                          .\ZMAIN\TI2530DB\" -I "C:\Texas                    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MT\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\TARGET\CC2530EB\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\INCLUDE\" -I "C:\Texas               #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\AF\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\NWK\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SEC\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SAPI\" -I "C:\Texas                 #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SYS\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\ZDO\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\F8W\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SADDR\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SDATA\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I      #
#                          "D:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3\8051\INC\" -I "D:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\" -Om #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\WSN_sensors\CC2530DB\RouterEB #
#                          \List\OSAL.lst                                     #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\WSN_sensors\CC2530DB\RouterEB #
#                          \Obj\OSAL.r51                                      #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Components\osal\common\OSAL.c
      1          /**************************************************************************************************
      2            Filename:       OSAL.c
      3            Revised:        $Date: 2009-08-18 11:27:57 -0700 (Tue, 18 Aug 2009) $
      4            Revision:       $Revision: 20600 $
      5          
      6            Description:    This API allows the software components in the Z-stack to be written
      7                            independently of the specifics of the operating system, kernel or tasking
      8                            environment (including control loops or connect-to-interrupt systems).
      9          
     10          
     11            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     12          
     13            IMPORTANT: Your use of this Software is limited to those specific rights
     14            granted under the terms of a software license agreement between the user
     15            who downloaded the software, his/her employer (which must be your employer)
     16            and Texas Instruments Incorporated (the "License").  You may not use this
     17            Software unless you agree to abide by the terms of the License. The License
     18            limits your use, and you acknowledge, that the Software may not be modified,
     19            copied or distributed unless embedded on a Texas Instruments microcontroller
     20            or used solely and exclusively in conjunction with a Texas Instruments radio
     21            frequency transceiver, which is integrated into your product.  Other than for
     22            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     23            works of, modify, distribute, perform, display or sell this Software and/or
     24            its documentation for any purpose.
     25          
     26            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     27            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     28            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     29            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     30            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     31            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     32            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     33            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     34            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     35            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     36            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     37          
     38            Should you have any questions regarding your right to use this Software,
     39            contact Texas Instruments Incorporated at www.TI.com. 
     40          **************************************************************************************************/
     41          
     42          /*********************************************************************
     43           * INCLUDES
     44           */
     45          
     46          #include <string.h>
     47          
     48          #include "comdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_Tasks.h"
     51          #include "OSAL_Memory.h"
     52          #include "OSAL_PwrMgr.h"
     53          #include "OSAL_Clock.h"   
     54          
     55          #include "OnBoard.h"

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1
     56          
     57          /* HAL */
     58          #include "hal_drivers.h"
     59          
     60          /*********************************************************************
     61           * MACROS
     62           */
     63          
     64          #define OSAL_MSG_LEN(msg_ptr)      ((osal_msg_hdr_t *) (msg_ptr) - 1)->len
     65          
     66          #define OSAL_MSG_ID(msg_ptr)      ((osal_msg_hdr_t *) (msg_ptr) - 1)->dest_id
     67          
     68          /*********************************************************************
     69           * CONSTANTS
     70           */
     71          
     72          /*********************************************************************
     73           * TYPEDEFS
     74           */
     75          
     76          /*********************************************************************
     77           * GLOBAL VARIABLES
     78           */
     79          
     80          // Message Pool Definitions

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     81          osal_msg_q_t osal_qHead;
   \                     osal_qHead:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
     82          
     83          /*********************************************************************
     84           * EXTERNAL VARIABLES
     85           */
     86          
     87          /*********************************************************************
     88           * EXTERNAL FUNCTIONS
     89           */
     90          
     91          /*********************************************************************
     92           * LOCAL VARIABLES
     93           */
     94          
     95          /*********************************************************************
     96           * LOCAL FUNCTION PROTOTYPES
     97           */
     98          static uint8 osal_clear_event( uint8 task_id, uint16 event_flag );
     99          
    100          /*********************************************************************
    101           * HELPER FUNCTIONS
    102           */
    103          /* very ugly stub so Keil can compile */
    104          #ifdef __KEIL__
    105          char *  itoa ( int value, char * buffer, int radix )
    106          {
    107            return(buffer);
    108          }
    109          #endif
    110          
    111          /*********************************************************************
    112           * @fn      osal_strlen
    113           *
    114           * @brief
    115           *
    116           *   Calculates the length of a string.  The string must be null
    117           *   terminated.
    118           *
    119           * @param   char *pString - pointer to text string
    120           *
    121           * @return  int - number of characters
    122           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    123          int osal_strlen( char *pString )
   \                     osal_strlen:
    124          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    125            return (int)( strlen( pString ) );
   \   000004                ; Setup parameters for call to function strlen
   \   000004   12....       LCALL   ??strlen?relay
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
    126          }
    127          
    128          /*********************************************************************
    129           * @fn      osal_memcpy
    130           *
    131           * @brief
    132           *
    133           *   Generic memory copy.
    134           *
    135           *   Note: This function differs from the standard memcpy(), since
    136           *         it returns the pointer to the next destination uint8. The
    137           *         standard memcpy() returns the original destination address.
    138           *
    139           * @param   dst - destination address
    140           * @param   src - source address
    141           * @param   len - number of bytes to copy
    142           *
    143           * @return  pointer to end of destination buffer
    144           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void *osal_memcpy( void *dst, const void GENERIC *src, unsigned int len )
   \                     osal_memcpy:
    146          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   \   000009   740B         MOV     A,#0xb
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   F5..         MOV     ?V0 + 1,A
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
    147            uint8 *pDst;
    148            const uint8 GENERIC *pSrc;
    149          
    150            pSrc = src;
   \   000017   A9..         MOV     R1,?V0 + 0
   \   000019   AA..         MOV     R2,?V0 + 1
   \   00001B   FB           MOV     R3,A
    151            pDst = dst;
   \   00001C   8E82         MOV     DPL,R6
   \   00001E   8F83         MOV     DPH,R7
   \   000020   800D         SJMP    ??osal_memcpy_0
    152          
    153            while ( len-- )
    154              *pDst++ = *pSrc++;
   \                     ??osal_memcpy_1:
   \   000022   12....       LCALL   ?C_GPTR_LOAD
   \   000025   F0           MOVX    @DPTR,A
   \   000026   E9           MOV     A,R1
   \   000027   2401         ADD     A,#0x1
   \   000029   09           INC     R1
   \   00002A   EA           MOV     A,R2
   \   00002B   3400         ADDC    A,#0x0
   \   00002D   FA           MOV     R2,A
   \   00002E   A3           INC     DPTR
   \                     ??osal_memcpy_0:
   \   00002F   EC           MOV     A,R4
   \   000030   FE           MOV     R6,A
   \   000031   ED           MOV     A,R5
   \   000032   FF           MOV     R7,A
   \   000033   74FF         MOV     A,#-0x1
   \   000035   2E           ADD     A,R6
   \   000036   1C           DEC     R4
   \   000037   74FF         MOV     A,#-0x1
   \   000039   3F           ADDC    A,R7
   \   00003A   FD           MOV     R5,A
   \   00003B   EE           MOV     A,R6
   \   00003C   7001         JNZ     ??osal_memcpy_2
   \   00003E   EF           MOV     A,R7
   \                     ??osal_memcpy_2:
   \   00003F   70E1         JNZ     ??osal_memcpy_1
    155          
    156            return ( pDst );
   \   000041   AA82         MOV     R2,DPL
   \   000043   AB83         MOV     R3,DPH
   \   000045   7F03         MOV     R7,#0x3
   \   000047   02....       LJMP    ?BANKED_LEAVE_XDATA
    157          }
    158          
    159          /*********************************************************************
    160           * @fn      osal_memcmp
    161           *
    162           * @brief
    163           *
    164           *   Generic memory compare.
    165           *
    166           * @param   src1 - source 1 addrexx
    167           * @param   src2 - source 2 address
    168           * @param   len - number of bytes to compare
    169           *
    170           * @return  TRUE - same, FALSE - different
    171           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    172          uint8 osal_memcmp( const void GENERIC *src1, const void GENERIC *src2, unsigned int len )
   \                     osal_memcmp:
    173          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 3
   \   000005   74FD         MOV     A,#-0x3
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E9           MOV     A,R1
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   EA           MOV     A,R2
   \   000014   F0           MOVX    @DPTR,A
   \   000015   A3           INC     DPTR
   \   000016   EB           MOV     A,R3
   \   000017   F0           MOVX    @DPTR,A
   \   000018   8C..         MOV     ?V0 + 0,R4
   \   00001A   8D..         MOV     ?V0 + 1,R5
   \   00001C   7412         MOV     A,#0x12
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   E0           MOVX    A,@DPTR
   \   000022   F9           MOV     R1,A
   \   000023   A3           INC     DPTR
   \   000024   E0           MOVX    A,@DPTR
   \   000025   FA           MOV     R2,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   FB           MOV     R3,A
    174            const uint8 GENERIC *pSrc1;
    175            const uint8 GENERIC *pSrc2;
    176          
    177            pSrc1 = src1;
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   F5..         MOV     ?V0 + 4,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   F5..         MOV     ?V0 + 5,A
   \   000036   A3           INC     DPTR
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F5..         MOV     ?V0 + 6,A
    178            pSrc2 = src2;
   \   00003A   E9           MOV     A,R1
   \   00003B   FC           MOV     R4,A
   \   00003C   EA           MOV     A,R2
   \   00003D   FD           MOV     R5,A
   \   00003E   EB           MOV     A,R3
   \   00003F   FE           MOV     R6,A
    179          
    180            while ( len-- )
   \                     ??osal_memcmp_0:
   \   000040   A8..         MOV     R0,?V0 + 0
   \   000042   A9..         MOV     R1,?V0 + 1
   \   000044   74FF         MOV     A,#-0x1
   \   000046   28           ADD     A,R0
   \   000047   F5..         MOV     ?V0 + 0,A
   \   000049   74FF         MOV     A,#-0x1
   \   00004B   39           ADDC    A,R1
   \   00004C   F5..         MOV     ?V0 + 1,A
   \   00004E   E8           MOV     A,R0
   \   00004F   7001         JNZ     ??osal_memcmp_1
   \   000051   E9           MOV     A,R1
   \                     ??osal_memcmp_1:
   \   000052   6050         JZ      ??osal_memcmp_2
    181            {
    182              if( *pSrc1++ != *pSrc2++ )
   \   000054   A9..         MOV     R1,?V0 + 4
   \   000056   AA..         MOV     R2,?V0 + 5
   \   000058   AB..         MOV     R3,?V0 + 6
   \   00005A   E9           MOV     A,R1
   \   00005B   2401         ADD     A,#0x1
   \   00005D   F5..         MOV     ?V0 + 4,A
   \   00005F   EA           MOV     A,R2
   \   000060   3400         ADDC    A,#0x0
   \   000062   F5..         MOV     ?V0 + 5,A
   \   000064   85..82       MOV     DPL,?XSP + 0
   \   000067   85..83       MOV     DPH,?XSP + 1
   \   00006A   EC           MOV     A,R4
   \   00006B   F0           MOVX    @DPTR,A
   \   00006C   A3           INC     DPTR
   \   00006D   ED           MOV     A,R5
   \   00006E   F0           MOVX    @DPTR,A
   \   00006F   A3           INC     DPTR
   \   000070   EE           MOV     A,R6
   \   000071   F0           MOVX    @DPTR,A
   \   000072   85..82       MOV     DPL,?XSP + 0
   \   000075   85..83       MOV     DPH,?XSP + 1
   \   000078   E0           MOVX    A,@DPTR
   \   000079   FC           MOV     R4,A
   \   00007A   A3           INC     DPTR
   \   00007B   E0           MOVX    A,@DPTR
   \   00007C   FD           MOV     R5,A
   \   00007D   A3           INC     DPTR
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   FE           MOV     R6,A
   \   000080   EC           MOV     A,R4
   \   000081   2401         ADD     A,#0x1
   \   000083   0C           INC     R4
   \   000084   ED           MOV     A,R5
   \   000085   3400         ADDC    A,#0x0
   \   000087   FD           MOV     R5,A
   \   000088   12....       LCALL   ?C_GPTR_LOAD
   \   00008B   FF           MOV     R7,A
   \   00008C   85..82       MOV     DPL,?XSP + 0
   \   00008F   85..83       MOV     DPH,?XSP + 1
   \   000092   E0           MOVX    A,@DPTR
   \   000093   F9           MOV     R1,A
   \   000094   A3           INC     DPTR
   \   000095   E0           MOVX    A,@DPTR
   \   000096   FA           MOV     R2,A
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   FB           MOV     R3,A
   \   00009A   12....       LCALL   ?C_GPTR_LOAD
   \   00009D   6F           XRL     A,R7
   \   00009E   60A0         JZ      ??osal_memcmp_0
    183                return FALSE;
   \   0000A0   7900         MOV     R1,#0x0
   \   0000A2   8002         SJMP    ??osal_memcmp_3
    184            }
    185            return TRUE;
   \                     ??osal_memcmp_2:
   \   0000A4   7901         MOV     R1,#0x1
   \                     ??osal_memcmp_3:
   \   0000A6   7403         MOV     A,#0x3
   \   0000A8   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AB   7F07         MOV     R7,#0x7
   \   0000AD   02....       LJMP    ?BANKED_LEAVE_XDATA
    186          }
    187          
    188          
    189          /*********************************************************************
    190           * @fn      osal_memset
    191           *
    192           * @brief
    193           *
    194           *   Set memory buffer to value.
    195           *
    196           * @param   dest - pointer to buffer
    197           * @param   value - what to set each uint8 of the message
    198           * @param   size - how big
    199           *
    200           * @return  value of next widget, 0 if no widget found
    201           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    202          void *osal_memset( void *dest, uint8 value, int len )
   \                     osal_memset:
    203          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    204            return memset( dest, value, len );
   \   000005                ; Setup parameters for call to function memset
   \   000005   8C..         MOV     ?V0 + 0,R4
   \   000007   8D..         MOV     ?V0 + 1,R5
   \   000009   78..         MOV     R0,#?V0 + 0
   \   00000B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000E   E9           MOV     A,R1
   \   00000F   FC           MOV     R4,A
   \   000010   7D00         MOV     R5,#0x0
   \   000012   12....       LCALL   ??memset?relay
   \   000015   7402         MOV     A,#0x2
   \   000017   12....       LCALL   ?DEALLOC_XSTACK8
   \   00001A   7F02         MOV     R7,#0x2
   \   00001C   02....       LJMP    ?BANKED_LEAVE_XDATA
    205          }
    206          
    207          /*********************************************************************
    208           * @fn      osal_build_uint16
    209           *
    210           * @brief
    211           *
    212           *   Build a uint16 out of 2 bytes (0 then 1).
    213           *
    214           * @param   swapped - 0 then 1
    215           *
    216           * @return  uint16
    217           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    218          uint16 osal_build_uint16( uint8 *swapped )
   \                     osal_build_uint16:
    219          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    220            return ( BUILD_UINT16( swapped[0], swapped[1] ) );
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   FC           MOV     R4,A
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   EC           MOV     A,R4
   \   00000F   FA           MOV     R2,A
   \   000010   E9           MOV     A,R1
   \   000011   FB           MOV     R3,A
   \   000012   7F01         MOV     R7,#0x1
   \   000014   02....       LJMP    ?BANKED_LEAVE_XDATA
    221          }
    222          
    223          /*********************************************************************
    224           * @fn      osal_build_uint32
    225           *
    226           * @brief
    227           *
    228           *   Build a uint32 out of sequential bytes.
    229           *
    230           * @param   swapped - sequential bytes
    231           * @param   len - number of bytes in the uint8 array
    232           *
    233           * @return  uint32
    234           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    235          uint32 osal_build_uint32( uint8 *swapped, uint8 len )
   \                     osal_build_uint32:
    236          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
    237            if ( len == 2 )
   \   000005   7402         MOV     A,#0x2
   \   000007   69           XRL     A,R1
   \   000008   7036         JNZ     ??osal_build_uint32_0
    238              return ( BUILD_UINT32( swapped[0], swapped[1], 0L, 0L ) );
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   E0           MOVX    A,@DPTR
   \   00000F   F5..         MOV     ?V0 + 0,A
   \   000011   75..00       MOV     ?V0 + 1,#0x0
   \   000014   75..00       MOV     ?V0 + 2,#0x0
   \   000017   75..00       MOV     ?V0 + 3,#0x0
   \   00001A   A3           INC     DPTR
   \   00001B   E0           MOVX    A,@DPTR
   \   00001C   F5..         MOV     ?V0 + 4,A
   \   00001E   75..00       MOV     ?V0 + 5,#0x0
   \   000021   75..00       MOV     ?V0 + 6,#0x0
   \   000024   75..00       MOV     ?V0 + 7,#0x0
   \   000027   7408         MOV     A,#0x8
   \                     ??osal_build_uint32_1:
   \   000029   78..         MOV     R0,#?V0 + 4
   \   00002B   12....       LCALL   ?L_SHL
   \   00002E   78..         MOV     R0,#?V0 + 0
   \   000030   79..         MOV     R1,#?V0 + 4
   \   000032   12....       LCALL   ?L_ADD
   \   000035   AA..         MOV     R2,?V0 + 0
   \   000037   AB..         MOV     R3,?V0 + 1
   \   000039   AC..         MOV     R4,?V0 + 2
   \   00003B   AD..         MOV     R5,?V0 + 3
   \   00003D   02....       LJMP    ??osal_build_uint32_2 & 0xFFFF
    239            else if ( len == 3 )
   \                     ??osal_build_uint32_0:
   \   000040   7403         MOV     A,#0x3
   \   000042   69           XRL     A,R1
   \   000043   703B         JNZ     ??osal_build_uint32_3
    240              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], 0L ) );
   \   000045   8A82         MOV     DPL,R2
   \   000047   8B83         MOV     DPH,R3
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   F5..         MOV     ?V0 + 0,A
   \   00004C   75..00       MOV     ?V0 + 1,#0x0
   \   00004F   75..00       MOV     ?V0 + 2,#0x0
   \   000052   75..00       MOV     ?V0 + 3,#0x0
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   F5..         MOV     ?V0 + 4,A
   \   000059   75..00       MOV     ?V0 + 5,#0x0
   \   00005C   75..00       MOV     ?V0 + 6,#0x0
   \   00005F   75..00       MOV     ?V0 + 7,#0x0
   \   000062   7408         MOV     A,#0x8
   \   000064   78..         MOV     R0,#?V0 + 4
   \   000066   12....       LCALL   ?L_SHL
   \   000069   78..         MOV     R0,#?V0 + 0
   \   00006B   79..         MOV     R1,#?V0 + 4
   \   00006D   12....       LCALL   ?L_ADD
   \   000070   8A82         MOV     DPL,R2
   \   000072   8B83         MOV     DPH,R3
   \   000074   A3           INC     DPTR
   \   000075   A3           INC     DPTR
   \   000076   E0           MOVX    A,@DPTR
   \   000077   F5..         MOV     ?V0 + 4,A
   \   000079   75..00       MOV     ?V0 + 5,#0x0
   \   00007C   7410         MOV     A,#0x10
   \   00007E   80A9         SJMP    ??osal_build_uint32_1
    241            else if ( len == 4 )
   \                     ??osal_build_uint32_3:
   \   000080   7404         MOV     A,#0x4
   \   000082   69           XRL     A,R1
   \   000083   8A82         MOV     DPL,R2
   \   000085   8B83         MOV     DPH,R3
   \   000087   7053         JNZ     ??osal_build_uint32_4
    242              return ( BUILD_UINT32( swapped[0], swapped[1], swapped[2], swapped[3] ) );
   \   000089   E0           MOVX    A,@DPTR
   \   00008A   F5..         MOV     ?V0 + 0,A
   \   00008C   75..00       MOV     ?V0 + 1,#0x0
   \   00008F   75..00       MOV     ?V0 + 2,#0x0
   \   000092   75..00       MOV     ?V0 + 3,#0x0
   \   000095   A3           INC     DPTR
   \   000096   E0           MOVX    A,@DPTR
   \   000097   F5..         MOV     ?V0 + 4,A
   \   000099   75..00       MOV     ?V0 + 5,#0x0
   \   00009C   75..00       MOV     ?V0 + 6,#0x0
   \   00009F   75..00       MOV     ?V0 + 7,#0x0
   \   0000A2   7408         MOV     A,#0x8
   \   0000A4   78..         MOV     R0,#?V0 + 4
   \   0000A6   12....       LCALL   ?L_SHL
   \   0000A9   78..         MOV     R0,#?V0 + 0
   \   0000AB   79..         MOV     R1,#?V0 + 4
   \   0000AD   12....       LCALL   ?L_ADD
   \   0000B0   8A82         MOV     DPL,R2
   \   0000B2   8B83         MOV     DPH,R3
   \   0000B4   A3           INC     DPTR
   \   0000B5   A3           INC     DPTR
   \   0000B6   E0           MOVX    A,@DPTR
   \   0000B7   F5..         MOV     ?V0 + 4,A
   \   0000B9   75..00       MOV     ?V0 + 5,#0x0
   \   0000BC   7410         MOV     A,#0x10
   \   0000BE   78..         MOV     R0,#?V0 + 4
   \   0000C0   12....       LCALL   ?L_SHL
   \   0000C3   78..         MOV     R0,#?V0 + 0
   \   0000C5   79..         MOV     R1,#?V0 + 4
   \   0000C7   12....       LCALL   ?L_ADD
   \   0000CA   8A82         MOV     DPL,R2
   \   0000CC   8B83         MOV     DPH,R3
   \   0000CE   A3           INC     DPTR
   \   0000CF   A3           INC     DPTR
   \   0000D0   A3           INC     DPTR
   \   0000D1   E0           MOVX    A,@DPTR
   \   0000D2   F5..         MOV     ?V0 + 4,A
   \   0000D4   75..00       MOV     ?V0 + 6,#0x0
   \   0000D7   7418         MOV     A,#0x18
   \   0000D9   02....       LJMP    ??osal_build_uint32_1 & 0xFFFF
    243            else
    244              return ( (uint32)swapped[0] );
   \                     ??osal_build_uint32_4:
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   FA           MOV     R2,A
   \   0000DE   7B00         MOV     R3,#0x0
   \   0000E0   7C00         MOV     R4,#0x0
   \   0000E2   7D00         MOV     R5,#0x0
   \                     ??osal_build_uint32_2:
   \   0000E4   7F08         MOV     R7,#0x8
   \   0000E6   02....       LJMP    ?BANKED_LEAVE_XDATA
    245          }
    246          
    247          #if !defined ( ZBIT ) && !defined ( ZBIT2 ) && !defined (UBIT)
    248          /*********************************************************************
    249           * @fn      _ltoa
    250           *
    251           * @brief
    252           *
    253           *   convert a long unsigned int to a string.
    254           *
    255           * @param  l - long to convert
    256           * @param  buf - buffer to convert to
    257           * @param  radix - 10 dec, 16 hex
    258           *
    259           * @return  pointer to buffer
    260           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    261          unsigned char * _ltoa(unsigned long l, unsigned char *buf, unsigned char radix)
   \                     _ltoa:
    262          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 36
   \   000005   74DC         MOV     A,#-0x24
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7402         MOV     A,#0x2
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   EA           MOV     A,R2
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   EB           MOV     A,R3
   \   000013   F0           MOVX    @DPTR,A
   \   000014   A3           INC     DPTR
   \   000015   EC           MOV     A,R4
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   ED           MOV     A,R5
   \   000019   F0           MOVX    @DPTR,A
    263          #if defined( __GNUC__ )
    264            return ( (char*)ltoa( l, buf, radix ) );
    265          #else
    266            unsigned char tmp1[10] = "", tmp2[10] = "", tmp3[10] = "";
   \   00001A   90....       MOV     DPTR,#`?<Constant "">`
   \   00001D   C082         PUSH    DPL
   \   00001F   C083         PUSH    DPH
   \   000021   7406         MOV     A,#0x6
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   AC82         MOV     R4,DPL
   \   000028   AD83         MOV     R5,DPH
   \   00002A   D083         POP     DPH
   \   00002C   D082         POP     DPL
   \   00002E   740A         MOV     A,#0xa
   \   000030   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   000033   90....       MOV     DPTR,#`?<Constant "">_1`
   \   000036   740A         MOV     A,#0xa
   \   000038   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
   \   00003B   90....       MOV     DPTR,#`?<Constant "">_2`
   \   00003E   740A         MOV     A,#0xa
   \   000040   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    267            unsigned short num1, num2, num3;
    268            unsigned char i;
    269          
    270            buf[0] = '\0';
   \   000043   C0E0         PUSH    A
   \   000045   7434         MOV     A,#0x34
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F8           MOV     R0,A
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F583         MOV     DPH,A
   \   000050   8882         MOV     DPL,R0
   \   000052   D0E0         POP     A
   \   000054   F0           MOVX    @DPTR,A
    271          
    272            if ( radix == 10 )
   \   000055   740A         MOV     A,#0xa
   \   000057   69           XRL     A,R1
   \   000058   6003         JZ      $+5
   \   00005A   02....       LJMP    ??_ltoa_0 & 0xFFFF
    273            {
    274              num1 = l % 10000;
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   78..         MOV     R0,#?V0 + 4
   \   000064   12....       LCALL   ?L_MOV_X
   \   000067   90....       MOV     DPTR,#__Constant_2710
   \   00006A   78..         MOV     R0,#?V0 + 0
   \   00006C   12....       LCALL   ?L_MOV_X
   \   00006F   78..         MOV     R0,#?V0 + 4
   \   000071   79..         MOV     R1,#?V0 + 0
   \   000073   12....       LCALL   ?UL_DIV_MOD
   \   000076   85..82       MOV     DPL,?XSP + 0
   \   000079   85..83       MOV     DPH,?XSP + 1
   \   00007C   E5..         MOV     A,?V0 + 0
   \   00007E   F0           MOVX    @DPTR,A
   \   00007F   A3           INC     DPTR
   \   000080   E5..         MOV     A,?V0 + 1
   \   000082   F0           MOVX    @DPTR,A
    275              num2 = (l / 10000) % 10000;
   \   000083   7402         MOV     A,#0x2
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   78..         MOV     R0,#?V0 + 4
   \   00008A   12....       LCALL   ?L_MOV_X
   \   00008D   90....       MOV     DPTR,#__Constant_2710
   \   000090   78..         MOV     R0,#?V0 + 0
   \   000092   12....       LCALL   ?L_MOV_X
   \   000095   78..         MOV     R0,#?V0 + 4
   \   000097   79..         MOV     R1,#?V0 + 0
   \   000099   12....       LCALL   ?UL_DIV_MOD
   \   00009C   90....       MOV     DPTR,#__Constant_2710
   \   00009F   78..         MOV     R0,#?V0 + 0
   \   0000A1   12....       LCALL   ?L_MOV_X
   \   0000A4   78..         MOV     R0,#?V0 + 4
   \   0000A6   79..         MOV     R1,#?V0 + 0
   \   0000A8   12....       LCALL   ?UL_DIV_MOD
   \   0000AB   AE..         MOV     R6,?V0 + 0
   \   0000AD   AF..         MOV     R7,?V0 + 1
    276              num3 = (unsigned short)(l / 100000000);
   \   0000AF   7402         MOV     A,#0x2
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   78..         MOV     R0,#?V0 + 4
   \   0000B6   12....       LCALL   ?L_MOV_X
   \   0000B9   90....       MOV     DPTR,#__Constant_5f5e100
   \   0000BC   78..         MOV     R0,#?V0 + 0
   \   0000BE   12....       LCALL   ?L_MOV_X
   \   0000C1   78..         MOV     R0,#?V0 + 4
   \   0000C3   79..         MOV     R1,#?V0 + 0
   \   0000C5   12....       LCALL   ?UL_DIV_MOD
   \   0000C8   85....       MOV     ?V0 + 6,?V0 + 4
   \   0000CB   85....       MOV     ?V0 + 7,?V0 + 5
    277          
    278              if (num3) _itoa(num3, tmp3, 10);
   \   0000CE   E5..         MOV     A,?V0 + 6
   \   0000D0   7002         JNZ     ??_ltoa_1
   \   0000D2   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_1:
   \   0000D4   6012         JZ      ??_ltoa_2
   \   0000D6                ; Setup parameters for call to function _itoa
   \   0000D6   790A         MOV     R1,#0xa
   \   0000D8   741A         MOV     A,#0x1a
   \   0000DA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DD   AC82         MOV     R4,DPL
   \   0000DF   AD83         MOV     R5,DPH
   \   0000E1   AA..         MOV     R2,?V0 + 6
   \   0000E3   AB..         MOV     R3,?V0 + 7
   \   0000E5   12....       LCALL   ??_itoa?relay
    279              if (num2) _itoa(num2, tmp2, 10);
   \                     ??_ltoa_2:
   \   0000E8   EE           MOV     A,R6
   \   0000E9   7001         JNZ     ??_ltoa_3
   \   0000EB   EF           MOV     A,R7
   \                     ??_ltoa_3:
   \   0000EC   6012         JZ      ??_ltoa_4
   \   0000EE                ; Setup parameters for call to function _itoa
   \   0000EE   790A         MOV     R1,#0xa
   \   0000F0   7410         MOV     A,#0x10
   \   0000F2   12....       LCALL   ?XSTACK_DISP0_8
   \   0000F5   AC82         MOV     R4,DPL
   \   0000F7   AD83         MOV     R5,DPH
   \   0000F9   EE           MOV     A,R6
   \   0000FA   FA           MOV     R2,A
   \   0000FB   EF           MOV     A,R7
   \   0000FC   FB           MOV     R3,A
   \   0000FD   12....       LCALL   ??_itoa?relay
    280              if (num1) _itoa(num1, tmp1, 10);
   \                     ??_ltoa_4:
   \   000100   85..82       MOV     DPL,?XSP + 0
   \   000103   85..83       MOV     DPH,?XSP + 1
   \   000106   E0           MOVX    A,@DPTR
   \   000107   7002         JNZ     ??_ltoa_5
   \   000109   A3           INC     DPTR
   \   00010A   E0           MOVX    A,@DPTR
   \                     ??_ltoa_5:
   \   00010B   6019         JZ      ??_ltoa_6
   \   00010D                ; Setup parameters for call to function _itoa
   \   00010D   790A         MOV     R1,#0xa
   \   00010F   7406         MOV     A,#0x6
   \   000111   12....       LCALL   ?XSTACK_DISP0_8
   \   000114   AC82         MOV     R4,DPL
   \   000116   AD83         MOV     R5,DPH
   \   000118   85..82       MOV     DPL,?XSP + 0
   \   00011B   85..83       MOV     DPH,?XSP + 1
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   FA           MOV     R2,A
   \   000120   A3           INC     DPTR
   \   000121   E0           MOVX    A,@DPTR
   \   000122   FB           MOV     R3,A
   \   000123   12....       LCALL   ??_itoa?relay
    281          
    282              if (num3)
   \                     ??_ltoa_6:
   \   000126   E5..         MOV     A,?V0 + 6
   \   000128   7002         JNZ     ??_ltoa_7
   \   00012A   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_7:
   \   00012C   6053         JZ      ??_ltoa_8
    283              {
    284                strcpy((char*)buf, (char const*)tmp3);
   \   00012E                ; Setup parameters for call to function strcpy
   \   00012E   741A         MOV     A,#0x1a
   \   000130   12....       LCALL   ?XSTACK_DISP0_8
   \   000133   AC82         MOV     R4,DPL
   \   000135   AD83         MOV     R5,DPH
   \   000137   7434         MOV     A,#0x34
   \   000139   12....       LCALL   ?XSTACK_DISP0_8
   \   00013C   E0           MOVX    A,@DPTR
   \   00013D   FA           MOV     R2,A
   \   00013E   A3           INC     DPTR
   \   00013F   E0           MOVX    A,@DPTR
   \   000140   FB           MOV     R3,A
   \   000141   12....       LCALL   ??strcpy?relay
    285                for (i = 0; i < 4 - strlen((char const*)tmp2); i++)
   \   000144   75..00       MOV     ?V0 + 0,#0x0
   \   000147   8013         SJMP    ??_ltoa_9
    286                  strcat((char*)buf, "0");
   \                     ??_ltoa_10:
   \   000149                ; Setup parameters for call to function strcat
   \   000149   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   00014B   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   00014D   7434         MOV     A,#0x34
   \   00014F   12....       LCALL   ?XSTACK_DISP0_8
   \   000152   E0           MOVX    A,@DPTR
   \   000153   FA           MOV     R2,A
   \   000154   A3           INC     DPTR
   \   000155   E0           MOVX    A,@DPTR
   \   000156   FB           MOV     R3,A
   \   000157   12....       LCALL   ??strcat?relay
   \   00015A   05..         INC     ?V0 + 0
   \                     ??_ltoa_9:
   \   00015C   85....       MOV     ?V0 + 2,?V0 + 0
   \   00015F                ; Setup parameters for call to function strlen
   \   00015F   7410         MOV     A,#0x10
   \   000161   12....       LCALL   ?XSTACK_DISP0_8
   \   000164   AA82         MOV     R2,DPL
   \   000166   AB83         MOV     R3,DPH
   \   000168   12....       LCALL   ??strlen?relay
   \   00016B   8A..         MOV     ?V0 + 4,R2
   \   00016D   8B..         MOV     ?V0 + 5,R3
   \   00016F   7404         MOV     A,#0x4
   \   000171   C3           CLR     C
   \   000172   95..         SUBB    A,?V0 + 4
   \   000174   F8           MOV     R0,A
   \   000175   E4           CLR     A
   \   000176   95..         SUBB    A,?V0 + 5
   \   000178   F9           MOV     R1,A
   \   000179   C3           CLR     C
   \   00017A   E5..         MOV     A,?V0 + 2
   \   00017C   98           SUBB    A,R0
   \   00017D   E4           CLR     A
   \   00017E   99           SUBB    A,R1
   \   00017F   40C8         JC      ??_ltoa_10
    287              }
    288              strcat((char*)buf, (char const*)tmp2);
   \                     ??_ltoa_8:
   \   000181                ; Setup parameters for call to function strcat
   \   000181   7410         MOV     A,#0x10
   \   000183   12....       LCALL   ?XSTACK_DISP0_8
   \   000186   AC82         MOV     R4,DPL
   \   000188   AD83         MOV     R5,DPH
   \   00018A   7434         MOV     A,#0x34
   \   00018C   12....       LCALL   ?XSTACK_DISP0_8
   \   00018F   E0           MOVX    A,@DPTR
   \   000190   FA           MOV     R2,A
   \   000191   A3           INC     DPTR
   \   000192   E0           MOVX    A,@DPTR
   \   000193   FB           MOV     R3,A
   \   000194   12....       LCALL   ??strcat?relay
    289              if (num3 || num2)
   \   000197   E5..         MOV     A,?V0 + 6
   \   000199   7002         JNZ     ??_ltoa_11
   \   00019B   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_11:
   \   00019D   7006         JNZ     ??_ltoa_12
   \   00019F   EE           MOV     A,R6
   \   0001A0   7001         JNZ     ??_ltoa_13
   \   0001A2   EF           MOV     A,R7
   \                     ??_ltoa_13:
   \   0001A3   603D         JZ      ??_ltoa_14
    290              {
    291                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
   \                     ??_ltoa_12:
   \   0001A5   75..00       MOV     ?V0 + 0,#0x0
   \   0001A8   8013         SJMP    ??_ltoa_15
    292                  strcat((char*)buf, "0");
   \                     ??_ltoa_16:
   \   0001AA                ; Setup parameters for call to function strcat
   \   0001AA   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   0001AC   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   0001AE   7434         MOV     A,#0x34
   \   0001B0   12....       LCALL   ?XSTACK_DISP0_8
   \   0001B3   E0           MOVX    A,@DPTR
   \   0001B4   FA           MOV     R2,A
   \   0001B5   A3           INC     DPTR
   \   0001B6   E0           MOVX    A,@DPTR
   \   0001B7   FB           MOV     R3,A
   \   0001B8   12....       LCALL   ??strcat?relay
   \   0001BB   05..         INC     ?V0 + 0
   \                     ??_ltoa_15:
   \   0001BD   85....       MOV     ?V0 + 2,?V0 + 0
   \   0001C0                ; Setup parameters for call to function strlen
   \   0001C0   7406         MOV     A,#0x6
   \   0001C2   12....       LCALL   ?XSTACK_DISP0_8
   \   0001C5   AA82         MOV     R2,DPL
   \   0001C7   AB83         MOV     R3,DPH
   \   0001C9   12....       LCALL   ??strlen?relay
   \   0001CC   8A..         MOV     ?V0 + 4,R2
   \   0001CE   8B..         MOV     ?V0 + 5,R3
   \   0001D0   7404         MOV     A,#0x4
   \   0001D2   C3           CLR     C
   \   0001D3   95..         SUBB    A,?V0 + 4
   \   0001D5   F8           MOV     R0,A
   \   0001D6   E4           CLR     A
   \   0001D7   95..         SUBB    A,?V0 + 5
   \   0001D9   F9           MOV     R1,A
   \   0001DA   C3           CLR     C
   \   0001DB   E5..         MOV     A,?V0 + 2
   \   0001DD   98           SUBB    A,R0
   \   0001DE   E4           CLR     A
   \   0001DF   99           SUBB    A,R1
   \   0001E0   40C8         JC      ??_ltoa_16
    293              }
    294              strcat((char*)buf, (char const*)tmp1);
   \                     ??_ltoa_14:
   \   0001E2                ; Setup parameters for call to function strcat
   \   0001E2   7406         MOV     A,#0x6
   \   0001E4   12....       LCALL   ?XSTACK_DISP0_8
   \   0001E7   AC82         MOV     R4,DPL
   \   0001E9   AD83         MOV     R5,DPH
   \   0001EB   7434         MOV     A,#0x34
   \   0001ED   12....       LCALL   ?XSTACK_DISP0_8
   \   0001F0   E0           MOVX    A,@DPTR
   \   0001F1   FA           MOV     R2,A
   \   0001F2   A3           INC     DPTR
   \   0001F3   E0           MOVX    A,@DPTR
   \   0001F4   FB           MOV     R3,A
   \   0001F5   12....       LCALL   ??strcat?relay
    295              if (!num3 && !num2 && !num1)
   \   0001F8   E5..         MOV     A,?V0 + 6
   \   0001FA   7002         JNZ     ??_ltoa_17
   \   0001FC   E5..         MOV     A,?V0 + 7
   \                     ??_ltoa_17:
   \   0001FE   7024         JNZ     ??_ltoa_18
   \   000200   EE           MOV     A,R6
   \   000201   7001         JNZ     ??_ltoa_19
   \   000203   EF           MOV     A,R7
   \                     ??_ltoa_19:
   \   000204   701E         JNZ     ??_ltoa_18
   \                     ??_ltoa_20:
   \   000206   85..82       MOV     DPL,?XSP + 0
   \   000209   85..83       MOV     DPH,?XSP + 1
   \   00020C   E0           MOVX    A,@DPTR
   \   00020D   7002         JNZ     ??_ltoa_21
   \   00020F   A3           INC     DPTR
   \   000210   E0           MOVX    A,@DPTR
   \                     ??_ltoa_21:
   \   000211   7011         JNZ     ??_ltoa_18
    296                strcpy((char*)buf, "0");
   \   000213                ; Setup parameters for call to function strcpy
   \   000213   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   000215   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   000217   7434         MOV     A,#0x34
   \   000219   12....       LCALL   ?XSTACK_DISP0_8
   \   00021C   E0           MOVX    A,@DPTR
   \   00021D   FA           MOV     R2,A
   \   00021E   A3           INC     DPTR
   \   00021F   E0           MOVX    A,@DPTR
   \   000220   FB           MOV     R3,A
   \   000221   12....       LCALL   ??strcpy?relay
    297            }
    298            else if ( radix == 16 )
    299            {
    300              num1 = l & 0x0000FFFF;
    301              num2 = l >> 16;
    302          
    303              if (num2) _itoa(num2, tmp2, 16);
    304              if (num1) _itoa(num1, tmp1, 16);
    305          
    306              if (num2)
    307              {
    308                strcpy((char*)buf,(char const*)tmp2);
    309                for (i = 0; i < 4 - strlen((char const*)tmp1); i++)
    310                  strcat((char*)buf, "0");
    311              }
    312              strcat((char*)buf, (char const*)tmp1);
    313              if (!num2 && !num1)
    314                strcpy((char*)buf, "0");
    315            }
    316            else
    317              return NULL;
    318          
    319            return buf;
   \                     ??_ltoa_18:
   \   000224   7434         MOV     A,#0x34
   \   000226   12....       LCALL   ?XSTACK_DISP0_8
   \   000229   E0           MOVX    A,@DPTR
   \   00022A   FA           MOV     R2,A
   \   00022B   A3           INC     DPTR
   \   00022C   E0           MOVX    A,@DPTR
   \   00022D   FB           MOV     R3,A
   \                     ??_ltoa_22:
   \   00022E   7424         MOV     A,#0x24
   \   000230   12....       LCALL   ?DEALLOC_XSTACK8
   \   000233   7F08         MOV     R7,#0x8
   \   000235   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??_ltoa_0:
   \   000238   7410         MOV     A,#0x10
   \   00023A   69           XRL     A,R1
   \   00023B   6003         JZ      $+5
   \   00023D   02....       LJMP    ??_ltoa_23 & 0xFFFF
   \   000240   7402         MOV     A,#0x2
   \   000242   12....       LCALL   ?XSTACK_DISP0_8
   \   000245   78..         MOV     R0,#?V0 + 0
   \   000247   12....       LCALL   ?L_MOV_X
   \   00024A   85..82       MOV     DPL,?XSP + 0
   \   00024D   85..83       MOV     DPH,?XSP + 1
   \   000250   E5..         MOV     A,?V0 + 0
   \   000252   F0           MOVX    @DPTR,A
   \   000253   A3           INC     DPTR
   \   000254   E5..         MOV     A,?V0 + 1
   \   000256   F0           MOVX    @DPTR,A
   \   000257   7402         MOV     A,#0x2
   \   000259   12....       LCALL   ?XSTACK_DISP0_8
   \   00025C   78..         MOV     R0,#?V0 + 0
   \   00025E   12....       LCALL   ?L_MOV_X
   \   000261   7410         MOV     A,#0x10
   \   000263   78..         MOV     R0,#?V0 + 0
   \   000265   12....       LCALL   ?UL_SHR
   \   000268   AE..         MOV     R6,?V0 + 0
   \   00026A   AF..         MOV     R7,?V0 + 1
   \   00026C   EE           MOV     A,R6
   \   00026D   7001         JNZ     ??_ltoa_24
   \   00026F   EF           MOV     A,R7
   \                     ??_ltoa_24:
   \   000270   6011         JZ      ??_ltoa_25
   \   000272                ; Setup parameters for call to function _itoa
   \   000272   7910         MOV     R1,#0x10
   \   000274   E9           MOV     A,R1
   \   000275   12....       LCALL   ?XSTACK_DISP0_8
   \   000278   AC82         MOV     R4,DPL
   \   00027A   AD83         MOV     R5,DPH
   \   00027C   EE           MOV     A,R6
   \   00027D   FA           MOV     R2,A
   \   00027E   EF           MOV     A,R7
   \   00027F   FB           MOV     R3,A
   \   000280   12....       LCALL   ??_itoa?relay
   \                     ??_ltoa_25:
   \   000283   85..82       MOV     DPL,?XSP + 0
   \   000286   85..83       MOV     DPH,?XSP + 1
   \   000289   E0           MOVX    A,@DPTR
   \   00028A   7002         JNZ     ??_ltoa_26
   \   00028C   A3           INC     DPTR
   \   00028D   E0           MOVX    A,@DPTR
   \                     ??_ltoa_26:
   \   00028E   6019         JZ      ??_ltoa_27
   \   000290                ; Setup parameters for call to function _itoa
   \   000290   7910         MOV     R1,#0x10
   \   000292   7406         MOV     A,#0x6
   \   000294   12....       LCALL   ?XSTACK_DISP0_8
   \   000297   AC82         MOV     R4,DPL
   \   000299   AD83         MOV     R5,DPH
   \   00029B   85..82       MOV     DPL,?XSP + 0
   \   00029E   85..83       MOV     DPH,?XSP + 1
   \   0002A1   E0           MOVX    A,@DPTR
   \   0002A2   FA           MOV     R2,A
   \   0002A3   A3           INC     DPTR
   \   0002A4   E0           MOVX    A,@DPTR
   \   0002A5   FB           MOV     R3,A
   \   0002A6   12....       LCALL   ??_itoa?relay
   \                     ??_ltoa_27:
   \   0002A9   EE           MOV     A,R6
   \   0002AA   7001         JNZ     ??_ltoa_28
   \   0002AC   EF           MOV     A,R7
   \                     ??_ltoa_28:
   \   0002AD   6053         JZ      ??_ltoa_29
   \   0002AF                ; Setup parameters for call to function strcpy
   \   0002AF   7410         MOV     A,#0x10
   \   0002B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0002B4   AC82         MOV     R4,DPL
   \   0002B6   AD83         MOV     R5,DPH
   \   0002B8   7434         MOV     A,#0x34
   \   0002BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0002BD   E0           MOVX    A,@DPTR
   \   0002BE   FA           MOV     R2,A
   \   0002BF   A3           INC     DPTR
   \   0002C0   E0           MOVX    A,@DPTR
   \   0002C1   FB           MOV     R3,A
   \   0002C2   12....       LCALL   ??strcpy?relay
   \   0002C5   75..00       MOV     ?V0 + 0,#0x0
   \   0002C8   8013         SJMP    ??_ltoa_30
   \                     ??_ltoa_31:
   \   0002CA                ; Setup parameters for call to function strcat
   \   0002CA   7C..         MOV     R4,#(`?<Constant "0">` & 0xff)
   \   0002CC   7D..         MOV     R5,#((`?<Constant "0">` >> 8) & 0xff)
   \   0002CE   7434         MOV     A,#0x34
   \   0002D0   12....       LCALL   ?XSTACK_DISP0_8
   \   0002D3   E0           MOVX    A,@DPTR
   \   0002D4   FA           MOV     R2,A
   \   0002D5   A3           INC     DPTR
   \   0002D6   E0           MOVX    A,@DPTR
   \   0002D7   FB           MOV     R3,A
   \   0002D8   12....       LCALL   ??strcat?relay
   \   0002DB   05..         INC     ?V0 + 0
   \                     ??_ltoa_30:
   \   0002DD   85....       MOV     ?V0 + 2,?V0 + 0
   \   0002E0                ; Setup parameters for call to function strlen
   \   0002E0   7406         MOV     A,#0x6
   \   0002E2   12....       LCALL   ?XSTACK_DISP0_8
   \   0002E5   AA82         MOV     R2,DPL
   \   0002E7   AB83         MOV     R3,DPH
   \   0002E9   12....       LCALL   ??strlen?relay
   \   0002EC   8A..         MOV     ?V0 + 4,R2
   \   0002EE   8B..         MOV     ?V0 + 5,R3
   \   0002F0   7404         MOV     A,#0x4
   \   0002F2   C3           CLR     C
   \   0002F3   95..         SUBB    A,?V0 + 4
   \   0002F5   F8           MOV     R0,A
   \   0002F6   E4           CLR     A
   \   0002F7   95..         SUBB    A,?V0 + 5
   \   0002F9   F9           MOV     R1,A
   \   0002FA   C3           CLR     C
   \   0002FB   E5..         MOV     A,?V0 + 2
   \   0002FD   98           SUBB    A,R0
   \   0002FE   E4           CLR     A
   \   0002FF   99           SUBB    A,R1
   \   000300   40C8         JC      ??_ltoa_31
   \                     ??_ltoa_29:
   \   000302                ; Setup parameters for call to function strcat
   \   000302   7406         MOV     A,#0x6
   \   000304   12....       LCALL   ?XSTACK_DISP0_8
   \   000307   AC82         MOV     R4,DPL
   \   000309   AD83         MOV     R5,DPH
   \   00030B   7434         MOV     A,#0x34
   \   00030D   12....       LCALL   ?XSTACK_DISP0_8
   \   000310   E0           MOVX    A,@DPTR
   \   000311   FA           MOV     R2,A
   \   000312   A3           INC     DPTR
   \   000313   E0           MOVX    A,@DPTR
   \   000314   FB           MOV     R3,A
   \   000315   12....       LCALL   ??strcat?relay
   \   000318   EE           MOV     A,R6
   \   000319   7001         JNZ     ??_ltoa_32
   \   00031B   EF           MOV     A,R7
   \                     ??_ltoa_32:
   \   00031C   6003         JZ      $+5
   \   00031E   02....       LJMP    ??_ltoa_18 & 0xFFFF
   \   000321   02....       LJMP    ??_ltoa_20 & 0xFFFF
   \                     ??_ltoa_23:
   \   000324   7A00         MOV     R2,#0x0
   \   000326   7B00         MOV     R3,#0x0
   \   000328   02....       LJMP    ??_ltoa_22 & 0xFFFF
    320          #endif
    321          }
    322          #endif // !defined(ZBIT) && !defined(ZBIT2)
    323          
    324          /*********************************************************************
    325           * @fn        osal_rand
    326           *
    327           * @brief    Random number generator
    328           *
    329           * @param   none
    330           *
    331           * @return  uint16 - new random number
    332           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    333          uint16 osal_rand( void )
   \                     osal_rand:
    334          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    335            return ( Onboard_rand() );
   \   000004                ; Setup parameters for call to function Onboard_rand
   \   000004   12....       LCALL   ??Onboard_rand?relay
   \   000007   D083         POP     DPH
   \   000009   D082         POP     DPL
   \   00000B   02....       LJMP    ?BRET
    336          }
    337          
    338          /*********************************************************************
    339           * API FUNCTIONS
    340           *********************************************************************/
    341          
    342          /*********************************************************************
    343           * @fn      osal_msg_allocate
    344           *
    345           * @brief
    346           *
    347           *    This function is called by a task to allocate a message buffer
    348           *    into which the task will encode the particular message it wishes
    349           *    to send.  This common buffer scheme is used to strictly limit the
    350           *    creation of message buffers within the system due to RAM size
    351           *    limitations on the microprocessor.   Note that all message buffers
    352           *    are a fixed size (at least initially).  The parameter len is kept
    353           *    in case a message pool with varying fixed message sizes is later
    354           *    created (for example, a pool of message buffers of size LARGE,
    355           *    MEDIUM and SMALL could be maintained and allocated based on request
    356           *    from the tasks).
    357           *
    358           *
    359           * @param   uint8 len  - wanted buffer length
    360           *
    361           *
    362           * @return  pointer to allocated buffer or NULL if allocation failed.
    363           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    364          uint8 * osal_msg_allocate( uint16 len )
   \                     osal_msg_allocate:
    365          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    366            osal_msg_hdr_t *hdr;
    367          
    368            if ( len == 0 )
   \   000009   EE           MOV     A,R6
   \   00000A   7001         JNZ     ??osal_msg_allocate_0
   \   00000C   EF           MOV     A,R7
   \                     ??osal_msg_allocate_0:
   \   00000D   7006         JNZ     ??osal_msg_allocate_1
    369              return ( NULL );
   \                     ??osal_msg_allocate_2:
   \   00000F   7A00         MOV     R2,#0x0
   \   000011   7B00         MOV     R3,#0x0
   \   000013   803E         SJMP    ??osal_msg_allocate_3
    370          
    371            hdr = (osal_msg_hdr_t *) osal_mem_alloc( (short)(len + sizeof( osal_msg_hdr_t )) );
   \                     ??osal_msg_allocate_1:
   \   000015                ; Setup parameters for call to function osal_mem_alloc
   \   000015   7405         MOV     A,#0x5
   \   000017   2E           ADD     A,R6
   \   000018   FA           MOV     R2,A
   \   000019   E4           CLR     A
   \   00001A   3F           ADDC    A,R7
   \   00001B   FB           MOV     R3,A
   \   00001C   12....       LCALL   ??osal_mem_alloc?relay
   \   00001F   8A..         MOV     ?V0 + 0,R2
   \   000021   8B..         MOV     ?V0 + 1,R3
   \   000023   A8..         MOV     R0,?V0 + 0
   \   000025   A9..         MOV     R1,?V0 + 1
    372            if ( hdr )
   \   000027   E8           MOV     A,R0
   \   000028   7001         JNZ     ??osal_msg_allocate_4
   \   00002A   E9           MOV     A,R1
   \                     ??osal_msg_allocate_4:
   \   00002B   60E2         JZ      ??osal_msg_allocate_2
    373            {
    374              hdr->next = NULL;
   \   00002D   8882         MOV     DPL,R0
   \   00002F   8983         MOV     DPH,R1
   \   000031   E4           CLR     A
   \   000032   F0           MOVX    @DPTR,A
   \   000033   A3           INC     DPTR
   \   000034   F0           MOVX    @DPTR,A
    375              hdr->len = len;
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   EE           MOV     A,R6
   \   00003C   F0           MOVX    @DPTR,A
   \   00003D   A3           INC     DPTR
   \   00003E   EF           MOV     A,R7
   \   00003F   F0           MOVX    @DPTR,A
    376              hdr->dest_id = TASK_NO_TASK;
   \   000040   74FF         MOV     A,#-0x1
   \   000042   8882         MOV     DPL,R0
   \   000044   8983         MOV     DPH,R1
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   F0           MOVX    @DPTR,A
    377              return ( (uint8 *) (hdr + 1) );
   \   00004B   E8           MOV     A,R0
   \   00004C   2405         ADD     A,#0x5
   \   00004E   FA           MOV     R2,A
   \   00004F   E9           MOV     A,R1
   \   000050   3400         ADDC    A,#0x0
   \   000052   FB           MOV     R3,A
   \                     ??osal_msg_allocate_3:
   \   000053   7F02         MOV     R7,#0x2
   \   000055   02....       LJMP    ?BANKED_LEAVE_XDATA
    378            }
    379            else
    380              return ( NULL );
    381          }
    382          
    383          /*********************************************************************
    384           * @fn      osal_msg_deallocate
    385           *
    386           * @brief
    387           *
    388           *    This function is used to deallocate a message buffer. This function
    389           *    is called by a task (or processing element) after it has finished
    390           *    processing a received message.
    391           *
    392           *
    393           * @param   uint8 *msg_ptr - pointer to new message buffer
    394           *
    395           * @return  SUCCESS, INVALID_MSG_POINTER
    396           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    397          uint8 osal_msg_deallocate( uint8 *msg_ptr )
   \                     osal_msg_deallocate:
    398          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    399            uint8 *x;
    400          
    401            if ( msg_ptr == NULL )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??osal_msg_deallocate_0
   \   000007   EB           MOV     A,R3
   \                     ??osal_msg_deallocate_0:
   \   000008   7004         JNZ     ??osal_msg_deallocate_1
    402              return ( INVALID_MSG_POINTER );
   \   00000A   7905         MOV     R1,#0x5
   \   00000C   8020         SJMP    ??osal_msg_deallocate_2
    403          
    404            // don't deallocate queued buffer
    405            if ( OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_deallocate_1:
   \   00000E   EA           MOV     A,R2
   \   00000F   24FF         ADD     A,#-0x1
   \   000011   F582         MOV     DPL,A
   \   000013   EB           MOV     A,R3
   \   000014   34FF         ADDC    A,#-0x1
   \   000016   F583         MOV     DPH,A
   \   000018   E0           MOVX    A,@DPTR
   \   000019   64FF         XRL     A,#0xff
   \   00001B   6004         JZ      ??osal_msg_deallocate_3
    406              return ( MSG_BUFFER_NOT_AVAIL );
   \   00001D   7904         MOV     R1,#0x4
   \   00001F   800D         SJMP    ??osal_msg_deallocate_2
    407          
    408            x = (uint8 *)((uint8 *)msg_ptr - sizeof( osal_msg_hdr_t ));
    409          
    410            osal_mem_free( (void *)x );
   \                     ??osal_msg_deallocate_3:
   \   000021                ; Setup parameters for call to function osal_mem_free
   \   000021   EA           MOV     A,R2
   \   000022   24FB         ADD     A,#-0x5
   \   000024   FA           MOV     R2,A
   \   000025   EB           MOV     A,R3
   \   000026   34FF         ADDC    A,#-0x1
   \   000028   FB           MOV     R3,A
   \   000029   12....       LCALL   ??osal_mem_free?relay
    411          
    412            return ( SUCCESS );
   \   00002C   7900         MOV     R1,#0x0
   \                     ??osal_msg_deallocate_2:
   \   00002E   D083         POP     DPH
   \   000030   D082         POP     DPL
   \   000032   02....       LJMP    ?BRET
    413          }
    414          
    415          /*********************************************************************
    416           * @fn      osal_msg_send
    417           *
    418           * @brief
    419           *
    420           *    This function is called by a task to send a command message to
    421           *    another task or processing element.  The sending_task field must
    422           *    refer to a valid task, since the task ID will be used
    423           *    for the response message.  This function will also set a message
    424           *    ready event in the destination tasks event list.
    425           *
    426           *
    427           * @param   uint8 destination task - Send msg to?  Task ID
    428           * @param   uint8 *msg_ptr - pointer to new message buffer
    429           * @param   uint8 len - length of data in message
    430           *
    431           * @return  SUCCESS, INVALID_TASK, INVALID_MSG_POINTER
    432           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    433          uint8 osal_msg_send( uint8 destination_task, uint8 *msg_ptr )
   \                     osal_msg_send:
    434          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    435            if ( msg_ptr == NULL )
   \   000007   EA           MOV     A,R2
   \   000008   7001         JNZ     ??osal_msg_send_0
   \   00000A   EB           MOV     A,R3
   \                     ??osal_msg_send_0:
   \   00000B   7004         JNZ     ??osal_msg_send_1
    436              return ( INVALID_MSG_POINTER );
   \                     ??osal_msg_send_2:
   \   00000D   7905         MOV     R1,#0x5
   \   00000F   8052         SJMP    ??osal_msg_send_3
    437          
    438            if ( destination_task >= tasksCnt )
   \                     ??osal_msg_send_1:
   \   000011   EE           MOV     A,R6
   \   000012   C0E0         PUSH    A
   \   000014   90....       MOV     DPTR,#tasksCnt
   \   000017   E0           MOVX    A,@DPTR
   \   000018   FC           MOV     R4,A
   \   000019   D0E0         POP     A
   \   00001B   C3           CLR     C
   \   00001C   9C           SUBB    A,R4
   \   00001D   4007         JC      ??osal_msg_send_4
    439            {
    440              osal_msg_deallocate( msg_ptr );
   \   00001F                ; Setup parameters for call to function osal_msg_deallocate
   \   00001F   12....       LCALL   ??osal_msg_deallocate?relay
    441              return ( INVALID_TASK );
   \   000022   7903         MOV     R1,#0x3
   \   000024   803D         SJMP    ??osal_msg_send_3
    442            }
    443          
    444            // Check the message header
    445            if ( OSAL_MSG_NEXT( msg_ptr ) != NULL ||
    446                 OSAL_MSG_ID( msg_ptr ) != TASK_NO_TASK )
   \                     ??osal_msg_send_4:
   \   000026   EA           MOV     A,R2
   \   000027   24FB         ADD     A,#-0x5
   \   000029   F582         MOV     DPL,A
   \   00002B   EB           MOV     A,R3
   \   00002C   34FF         ADDC    A,#-0x1
   \   00002E   F583         MOV     DPH,A
   \   000030   E0           MOVX    A,@DPTR
   \   000031   7002         JNZ     ??osal_msg_send_5
   \   000033   A3           INC     DPTR
   \   000034   E0           MOVX    A,@DPTR
   \                     ??osal_msg_send_5:
   \   000035   700F         JNZ     ??osal_msg_send_6
   \   000037   EA           MOV     A,R2
   \   000038   24FF         ADD     A,#-0x1
   \   00003A   F582         MOV     DPL,A
   \   00003C   EB           MOV     A,R3
   \   00003D   34FF         ADDC    A,#-0x1
   \   00003F   F583         MOV     DPH,A
   \   000041   E0           MOVX    A,@DPTR
   \   000042   64FF         XRL     A,#0xff
   \   000044   6005         JZ      ??osal_msg_send_7
    447            {
    448              osal_msg_deallocate( msg_ptr );
   \                     ??osal_msg_send_6:
   \   000046                ; Setup parameters for call to function osal_msg_deallocate
   \   000046   12....       LCALL   ??osal_msg_deallocate?relay
    449              return ( INVALID_MSG_POINTER );
   \   000049   80C2         SJMP    ??osal_msg_send_2
    450            }
    451          
    452            OSAL_MSG_ID( msg_ptr ) = destination_task;
   \                     ??osal_msg_send_7:
   \   00004B   EE           MOV     A,R6
   \   00004C   F0           MOVX    @DPTR,A
    453          
    454            // queue message
    455            osal_msg_enqueue( &osal_qHead, msg_ptr );
   \   00004D                ; Setup parameters for call to function osal_msg_enqueue
   \   00004D   EA           MOV     A,R2
   \   00004E   FC           MOV     R4,A
   \   00004F   EB           MOV     A,R3
   \   000050   FD           MOV     R5,A
   \   000051   7A..         MOV     R2,#(osal_qHead & 0xff)
   \   000053   7B..         MOV     R3,#((osal_qHead >> 8) & 0xff)
   \   000055   12....       LCALL   ??osal_msg_enqueue?relay
    456          
    457            // Signal the task that a message is waiting
    458            osal_set_event( destination_task, SYS_EVENT_MSG );
   \   000058                ; Setup parameters for call to function osal_set_event
   \   000058   7A00         MOV     R2,#0x0
   \   00005A   7B80         MOV     R3,#-0x80
   \   00005C   EE           MOV     A,R6
   \   00005D   F9           MOV     R1,A
   \   00005E   12....       LCALL   ??osal_set_event?relay
    459          
    460            return ( SUCCESS );
   \   000061   7900         MOV     R1,#0x0
   \                     ??osal_msg_send_3:
   \   000063   7F01         MOV     R7,#0x1
   \   000065   02....       LJMP    ?BANKED_LEAVE_XDATA
    461          }
    462          
    463          /*********************************************************************
    464           * @fn      osal_msg_receive
    465           *
    466           * @brief
    467           *
    468           *    This function is called by a task to retrieve a received command
    469           *    message. The calling task must deallocate the message buffer after
    470           *    processing the message using the osal_msg_deallocate() call.
    471           *
    472           * @param   uint8 task_id - receiving tasks ID
    473           *
    474           * @return  *uint8 - message information or NULL if no message
    475           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    476          uint8 *osal_msg_receive( uint8 task_id )
   \                     osal_msg_receive:
    477          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FC           MOV     R4,A
    478            osal_msg_hdr_t *listHdr;
    479            osal_msg_hdr_t *prevHdr = NULL;
   \   000007   75..00       MOV     ?V0 + 2,#0x0
   \   00000A   75..00       MOV     ?V0 + 3,#0x0
    480            osal_msg_hdr_t *foundHdr = NULL;
   \   00000D   7E00         MOV     R6,#0x0
   \   00000F   7F00         MOV     R7,#0x0
    481            halIntState_t   intState;
    482          
    483            // Hold off interrupts
    484            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000011   A2AF         MOV     C,0xa8.7
   \   000013   E4           CLR     A
   \   000014   92E0         MOV     0xE0 /* A   */.0,C
   \   000016   F5..         MOV     ?V0 + 0,A
   \   000018   C2AF         CLR     0xa8.7
    485          
    486            // Point to the top of the queue
    487            listHdr = osal_qHead;
   \   00001A   90....       MOV     DPTR,#osal_qHead
   \   00001D   8018         SJMP    ??osal_msg_receive_0
    488          
    489            // Look through the queue for a message that belongs to the asking task
    490            while ( listHdr != NULL )
    491            {
    492              if ( (listHdr - 1)->dest_id == task_id )
    493              {
    494                if ( foundHdr == NULL )
    495                {
    496                  // Save the first one
    497                  foundHdr = listHdr;
   \                     ??osal_msg_receive_1:
   \   00001F   E8           MOV     A,R0
   \   000020   FE           MOV     R6,A
   \   000021   E9           MOV     A,R1
   \   000022   FF           MOV     R7,A
    498                }
    499                else
    500                {
    501                  // Second msg found, stop looking
    502                  break;
    503                }
    504              }
    505              if ( foundHdr == NULL )
   \                     ??osal_msg_receive_2:
   \   000023   EE           MOV     A,R6
   \   000024   7001         JNZ     ??osal_msg_receive_3
   \   000026   EF           MOV     A,R7
   \                     ??osal_msg_receive_3:
   \   000027   7004         JNZ     ??osal_msg_receive_4
    506              {
    507                prevHdr = listHdr;
   \   000029   88..         MOV     ?V0 + 2,R0
   \   00002B   89..         MOV     ?V0 + 3,R1
    508              }
    509              listHdr = OSAL_MSG_NEXT( listHdr );
   \                     ??osal_msg_receive_4:
   \   00002D   E8           MOV     A,R0
   \   00002E   24FB         ADD     A,#-0x5
   \   000030   F582         MOV     DPL,A
   \   000032   E9           MOV     A,R1
   \   000033   34FF         ADDC    A,#-0x1
   \   000035   F583         MOV     DPH,A
   \                     ??osal_msg_receive_0:
   \   000037   E0           MOVX    A,@DPTR
   \   000038   F8           MOV     R0,A
   \   000039   A3           INC     DPTR
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   F9           MOV     R1,A
   \   00003C   E8           MOV     A,R0
   \   00003D   7001         JNZ     ??osal_msg_receive_5
   \   00003F   E9           MOV     A,R1
   \                     ??osal_msg_receive_5:
   \   000040   6014         JZ      ??osal_msg_receive_6
   \   000042   E8           MOV     A,R0
   \   000043   24FF         ADD     A,#-0x1
   \   000045   F582         MOV     DPL,A
   \   000047   E9           MOV     A,R1
   \   000048   34FF         ADDC    A,#-0x1
   \   00004A   F583         MOV     DPH,A
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   6C           XRL     A,R4
   \   00004E   70D3         JNZ     ??osal_msg_receive_2
   \   000050   EE           MOV     A,R6
   \   000051   7001         JNZ     ??osal_msg_receive_7
   \   000053   EF           MOV     A,R7
   \                     ??osal_msg_receive_7:
   \   000054   60C9         JZ      ??osal_msg_receive_1
    510            }
    511            
    512            // Is there more than one?
    513            if ( listHdr != NULL )
   \                     ??osal_msg_receive_6:
   \   000056   E8           MOV     A,R0
   \   000057   7001         JNZ     ??osal_msg_receive_8
   \   000059   E9           MOV     A,R1
   \                     ??osal_msg_receive_8:
   \   00005A   7A00         MOV     R2,#0x0
   \   00005C   7B80         MOV     R3,#-0x80
   \   00005E   6007         JZ      ??osal_msg_receive_9
    514            {
    515              // Yes, Signal the task that a message is waiting
    516              osal_set_event( task_id, SYS_EVENT_MSG );
   \   000060                ; Setup parameters for call to function osal_set_event
   \   000060   EC           MOV     A,R4
   \   000061   F9           MOV     R1,A
   \   000062   12....       LCALL   ??osal_set_event?relay
   \   000065   8005         SJMP    ??osal_msg_receive_10
    517            }
    518            else
    519            {
    520              // No more
    521              osal_clear_event( task_id, SYS_EVENT_MSG );
   \                     ??osal_msg_receive_9:
   \   000067                ; Setup parameters for call to function osal_clear_event
   \   000067   EC           MOV     A,R4
   \   000068   F9           MOV     R1,A
   \   000069   12....       LCALL   ??osal_clear_event?relay
    522            }
    523          
    524            // Did we find a message?
    525            if ( foundHdr != NULL )
   \                     ??osal_msg_receive_10:
   \   00006C   EE           MOV     A,R6
   \   00006D   7001         JNZ     ??osal_msg_receive_11
   \   00006F   EF           MOV     A,R7
   \                     ??osal_msg_receive_11:
   \   000070   6015         JZ      ??osal_msg_receive_12
    526            {
    527              // Take out of the link list
    528              osal_msg_extract( &osal_qHead, foundHdr, prevHdr );
   \   000072                ; Setup parameters for call to function osal_msg_extract
   \   000072   78..         MOV     R0,#?V0 + 2
   \   000074   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000077   EE           MOV     A,R6
   \   000078   FC           MOV     R4,A
   \   000079   EF           MOV     A,R7
   \   00007A   FD           MOV     R5,A
   \   00007B   7A..         MOV     R2,#(osal_qHead & 0xff)
   \   00007D   7B..         MOV     R3,#((osal_qHead >> 8) & 0xff)
   \   00007F   12....       LCALL   ??osal_msg_extract?relay
   \   000082   7402         MOV     A,#0x2
   \   000084   12....       LCALL   ?DEALLOC_XSTACK8
    529            }
    530          
    531            // Release interrupts
    532            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_receive_12:
   \   000087   E5..         MOV     A,?V0 + 0
   \   000089   A2E0         MOV     C,0xE0 /* A   */.0
   \   00008B   92AF         MOV     0xa8.7,C
    533          
    534            return ( (uint8*) foundHdr );
   \   00008D   EE           MOV     A,R6
   \   00008E   FA           MOV     R2,A
   \   00008F   EF           MOV     A,R7
   \   000090   FB           MOV     R3,A
   \   000091   7F04         MOV     R7,#0x4
   \   000093   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000096                REQUIRE _A_IEN0
    535          }
    536          
    537          /*********************************************************************
    538           * @fn      osal_msg_enqueue
    539           *
    540           * @brief
    541           *
    542           *    This function enqueues an OSAL message into an OSAL queue.
    543           *
    544           * @param   osal_msg_q_t *q_ptr - OSAL queue
    545           * @param   void *msg_ptr  - OSAL message
    546           *
    547           * @return  none
    548           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    549          void osal_msg_enqueue( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_enqueue:
    550          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    551            void *list;
    552            halIntState_t intState;
    553          
    554            // Hold off interrupts
    555            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FE           MOV     R6,A
   \   00000B   C2AF         CLR     0xa8.7
    556          
    557            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   00000D   EC           MOV     A,R4
   \   00000E   24FB         ADD     A,#-0x5
   \   000010   F582         MOV     DPL,A
   \   000012   ED           MOV     A,R5
   \   000013   34FF         ADDC    A,#-0x1
   \   000015   F583         MOV     DPH,A
   \   000017   E4           CLR     A
   \   000018   F0           MOVX    @DPTR,A
   \   000019   A3           INC     DPTR
   \   00001A   F0           MOVX    @DPTR,A
    558            // If first message in queue
    559            if ( *q_ptr == NULL )
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   E0           MOVX    A,@DPTR
   \   000020   7002         JNZ     ??osal_msg_enqueue_0
   \   000022   A3           INC     DPTR
   \   000023   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_0:
   \   000024   8A82         MOV     DPL,R2
   \   000026   8B83         MOV     DPH,R3
   \   000028   601C         JZ      ??osal_msg_enqueue_1
    560            {
    561              *q_ptr = msg_ptr;
    562            }
    563            else
    564            {
    565              // Find end of queue
    566              for ( list = *q_ptr; OSAL_MSG_NEXT( list ) != NULL; list = OSAL_MSG_NEXT( list ) );
   \                     ??osal_msg_enqueue_2:
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F8           MOV     R0,A
   \   00002C   A3           INC     DPTR
   \   00002D   E0           MOVX    A,@DPTR
   \   00002E   F9           MOV     R1,A
   \   00002F   E8           MOV     A,R0
   \   000030   24FB         ADD     A,#-0x5
   \   000032   F8           MOV     R0,A
   \   000033   E9           MOV     A,R1
   \   000034   34FF         ADDC    A,#-0x1
   \   000036   F9           MOV     R1,A
   \   000037   8882         MOV     DPL,R0
   \   000039   8983         MOV     DPH,R1
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   7002         JNZ     ??osal_msg_enqueue_3
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_3:
   \   000040   8882         MOV     DPL,R0
   \   000042   8983         MOV     DPH,R1
   \   000044   70E4         JNZ     ??osal_msg_enqueue_2
    567          
    568              // Add message to end of queue
    569              OSAL_MSG_NEXT( list ) = msg_ptr;
   \                     ??osal_msg_enqueue_1:
   \   000046   EC           MOV     A,R4
   \   000047   F0           MOVX    @DPTR,A
   \   000048   A3           INC     DPTR
   \   000049   ED           MOV     A,R5
   \   00004A   F0           MOVX    @DPTR,A
    570            }
    571          
    572            // Re-enable interrupts
    573            HAL_EXIT_CRITICAL_SECTION(intState);
   \   00004B   EE           MOV     A,R6
   \   00004C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00004E   92AF         MOV     0xa8.7,C
    574          }
   \   000050   7F01         MOV     R7,#0x1
   \   000052   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000055                REQUIRE _A_IEN0
    575          
    576          /*********************************************************************
    577           * @fn      osal_msg_dequeue
    578           *
    579           * @brief
    580           *
    581           *    This function dequeues an OSAL message from an OSAL queue.
    582           *
    583           * @param   osal_msg_q_t *q_ptr - OSAL queue
    584           *
    585           * @return  void * - pointer to OSAL message or NULL of queue is empty.
    586           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    587          void *osal_msg_dequeue( osal_msg_q_t *q_ptr )
   \                     osal_msg_dequeue:
    588          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   F8           MOV     R0,A
   \   000007   EB           MOV     A,R3
   \   000008   F9           MOV     R1,A
    589            void *msg_ptr = NULL;
   \   000009   7A00         MOV     R2,#0x0
   \   00000B   7B00         MOV     R3,#0x0
    590            halIntState_t intState;
    591          
    592            // Hold off interrupts
    593            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000D   A2AF         MOV     C,0xa8.7
   \   00000F   E4           CLR     A
   \   000010   92E0         MOV     0xE0 /* A   */.0,C
   \   000012   F5..         MOV     ?V0 + 0,A
   \   000014   C2AF         CLR     0xa8.7
    594          
    595            if ( *q_ptr != NULL )
   \   000016   8882         MOV     DPL,R0
   \   000018   8983         MOV     DPH,R1
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   7002         JNZ     ??osal_msg_dequeue_0
   \   00001D   A3           INC     DPTR
   \   00001E   E0           MOVX    A,@DPTR
   \                     ??osal_msg_dequeue_0:
   \   00001F   603C         JZ      ??osal_msg_dequeue_1
    596            {
    597              // Dequeue message
    598              msg_ptr = *q_ptr;
   \   000021   8882         MOV     DPL,R0
   \   000023   8983         MOV     DPH,R1
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FA           MOV     R2,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FB           MOV     R3,A
    599              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   00002A   EA           MOV     A,R2
   \   00002B   24FB         ADD     A,#-0x5
   \   00002D   FC           MOV     R4,A
   \   00002E   EB           MOV     A,R3
   \   00002F   34FF         ADDC    A,#-0x1
   \   000031   FD           MOV     R5,A
   \   000032   8C82         MOV     DPL,R4
   \   000034   8D83         MOV     DPH,R5
   \   000036   E0           MOVX    A,@DPTR
   \   000037   FE           MOV     R6,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   FF           MOV     R7,A
   \   00003B   8882         MOV     DPL,R0
   \   00003D   8983         MOV     DPH,R1
   \   00003F   EE           MOV     A,R6
   \   000040   F0           MOVX    @DPTR,A
   \   000041   A3           INC     DPTR
   \   000042   EF           MOV     A,R7
   \   000043   F0           MOVX    @DPTR,A
    600              OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   000044   8C82         MOV     DPL,R4
   \   000046   8D83         MOV     DPH,R5
   \   000048   E4           CLR     A
   \   000049   F0           MOVX    @DPTR,A
   \   00004A   A3           INC     DPTR
   \   00004B   F0           MOVX    @DPTR,A
    601              OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   00004C   74FF         MOV     A,#-0x1
   \   00004E   C0E0         PUSH    A
   \   000050   EA           MOV     A,R2
   \   000051   24FF         ADD     A,#-0x1
   \   000053   F582         MOV     DPL,A
   \   000055   EB           MOV     A,R3
   \   000056   34FF         ADDC    A,#-0x1
   \   000058   F583         MOV     DPH,A
   \   00005A   D0E0         POP     A
   \   00005C   F0           MOVX    @DPTR,A
    602            }
    603          
    604            // Re-enable interrupts
    605            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_dequeue_1:
   \   00005D   E5..         MOV     A,?V0 + 0
   \   00005F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000061   92AF         MOV     0xa8.7,C
    606          
    607            return msg_ptr;
   \   000063   7F02         MOV     R7,#0x2
   \   000065   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000068                REQUIRE _A_IEN0
    608          }
    609          
    610          /*********************************************************************
    611           * @fn      osal_msg_push
    612           *
    613           * @brief
    614           *
    615           *    This function pushes an OSAL message to the head of an OSAL
    616           *    queue.
    617           *
    618           * @param   osal_msg_q_t *q_ptr - OSAL queue
    619           * @param   void *msg_ptr  - OSAL message
    620           *
    621           * @return  none
    622           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    623          void osal_msg_push( osal_msg_q_t *q_ptr, void *msg_ptr )
   \                     osal_msg_push:
    624          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    625            halIntState_t intState;
    626          
    627            // Hold off interrupts
    628            HAL_ENTER_CRITICAL_SECTION(intState);
   \   000005   A2AF         MOV     C,0xa8.7
   \   000007   E4           CLR     A
   \   000008   92E0         MOV     0xE0 /* A   */.0,C
   \   00000A   FE           MOV     R6,A
   \   00000B   C2AF         CLR     0xa8.7
    629          
    630            // Push message to head of queue
    631            OSAL_MSG_NEXT( msg_ptr ) = *q_ptr;
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   E0           MOVX    A,@DPTR
   \   000012   F8           MOV     R0,A
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \   000015   F9           MOV     R1,A
   \   000016   EC           MOV     A,R4
   \   000017   24FB         ADD     A,#-0x5
   \   000019   F582         MOV     DPL,A
   \   00001B   ED           MOV     A,R5
   \   00001C   34FF         ADDC    A,#-0x1
   \   00001E   F583         MOV     DPH,A
   \   000020   E8           MOV     A,R0
   \   000021   F0           MOVX    @DPTR,A
   \   000022   A3           INC     DPTR
   \   000023   E9           MOV     A,R1
   \   000024   F0           MOVX    @DPTR,A
    632            *q_ptr = msg_ptr;
   \   000025   8A82         MOV     DPL,R2
   \   000027   8B83         MOV     DPH,R3
   \   000029   EC           MOV     A,R4
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   ED           MOV     A,R5
   \   00002D   F0           MOVX    @DPTR,A
    633          
    634            // Re-enable interrupts
    635            HAL_EXIT_CRITICAL_SECTION(intState);
   \   00002E   EE           MOV     A,R6
   \   00002F   A2E0         MOV     C,0xE0 /* A   */.0
   \   000031   92AF         MOV     0xa8.7,C
    636          }
   \   000033   7F01         MOV     R7,#0x1
   \   000035   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000038                REQUIRE _A_IEN0
    637          
    638          /*********************************************************************
    639           * @fn      osal_msg_extract
    640           *
    641           * @brief
    642           *
    643           *    This function extracts and removes an OSAL message from the
    644           *    middle of an OSAL queue.
    645           *
    646           * @param   osal_msg_q_t *q_ptr - OSAL queue
    647           * @param   void *msg_ptr  - OSAL message to be extracted
    648           * @param   void *prev_ptr  - OSAL message before msg_ptr in queue
    649           *
    650           * @return  none
    651           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    652          void osal_msg_extract( osal_msg_q_t *q_ptr, void *msg_ptr, void *prev_ptr )
   \                     osal_msg_extract:
    653          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 0
   \   000005   740B         MOV     A,#0xb
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F8           MOV     R0,A
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   F9           MOV     R1,A
    654            halIntState_t intState;
    655          
    656            // Hold off interrupts
    657            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000F   A2AF         MOV     C,0xa8.7
   \   000011   E4           CLR     A
   \   000012   92E0         MOV     0xE0 /* A   */.0,C
   \   000014   F5..         MOV     ?V0 + 2,A
   \   000016   C2AF         CLR     0xa8.7
    658          
    659            if ( msg_ptr == *q_ptr )
   \   000018   EC           MOV     A,R4
   \   000019   24FB         ADD     A,#-0x5
   \   00001B   FE           MOV     R6,A
   \   00001C   ED           MOV     A,R5
   \   00001D   34FF         ADDC    A,#-0x1
   \   00001F   FF           MOV     R7,A
   \   000020   8A82         MOV     DPL,R2
   \   000022   8B83         MOV     DPH,R3
   \   000024   E0           MOVX    A,@DPTR
   \   000025   F5..         MOV     ?V0 + 0,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   F5..         MOV     ?V0 + 1,A
   \   00002B   EC           MOV     A,R4
   \   00002C   65..         XRL     A,?V0 + 0
   \   00002E   7003         JNZ     ??osal_msg_extract_0
   \   000030   ED           MOV     A,R5
   \   000031   65..         XRL     A,?V0 + 1
   \                     ??osal_msg_extract_0:
   \   000033   8E82         MOV     DPL,R6
   \   000035   8F83         MOV     DPH,R7
   \   000037   700F         JNZ     ??osal_msg_extract_1
    660            {
    661              // remove from first
    662              *q_ptr = OSAL_MSG_NEXT( msg_ptr );
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   F8           MOV     R0,A
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   F9           MOV     R1,A
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   E8           MOV     A,R0
   \   000043   F0           MOVX    @DPTR,A
   \   000044   A3           INC     DPTR
   \   000045   E9           MOV     A,R1
   \   000046   8013         SJMP    ??osal_msg_extract_2
    663            }
    664            else
    665            {
    666              // remove from middle
    667              OSAL_MSG_NEXT( prev_ptr ) = OSAL_MSG_NEXT( msg_ptr );
   \                     ??osal_msg_extract_1:
   \   000048   E0           MOVX    A,@DPTR
   \   000049   FA           MOV     R2,A
   \   00004A   A3           INC     DPTR
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FB           MOV     R3,A
   \   00004D   E8           MOV     A,R0
   \   00004E   24FB         ADD     A,#-0x5
   \   000050   F582         MOV     DPL,A
   \   000052   E9           MOV     A,R1
   \   000053   34FF         ADDC    A,#-0x1
   \   000055   F583         MOV     DPH,A
   \   000057   EA           MOV     A,R2
   \   000058   F0           MOVX    @DPTR,A
   \   000059   A3           INC     DPTR
   \   00005A   EB           MOV     A,R3
   \                     ??osal_msg_extract_2:
   \   00005B   F0           MOVX    @DPTR,A
    668            }
    669            OSAL_MSG_NEXT( msg_ptr ) = NULL;
   \   00005C   8E82         MOV     DPL,R6
   \   00005E   8F83         MOV     DPH,R7
   \   000060   E4           CLR     A
   \   000061   F0           MOVX    @DPTR,A
   \   000062   A3           INC     DPTR
   \   000063   F0           MOVX    @DPTR,A
    670            OSAL_MSG_ID( msg_ptr ) = TASK_NO_TASK;
   \   000064   74FF         MOV     A,#-0x1
   \   000066   C0E0         PUSH    A
   \   000068   EC           MOV     A,R4
   \   000069   24FF         ADD     A,#-0x1
   \   00006B   F582         MOV     DPL,A
   \   00006D   ED           MOV     A,R5
   \   00006E   34FF         ADDC    A,#-0x1
   \   000070   F583         MOV     DPH,A
   \   000072   D0E0         POP     A
   \   000074   F0           MOVX    @DPTR,A
    671          
    672            // Re-enable interrupts
    673            HAL_EXIT_CRITICAL_SECTION(intState);
   \   000075   E5..         MOV     A,?V0 + 2
   \   000077   A2E0         MOV     C,0xE0 /* A   */.0
   \   000079   92AF         MOV     0xa8.7,C
    674          }
   \   00007B   7F03         MOV     R7,#0x3
   \   00007D   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000080                REQUIRE _A_IEN0
    675          
    676          /*********************************************************************
    677           * @fn      osal_msg_enqueue_max
    678           *
    679           * @brief
    680           *
    681           *    This function enqueues an OSAL message into an OSAL queue if
    682           *    the length of the queue is less than max.
    683           *
    684           * @param   osal_msg_q_t *q_ptr - OSAL queue
    685           * @param   void *msg_ptr  - OSAL message
    686           * @param   uint8 max - maximum length of queue
    687           *
    688           * @return  TRUE if message was enqueued, FALSE otherwise
    689           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    690          uint8 osal_msg_enqueue_max( osal_msg_q_t *q_ptr, void *msg_ptr, uint8 max )
   \                     osal_msg_enqueue_max:
    691          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   E9           MOV     A,R1
   \   000006   FE           MOV     R6,A
    692            void *list;
    693            uint8 ret = FALSE;
   \   000007   75..00       MOV     ?V0 + 0,#0x0
    694            halIntState_t intState;
    695          
    696            // Hold off interrupts
    697            HAL_ENTER_CRITICAL_SECTION(intState);
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   92E0         MOV     0xE0 /* A   */.0,C
   \   00000F   FF           MOV     R7,A
   \   000010   C2AF         CLR     0xa8.7
    698          
    699            // If first message in queue
    700            if ( *q_ptr == NULL )
   \   000012   8A82         MOV     DPL,R2
   \   000014   8B83         MOV     DPH,R3
   \   000016   E0           MOVX    A,@DPTR
   \   000017   7002         JNZ     ??osal_msg_enqueue_max_0
   \   000019   A3           INC     DPTR
   \   00001A   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_max_0:
   \   00001B   8A82         MOV     DPL,R2
   \   00001D   8B83         MOV     DPH,R3
   \   00001F   7006         JNZ     ??osal_msg_enqueue_max_1
    701            {
    702              *q_ptr = msg_ptr;
   \   000021   8027         SJMP    ??osal_msg_enqueue_max_2
    703              ret = TRUE;
    704            }
    705            else
    706            {
    707              // Find end of queue or max
    708              list = *q_ptr;
    709              max--;
    710              while ( (OSAL_MSG_NEXT( list ) != NULL) && (max > 0) )
    711              {
    712                list = OSAL_MSG_NEXT( list );
   \                     ??osal_msg_enqueue_max_3:
   \   000023   8882         MOV     DPL,R0
   \   000025   8983         MOV     DPH,R1
   \                     ??osal_msg_enqueue_max_1:
   \   000027   E0           MOVX    A,@DPTR
   \   000028   F8           MOV     R0,A
   \   000029   A3           INC     DPTR
   \   00002A   E0           MOVX    A,@DPTR
   \   00002B   F9           MOV     R1,A
    713                max--;
   \   00002C   1E           DEC     R6
    714              }
   \   00002D   E8           MOV     A,R0
   \   00002E   24FB         ADD     A,#-0x5
   \   000030   F8           MOV     R0,A
   \   000031   E9           MOV     A,R1
   \   000032   34FF         ADDC    A,#-0x1
   \   000034   F9           MOV     R1,A
   \   000035   8882         MOV     DPL,R0
   \   000037   8983         MOV     DPH,R1
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   7002         JNZ     ??osal_msg_enqueue_max_4
   \   00003C   A3           INC     DPTR
   \   00003D   E0           MOVX    A,@DPTR
   \                     ??osal_msg_enqueue_max_4:
   \   00003E   6003         JZ      ??osal_msg_enqueue_max_5
   \   000040   EE           MOV     A,R6
   \   000041   70E0         JNZ     ??osal_msg_enqueue_max_3
    715          
    716              // Add message to end of queue if max not reached
    717              if ( max != 0 )
   \                     ??osal_msg_enqueue_max_5:
   \   000043   EE           MOV     A,R6
   \   000044   600C         JZ      ??osal_msg_enqueue_max_6
    718              {
    719                OSAL_MSG_NEXT( list ) = msg_ptr;
   \   000046   8882         MOV     DPL,R0
   \   000048   8983         MOV     DPH,R1
   \                     ??osal_msg_enqueue_max_2:
   \   00004A   EC           MOV     A,R4
   \   00004B   F0           MOVX    @DPTR,A
   \   00004C   A3           INC     DPTR
   \   00004D   ED           MOV     A,R5
   \   00004E   F0           MOVX    @DPTR,A
    720                ret = TRUE;
   \   00004F   75..01       MOV     ?V0 + 0,#0x1
    721              }
    722            }
    723          
    724            // Re-enable interrupts
    725            HAL_EXIT_CRITICAL_SECTION(intState);
   \                     ??osal_msg_enqueue_max_6:
   \   000052   EF           MOV     A,R7
   \   000053   A2E0         MOV     C,0xE0 /* A   */.0
   \   000055   92AF         MOV     0xa8.7,C
    726          
    727            return ret;
   \   000057   A9..         MOV     R1,?V0 + 0
   \   000059   7F02         MOV     R7,#0x2
   \   00005B   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00005E                REQUIRE _A_IEN0
    728          }
    729          
    730          /*********************************************************************
    731           * @fn      osal_set_event
    732           *
    733           * @brief
    734           *
    735           *    This function is called to set the event flags for a task.  The
    736           *    event passed in is OR'd into the task's event variable.
    737           *
    738           * @param   uint8 task_id - receiving tasks ID
    739           * @param   uint8 event_flag - what event to set
    740           *
    741           * @return  SUCCESS, INVALID_TASK
    742           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    743          uint8 osal_set_event( uint8 task_id, uint16 event_flag )
   \                     osal_set_event:
    744          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    745            if ( task_id < tasksCnt )
   \   000004   E9           MOV     A,R1
   \   000005   C0E0         PUSH    A
   \   000007   90....       MOV     DPTR,#tasksCnt
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FC           MOV     R4,A
   \   00000C   D0E0         POP     A
   \   00000E   C3           CLR     C
   \   00000F   9C           SUBB    A,R4
   \   000010   502C         JNC     ??osal_set_event_0
    746            {
    747              halIntState_t   intState;
    748              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   000012   A2AF         MOV     C,0xa8.7
   \   000014   E4           CLR     A
   \   000015   92E0         MOV     0xE0 /* A   */.0,C
   \   000017   FD           MOV     R5,A
   \   000018   C2AF         CLR     0xa8.7
    749              tasksEvents[task_id] |= event_flag;  // Stuff the event bit(s)
   \   00001A   E9           MOV     A,R1
   \   00001B   C3           CLR     C
   \   00001C   33           RLC     A
   \   00001D   F8           MOV     R0,A
   \   00001E   E4           CLR     A
   \   00001F   33           RLC     A
   \   000020   F9           MOV     R1,A
   \   000021   90....       MOV     DPTR,#tasksEvents
   \   000024   E0           MOVX    A,@DPTR
   \   000025   28           ADD     A,R0
   \   000026   FC           MOV     R4,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   39           ADDC    A,R1
   \   00002A   8C82         MOV     DPL,R4
   \   00002C   F583         MOV     DPH,A
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   4A           ORL     A,R2
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   4B           ORL     A,R3
   \   000034   F0           MOVX    @DPTR,A
    750              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   000035   ED           MOV     A,R5
   \   000036   A2E0         MOV     C,0xE0 /* A   */.0
   \   000038   92AF         MOV     0xa8.7,C
    751              return ( SUCCESS );
   \   00003A   7900         MOV     R1,#0x0
   \   00003C   8002         SJMP    ??osal_set_event_1
    752            }
    753             else
    754            {
    755              return ( INVALID_TASK );
   \                     ??osal_set_event_0:
   \   00003E   7903         MOV     R1,#0x3
   \                     ??osal_set_event_1:
   \   000040   D083         POP     DPH
   \   000042   D082         POP     DPL
   \   000044   02....       LJMP    ?BRET
   \   000047                REQUIRE _A_IEN0
    756            }
    757          }
    758          
    759          /*********************************************************************
    760           * @fn      osal_clear_event
    761           *
    762           * @brief
    763           *
    764           *    This function is called to clear the event flags for a task.  The
    765           *    event passed in is masked out of the task's event variable.
    766           *
    767           * @param   uint8 task_id - receiving tasks ID
    768           * @param   uint8 event_flag - what event to set
    769           *
    770           * @return  SUCCESS, INVALID_TASK
    771           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    772          static uint8 osal_clear_event( uint8 task_id, uint16 event_flag )
   \                     osal_clear_event:
    773          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    774            if ( task_id < tasksCnt )
   \   000005   E9           MOV     A,R1
   \   000006   C0E0         PUSH    A
   \   000008   90....       MOV     DPTR,#tasksCnt
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   FC           MOV     R4,A
   \   00000D   D0E0         POP     A
   \   00000F   C3           CLR     C
   \   000010   9C           SUBB    A,R4
   \   000011   5032         JNC     ??osal_clear_event_0
    775            {
    776              halIntState_t   intState;
    777              HAL_ENTER_CRITICAL_SECTION(intState);    // Hold off interrupts
   \   000013   A2AF         MOV     C,0xa8.7
   \   000015   E4           CLR     A
   \   000016   92E0         MOV     0xE0 /* A   */.0,C
   \   000018   FE           MOV     R6,A
   \   000019   C2AF         CLR     0xa8.7
    778              tasksEvents[task_id] &= ~(event_flag);   // clear the event bit(s)
   \   00001B   EA           MOV     A,R2
   \   00001C   F4           CPL     A
   \   00001D   FC           MOV     R4,A
   \   00001E   EB           MOV     A,R3
   \   00001F   F4           CPL     A
   \   000020   FD           MOV     R5,A
   \   000021   E9           MOV     A,R1
   \   000022   C3           CLR     C
   \   000023   33           RLC     A
   \   000024   F8           MOV     R0,A
   \   000025   E4           CLR     A
   \   000026   33           RLC     A
   \   000027   F9           MOV     R1,A
   \   000028   90....       MOV     DPTR,#tasksEvents
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   28           ADD     A,R0
   \   00002D   FA           MOV     R2,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   39           ADDC    A,R1
   \   000031   8A82         MOV     DPL,R2
   \   000033   F583         MOV     DPH,A
   \   000035   E0           MOVX    A,@DPTR
   \   000036   5C           ANL     A,R4
   \   000037   F0           MOVX    @DPTR,A
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   5D           ANL     A,R5
   \   00003B   F0           MOVX    @DPTR,A
    779              HAL_EXIT_CRITICAL_SECTION(intState);     // Release interrupts
   \   00003C   EE           MOV     A,R6
   \   00003D   A2E0         MOV     C,0xE0 /* A   */.0
   \   00003F   92AF         MOV     0xa8.7,C
    780              return ( SUCCESS );
   \   000041   7900         MOV     R1,#0x0
   \   000043   8002         SJMP    ??osal_clear_event_1
    781            }
    782             else
    783            {
    784              return ( INVALID_TASK );
   \                     ??osal_clear_event_0:
   \   000045   7903         MOV     R1,#0x3
   \                     ??osal_clear_event_1:
   \   000047   7F01         MOV     R7,#0x1
   \   000049   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   00004C                REQUIRE _A_IEN0
    785            }
    786          }
    787          
    788          /*********************************************************************
    789           * @fn      osal_isr_register
    790           *
    791           * @brief
    792           *
    793           *   This function is called to register a service routine with an
    794           *   interrupt. When the interrupt occurs, this service routine is called.
    795           *
    796           * @param   uint8 interrupt_id - Interrupt number
    797           * @param   void (*isr_ptr)( uint8* ) - function pointer to ISR
    798           *
    799           * @return  SUCCESS, INVALID_INTERRUPT_ID,
    800           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    801          uint8 osal_isr_register( uint8 interrupt_id, void (*isr_ptr)( uint8* ) )
   \                     osal_isr_register:
    802          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    803            // Remove these statements when functionality is complete
    804            (void)interrupt_id;
    805            (void)isr_ptr;
    806            return ( SUCCESS );
   \   000000   7900         MOV     R1,#0x0
   \   000002   02....       LJMP    ?BRET
    807          }
    808          
    809          /*********************************************************************
    810           * @fn      osal_int_enable
    811           *
    812           * @brief
    813           *
    814           *   This function is called to enable an interrupt. Once enabled,
    815           *   occurrence of the interrupt causes the service routine associated
    816           *   with that interrupt to be called.
    817           *
    818           *   If INTS_ALL is the interrupt_id, interrupts (in general) are enabled.
    819           *   If a single interrupt is passed in, then interrupts still have
    820           *   to be enabled with another call to INTS_ALL.
    821           *
    822           * @param   uint8 interrupt_id - Interrupt number
    823           *
    824           * @return  SUCCESS or INVALID_INTERRUPT_ID
    825           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    826          uint8 osal_int_enable( uint8 interrupt_id )
   \                     osal_int_enable:
    827          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    828          
    829            if ( interrupt_id == INTS_ALL )
   \   000000   74FF         MOV     A,#-0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??osal_int_enable_0
    830            {
    831              HAL_ENABLE_INTERRUPTS();
   \   000005   D2AF         SETB    0xa8.7
    832              return ( SUCCESS );
   \   000007   7900         MOV     R1,#0x0
   \   000009   8002         SJMP    ??osal_int_enable_1
    833            }
    834            else
    835            {
    836              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_enable_0:
   \   00000B   7907         MOV     R1,#0x7
   \                     ??osal_int_enable_1:
   \   00000D   02....       LJMP    ?BRET
   \   000010                REQUIRE _A_IEN0
    837            }
    838          }
    839          
    840          /*********************************************************************
    841           * @fn      osal_int_disable
    842           *
    843           * @brief
    844           *
    845           *   This function is called to disable an interrupt. When a disabled
    846           *   interrupt occurs, the service routine associated with that
    847           *   interrupt is not called.
    848           *
    849           *   If INTS_ALL is the interrupt_id, interrupts (in general) are disabled.
    850           *   If a single interrupt is passed in, then just that interrupt is disabled.
    851           *
    852           * @param   uint8 interrupt_id - Interrupt number
    853           *
    854           * @return  SUCCESS or INVALID_INTERRUPT_ID
    855           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    856          uint8 osal_int_disable( uint8 interrupt_id )
   \                     osal_int_disable:
    857          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    858          
    859            if ( interrupt_id == INTS_ALL )
   \   000000   74FF         MOV     A,#-0x1
   \   000002   69           XRL     A,R1
   \   000003   7006         JNZ     ??osal_int_disable_0
    860            {
    861              HAL_DISABLE_INTERRUPTS();
   \   000005   C2AF         CLR     0xa8.7
    862              return ( SUCCESS );
   \   000007   7900         MOV     R1,#0x0
   \   000009   8002         SJMP    ??osal_int_disable_1
    863            }
    864            else
    865            {
    866              return ( INVALID_INTERRUPT_ID );
   \                     ??osal_int_disable_0:
   \   00000B   7907         MOV     R1,#0x7
   \                     ??osal_int_disable_1:
   \   00000D   02....       LJMP    ?BRET
   \   000010                REQUIRE _A_IEN0
    867            }
    868          }
    869          
    870          /*********************************************************************
    871           * @fn      osal_init_system
    872           *
    873           * @brief
    874           *
    875           *   This function initializes the "task" system by creating the
    876           *   tasks defined in the task table (OSAL_Tasks.h).
    877           *
    878           * @param   void
    879           *
    880           * @return  SUCCESS
    881           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    882          uint8 osal_init_system( void )
   \                     osal_init_system:
    883          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    884            // Initialize the Memory Allocation System
    885            osal_mem_init();
   \   000004                ; Setup parameters for call to function osal_mem_init
   \   000004   12....       LCALL   ??osal_mem_init?relay
    886          
    887            // Initialize the message queue
    888            osal_qHead = NULL;
   \   000007   90....       MOV     DPTR,#osal_qHead
   \   00000A   E4           CLR     A
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   A3           INC     DPTR
   \   00000D   F0           MOVX    @DPTR,A
    889          
    890            // Initialize the timers
    891            osalTimerInit();
   \   00000E                ; Setup parameters for call to function osalTimerInit
   \   00000E   12....       LCALL   ??osalTimerInit?relay
    892          
    893            // Initialize the Power Management System
    894            osal_pwrmgr_init();
   \   000011                ; Setup parameters for call to function osal_pwrmgr_init
   \   000011   12....       LCALL   ??osal_pwrmgr_init?relay
    895          
    896            // Initialize the system tasks.
    897            osalInitTasks();
   \   000014                ; Setup parameters for call to function osalInitTasks
   \   000014   12....       LCALL   ??osalInitTasks?relay
    898          
    899            // Setup efficient search for the first free block of heap.
    900            osal_mem_kick();
   \   000017                ; Setup parameters for call to function osal_mem_kick
   \   000017   12....       LCALL   ??osal_mem_kick?relay
    901          
    902            return ( SUCCESS );
   \   00001A   7900         MOV     R1,#0x0
   \   00001C   D083         POP     DPH
   \   00001E   D082         POP     DPL
   \   000020   02....       LJMP    ?BRET
    903          }
    904          
    905          /*********************************************************************
    906           * @fn      osal_start_system
    907           *
    908           * @brief
    909           *
    910           *   This function is the main loop function of the task system.  It
    911           *   will look through all task events and call the task_event_processor()
    912           *   function for the task with the event.  If there are no events (for
    913           *   all tasks), this function puts the processor into Sleep.
    914           *   This Function doesn't return.
    915           *
    916           * @param   void
    917           *
    918           * @return  none
    919           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    920          void osal_start_system( void )
   \                     osal_start_system:
    921          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    922          #if !defined ( ZBIT ) && !defined ( UBIT )
    923            for(;;)  // Forever Loop
    924          #endif
    925            {
    926              uint8 idx = 0;
   \                     ??osal_start_system_0:
   \   000005   75..00       MOV     ?V0 + 0,#0x0
    927          
    928              osalTimeUpdate();
   \   000008                ; Setup parameters for call to function osalTimeUpdate
   \   000008   12....       LCALL   ??osalTimeUpdate?relay
    929              Hal_ProcessPoll();  // This replaces MT_SerialPoll() and osal_check_timer().
   \   00000B                ; Setup parameters for call to function Hal_ProcessPoll
   \   00000B   12....       LCALL   ??Hal_ProcessPoll?relay
    930              
    931              do {
    932                if (tasksEvents[idx])  // Task is highest priority that is ready.
   \                     ??osal_start_system_1:
   \   00000E   E5..         MOV     A,?V0 + 0
   \   000010   C3           CLR     C
   \   000011   33           RLC     A
   \   000012   F8           MOV     R0,A
   \   000013   E4           CLR     A
   \   000014   33           RLC     A
   \   000015   F9           MOV     R1,A
   \   000016   90....       MOV     DPTR,#tasksEvents
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   28           ADD     A,R0
   \   00001B   FA           MOV     R2,A
   \   00001C   A3           INC     DPTR
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   39           ADDC    A,R1
   \   00001F   8A82         MOV     DPL,R2
   \   000021   F583         MOV     DPH,A
   \   000023   E0           MOVX    A,@DPTR
   \   000024   7002         JNZ     ??osal_start_system_2
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \                     ??osal_start_system_2:
   \   000028   700D         JNZ     ??osal_start_system_3
    933                {
    934                  break;
    935                }
    936              } while (++idx < tasksCnt);
   \   00002A   05..         INC     ?V0 + 0
   \   00002C   90....       MOV     DPTR,#tasksCnt
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   FA           MOV     R2,A
   \   000031   E5..         MOV     A,?V0 + 0
   \   000033   C3           CLR     C
   \   000034   9A           SUBB    A,R2
   \   000035   40D7         JC      ??osal_start_system_1
    937          
    938              if (idx < tasksCnt)
   \                     ??osal_start_system_3:
   \   000037   90....       MOV     DPTR,#tasksCnt
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   FA           MOV     R2,A
   \   00003C   E5..         MOV     A,?V0 + 0
   \   00003E   C3           CLR     C
   \   00003F   9A           SUBB    A,R2
   \   000040   50C3         JNC     ??osal_start_system_0
    939              {
    940                uint16 events;
    941                halIntState_t intState;
    942          
    943                HAL_ENTER_CRITICAL_SECTION(intState);
   \   000042   A2AF         MOV     C,0xa8.7
   \   000044   E4           CLR     A
   \   000045   92E0         MOV     0xE0 /* A   */.0,C
   \   000047   FD           MOV     R5,A
   \   000048   C2AF         CLR     0xa8.7
    944                events = tasksEvents[idx];
   \   00004A   E5..         MOV     A,?V0 + 0
   \   00004C   C3           CLR     C
   \   00004D   33           RLC     A
   \   00004E   FE           MOV     R6,A
   \   00004F   E4           CLR     A
   \   000050   33           RLC     A
   \   000051   FF           MOV     R7,A
   \   000052   90....       MOV     DPTR,#tasksEvents
   \   000055   E0           MOVX    A,@DPTR
   \   000056   2E           ADD     A,R6
   \   000057   F8           MOV     R0,A
   \   000058   A3           INC     DPTR
   \   000059   E0           MOVX    A,@DPTR
   \   00005A   3F           ADDC    A,R7
   \   00005B   F9           MOV     R1,A
   \   00005C   8882         MOV     DPL,R0
   \   00005E   8983         MOV     DPH,R1
   \   000060   E0           MOVX    A,@DPTR
   \   000061   FA           MOV     R2,A
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   FB           MOV     R3,A
    945                tasksEvents[idx] = 0;  // Clear the Events for this task.
   \   000065   8882         MOV     DPL,R0
   \   000067   8983         MOV     DPH,R1
   \   000069   E4           CLR     A
   \   00006A   F0           MOVX    @DPTR,A
   \   00006B   A3           INC     DPTR
   \   00006C   F0           MOVX    @DPTR,A
    946                HAL_EXIT_CRITICAL_SECTION(intState);
   \   00006D   ED           MOV     A,R5
   \   00006E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000070   92AF         MOV     0xa8.7,C
    947          
    948                events = (tasksArr[idx])( idx, events );
   \   000072                ; Setup parameters for indirect call
   \   000072   A9..         MOV     R1,?V0 + 0
   \   000074   EE           MOV     A,R6
   \   000075   24..         ADD     A,#(tasksArr & 0xff)
   \   000077   F582         MOV     DPL,A
   \   000079   EF           MOV     A,R7
   \   00007A   34..         ADDC    A,#((tasksArr >> 8) & 0xff)
   \   00007C   F583         MOV     DPH,A
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   F8           MOV     R0,A
   \   000080   A3           INC     DPTR
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F583         MOV     DPH,A
   \   000084   8882         MOV     DPL,R0
   \   000086   12....       LCALL   ?CALL_IND
    949          
    950                HAL_ENTER_CRITICAL_SECTION(intState);
   \   000089   A2AF         MOV     C,0xa8.7
   \   00008B   E4           CLR     A
   \   00008C   92E0         MOV     0xE0 /* A   */.0,C
   \   00008E   FD           MOV     R5,A
   \   00008F   C2AF         CLR     0xa8.7
    951                tasksEvents[idx] |= events;  // Add back unprocessed events to the current task.
   \   000091   90....       MOV     DPTR,#tasksEvents
   \   000094   E0           MOVX    A,@DPTR
   \   000095   2E           ADD     A,R6
   \   000096   FC           MOV     R4,A
   \   000097   A3           INC     DPTR
   \   000098   E0           MOVX    A,@DPTR
   \   000099   3F           ADDC    A,R7
   \   00009A   8C82         MOV     DPL,R4
   \   00009C   F583         MOV     DPH,A
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   4A           ORL     A,R2
   \   0000A0   F0           MOVX    @DPTR,A
   \   0000A1   A3           INC     DPTR
   \   0000A2   E0           MOVX    A,@DPTR
   \   0000A3   4B           ORL     A,R3
   \   0000A4   F0           MOVX    @DPTR,A
    952                HAL_EXIT_CRITICAL_SECTION(intState);
   \   0000A5   ED           MOV     A,R5
   \   0000A6   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000A8   92AF         MOV     0xa8.7,C
   \   0000AA   02....       LJMP    ??osal_start_system_0 & 0xFFFF
   \   0000AD                REQUIRE _A_IEN0
    953              }
    954          #if defined( POWER_SAVING )
    955              else  // Complete pass through all task events with no activity?
    956              {
    957                osal_pwrmgr_powerconserve();  // Put the processor/system into sleep
    958              }
    959          #endif
    960            }
    961          }
    962          
    963          /*********************************************************************
    964           * @fn      osal_buffer_uint32
    965           *
    966           * @brief
    967           *
    968           *   Buffer an uint32 value - LSB first.
    969           *
    970           * @param   buf - buffer
    971           * @param   val - uint32 value
    972           *
    973           * @return  pointer to end of destination buffer
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          uint8* osal_buffer_uint32( uint8 *buf, uint32 val )
   \                     osal_buffer_uint32:
    976          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   78..         MOV     R0,#?V0 + 4
   \   00000C   12....       LCALL   ?L_MOV_X
    977            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   E5..         MOV     A,?V0 + 4
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
    978            *buf++ = BREAK_UINT32( val, 1 );
   \   000017   85....       MOV     ?V0 + 1,?V0 + 5
   \   00001A   E5..         MOV     A,?V0 + 1
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
    979            *buf++ = BREAK_UINT32( val, 2 );
   \   00001E   85....       MOV     ?V0 + 0,?V0 + 4
   \   000021   85....       MOV     ?V0 + 2,?V0 + 6
   \   000024   85....       MOV     ?V0 + 3,?V0 + 7
   \   000027   7410         MOV     A,#0x10
   \   000029   78..         MOV     R0,#?V0 + 0
   \   00002B   12....       LCALL   ?UL_SHR
   \   00002E   E5..         MOV     A,?V0 + 0
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
    980            *buf++ = BREAK_UINT32( val, 3 );
   \   000032   7418         MOV     A,#0x18
   \   000034   78..         MOV     R0,#?V0 + 4
   \   000036   12....       LCALL   ?UL_SHR
   \   000039   E5..         MOV     A,?V0 + 4
   \   00003B   F0           MOVX    @DPTR,A
   \   00003C   A3           INC     DPTR
   \   00003D   AA82         MOV     R2,DPL
   \   00003F   AB83         MOV     R3,DPH
    981          
    982            return buf;
   \   000041   7F08         MOV     R7,#0x8
   \   000043   02....       LJMP    ?BANKED_LEAVE_XDATA
    983          }
    984          
    985          /*********************************************************************
    986           * @fn      osal_buffer_uint24
    987           *
    988           * @brief
    989           *
    990           *   Buffer an uint24 value - LSB first. Note that type uint24 is
    991           *   typedef to uint32 in comdef.h
    992           *
    993           * @param   buf - buffer
    994           * @param   val - uint24 value
    995           *
    996           * @return  pointer to end of destination buffer
    997           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    998          uint8* osal_buffer_uint24( uint8 *buf, uint24 val )
   \                     osal_buffer_uint24:
    999          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 0
   \   000005   7410         MOV     A,#0x10
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   78..         MOV     R0,#?V0 + 4
   \   00000C   12....       LCALL   ?L_MOV_X
   1000            *buf++ = BREAK_UINT32( val, 0 );
   \   00000F   8A82         MOV     DPL,R2
   \   000011   8B83         MOV     DPH,R3
   \   000013   E5..         MOV     A,?V0 + 4
   \   000015   F0           MOVX    @DPTR,A
   \   000016   A3           INC     DPTR
   1001            *buf++ = BREAK_UINT32( val, 1 );
   \   000017   85....       MOV     ?V0 + 1,?V0 + 5
   \   00001A   E5..         MOV     A,?V0 + 1
   \   00001C   F0           MOVX    @DPTR,A
   \   00001D   A3           INC     DPTR
   1002            *buf++ = BREAK_UINT32( val, 2 );
   \   00001E   7410         MOV     A,#0x10
   \   000020   78..         MOV     R0,#?V0 + 4
   \   000022   12....       LCALL   ?UL_SHR
   \   000025   E5..         MOV     A,?V0 + 4
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   AA82         MOV     R2,DPL
   \   00002B   AB83         MOV     R3,DPH
   1003          
   1004            return buf;
   \   00002D   7F08         MOV     R7,#0x8
   \   00002F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1005          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_strlen?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_strlen

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memcpy?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcpy

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memcmp?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memcmp

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_memset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_memset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint16?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint16

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_build_uint32?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_build_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??_ltoa?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    _ltoa

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_rand?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_rand

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_allocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_allocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_deallocate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_deallocate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_send?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_send

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_receive?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_receive

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_dequeue?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_dequeue

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_push?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_push

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_extract?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_extract

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_msg_enqueue_max?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_msg_enqueue_max

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_set_event?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_set_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_clear_event?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_clear_event

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_isr_register?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_isr_register

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_enable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_enable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_int_disable?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_int_disable

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_init_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_init_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_start_system?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_start_system

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_buffer_uint32?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_buffer_uint32

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??osal_buffer_uint24?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    osal_buffer_uint24

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_1`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "">_2`:
   \   000000   00           DB ""
   \   000001   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 0
   \            00000000
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "0">`:
   \   000000   3000         DB "0"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2710:
   \   000000   10270000     DD 10000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_5f5e100:
   \   000000   00E1F505     DD 100000000
   1006          /*********************************************************************
   1007          *********************************************************************/

   Maximum stack usage in bytes:

     Function                 ISTACK PSTACK XSTACK
     --------                 ------ ------ ------
     _ltoa                        2      0     54
       -> _itoa                   0      0    104
       -> _itoa                   0      0    104
       -> _itoa                   0      0    104
       -> strcpy                  0      0    104
       -> strcat                  0      0    104
       -> strlen                  0      0    104
       -> strcat                  0      0    104
       -> strcat                  0      0    104
       -> strlen                  0      0    104
       -> strcat                  0      0    104
       -> strcpy                  0      0    104
       -> _itoa                   0      0    104
       -> _itoa                   0      0    104
       -> strcpy                  0      0    104
       -> strcat                  0      0    104
       -> strlen                  0      0    104
       -> strcat                  0      0    104
     osal_buffer_uint24           1      0     20
     osal_buffer_uint32           1      0     20
     osal_build_uint16            0      0      9
     osal_build_uint32            0      0     16
     osal_clear_event             1      0     21
     osal_init_system             2      0      0
       -> osal_mem_init           4      0      0
       -> osalTimerInit           4      0      0
       -> osal_pwrmgr_init        4      0      0
       -> osalInitTasks           4      0      0
       -> osal_mem_kick           4      0      0
     osal_int_disable             0      0      0
     osal_int_enable              0      0      0
     osal_isr_register            0      0      0
     osal_memcmp                  0      0     21
     osal_memcpy                  1      0     14
     osal_memset                  0      0     12
       -> memset                  0      0     24
     osal_msg_allocate            1      0     10
       -> osal_mem_alloc          0      0     20
     osal_msg_deallocate          2      0      9
       -> osal_mem_free           4      0      0
     osal_msg_dequeue             1      0     10
     osal_msg_enqueue             0      0     18
     osal_msg_enqueue_max         0      0     10
     osal_msg_extract             1      0     25
     osal_msg_push                0      0      9
     osal_msg_receive             0      0     14
       -> osal_set_event          0      0     24
       -> osal_clear_event        0      0     24
       -> osal_msg_extract        0      0     28
     osal_msg_send                1      0      9
       -> osal_msg_deallocate     0      0     18
       -> osal_msg_deallocate     0      0     18
       -> osal_msg_enqueue        0      0     18
       -> osal_set_event          0      0     18
     osal_rand                    2      0      0
       -> Onboard_rand            4      0      0
     osal_set_event               3      0     12
     osal_start_system            1      0     10
       -> osalTimeUpdate          0      0     20
       -> Hal_ProcessPoll         0      0     20
     osal_strlen                  2      0      0
       -> strlen                  4      0      0


   Segment part sizes:

     Function/Label               Bytes
     --------------               -----
     _A_IEN0                         1
     osal_qHead                      2
     osal_strlen                    14
     osal_memcpy                    74
     osal_memcmp                   176
     osal_memset                    31
     osal_build_uint16              23
     osal_build_uint32             233
     _ltoa                         811
     osal_rand                      14
     osal_msg_allocate              88
     osal_msg_deallocate            53
     osal_msg_send                 104
     osal_msg_receive              150
     osal_msg_enqueue               85
     osal_msg_dequeue              104
     osal_msg_push                  56
     osal_msg_extract              128
     osal_msg_enqueue_max           94
     osal_set_event                 71
     osal_clear_event               76
     osal_isr_register               5
     osal_int_enable                16
     osal_int_disable               16
     osal_init_system               35
     osal_start_system             173
     osal_buffer_uint32             70
     osal_buffer_uint24             50
     ??osal_strlen?relay             6
     ??osal_memcpy?relay             6
     ??osal_memcmp?relay             6
     ??osal_memset?relay             6
     ??osal_build_uint16?relay       6
     ??osal_build_uint32?relay       6
     ??_ltoa?relay                   6
     ??osal_rand?relay               6
     ??osal_msg_allocate?relay       6
     ??osal_msg_deallocate?relay     6
     ??osal_msg_send?relay           6
     ??osal_msg_receive?relay        6
     ??osal_msg_enqueue?relay        6
     ??osal_msg_dequeue?relay        6
     ??osal_msg_push?relay           6
     ??osal_msg_extract?relay        6
     ??osal_msg_enqueue_max?relay    6
     ??osal_set_event?relay          6
     ??osal_clear_event?relay        6
     ??osal_isr_register?relay       6
     ??osal_int_enable?relay         6
     ??osal_int_disable?relay        6
     ??osal_init_system?relay        6
     ??osal_start_system?relay       6
     ??osal_buffer_uint32?relay      6
     ??osal_buffer_uint24?relay      6
     ?<Constant "">                 10
     ?<Constant "">_1               10
     ?<Constant "">_2               10
     ?<Constant "0">                 2
     __Constant_2710                 4
     __Constant_5f5e100              4

 
 2 750 bytes in segment BANKED_CODE
   156 bytes in segment BANK_RELAYS
     1 byte  in segment SFR_AN
    40 bytes in segment XDATA_ROM_C
     2 bytes in segment XDATA_Z
 
 2 906 bytes of CODE  memory
    32 bytes of CONST memory (+ 8 bytes shared)
     0 bytes of DATA  memory (+ 1 byte  shared)
     2 bytes of XDATA memory

Errors: none
Warnings: none
