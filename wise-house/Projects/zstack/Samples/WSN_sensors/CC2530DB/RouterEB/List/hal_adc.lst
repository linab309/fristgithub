###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                08/Apr/2013  11:22:31 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Com #
#                          ponents\hal\target\CC2530EB\hal_adc.c              #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0 #
#                          \Projects\zstack\Samples\WSN_sensors\CC2530DB\..\. #
#                          .\..\Tools\CC2530DB\f8wRouter.cfg" (-DCPU32MHZ     #
#                          -DROOT=__near_func -DMAC_CFG_APP_PENDING_QUEUE=TRU #
#                          E -DRTR_NWK -DBLINK_LEDS) -f "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wConfig.cfg" (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0xFFFF                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Co #
#                          mponents\hal\target\CC2530EB\hal_adc.c" -D         #
#                          ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D MT_ZDO_FUNC  #
#                          -D LCD_SUPPORTED=DEBUG -lC "C:\Texas               #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\RouterEB\List\"   #
#                          -lA "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3. #
#                          0\Projects\zstack\Samples\WSN_sensors\CC2530DB\Rou #
#                          terEB\List\" --diag_suppress Pe001,Pa010 -o        #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\WSN_sensors\CC2530DB\RouterE #
#                          B\Obj\" -e --require_prototypes --no_unroll        #
#                          --no_inline --no_tbaa --debug --core=plain         #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\" -I "C:\Texas    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\SOURCE\" -I    #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\WSN_sensors\CC2530DB\..\..\. #
#                          .\ZMAIN\TI2530DB\" -I "C:\Texas                    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MT\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\TARGET\CC2530EB\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\INCLUDE\" -I "C:\Texas               #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\AF\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\NWK\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SEC\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SAPI\" -I "C:\Texas                 #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SYS\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\ZDO\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\F8W\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SADDR\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SDATA\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\WSN_sensors\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I      #
#                          "D:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3\8051\INC\" -I "D:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\" -Om #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\WSN_sensors\CC2530DB\RouterEB #
#                          \List\hal_adc.lst                                  #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\WSN_sensors\CC2530DB\RouterEB #
#                          \Obj\hal_adc.r51                                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Components\hal\target\CC2530EB\hal_adc.c
      1          /**************************************************************************************************
      2            Filename:       hal_adc.c
      3            Revised:        $Date: 2009-03-13 05:45:44 -0700 (Fri, 13 Mar 2009) $
      4            Revision:       $Revision: 19408 $
      5          
      6            Description:    This file contains the interface to the HAL ADC.
      7          
      8          
      9            Copyright 2006-2007 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /**************************************************************************************************
     41           *                                           INCLUDES
     42           **************************************************************************************************/
     43          #include  "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x88
   \   union <unnamed> volatile __sfr _A_TCON
   \                     _A_TCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb5
   \   unsigned char volatile __sfr ADCCON2
   \                     ADCCON2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb6
   \   unsigned char volatile __sfr ADCCON3
   \                     ADCCON3:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xba
   \   unsigned char volatile __sfr ADCL
   \                     ADCL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbb
   \   unsigned char volatile __sfr ADCH
   \                     ADCH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xf2
   \   unsigned char volatile __sfr ADCCFG
   \                     ADCCFG:
   \   000000                DS 1
     44          #include  "hal_defs.h"
     45          #include  "hal_types.h"
     46          #include  "hal_adc.h"
     47          
     48          /**************************************************************************************************
     49           *                                            CONSTANTS
     50           **************************************************************************************************/
     51          #define HAL_ADC_EOC         0x80    /* End of Conversion bit */
     52          #define HAL_ADC_START       0x40    /* Starts Conversion */
     53          
     54          #define HAL_ADC_STSEL_EXT   0x00    /* External Trigger */
     55          #define HAL_ADC_STSEL_FULL  0x10    /* Full Speed, No Trigger */
     56          #define HAL_ADC_STSEL_T1C0  0x20    /* Timer1, Channel 0 Compare Event Trigger */
     57          #define HAL_ADC_STSEL_ST    0x30    /* ADCCON1.ST =1 Trigger */
     58          
     59          #define HAL_ADC_RAND_NORM   0x00    /* Normal Operation */
     60          #define HAL_ADC_RAND_LFSR   0x04    /* Clock LFSR */
     61          #define HAL_ADC_RAND_SEED   0x08    /* Seed Modulator */
     62          #define HAL_ADC_RAND_STOP   0x0c    /* Stop Random Generator */
     63          #define HAL_ADC_RAND_BITS   0x0c    /* Bits [3:2] */
     64          
     65          #define HAL_ADC_REF_125V    0x00    /* Internal 1.25V Reference */
     66          #define HAL_ADC_REF_AIN7    0x40    /* AIN7 Reference */
     67          #define HAL_ADC_REF_AVDD    0x80    /* AVDD_SOC Pin Reference */
     68          #define HAL_ADC_REF_DIFF    0xc0    /* AIN7,AIN6 Differential Reference */
     69          #define HAL_ADC_REF_BITS    0xc0    /* Bits [7:6] */
     70          
     71          #define HAL_ADC_DEC_064     0x00    /* Decimate by 64 : 8-bit resolution */
     72          #define HAL_ADC_DEC_128     0x10    /* Decimate by 128 : 10-bit resolution */
     73          #define HAL_ADC_DEC_256     0x20    /* Decimate by 256 : 12-bit resolution */
     74          #define HAL_ADC_DEC_512     0x30    /* Decimate by 512 : 14-bit resolution */
     75          #define HAL_ADC_DEC_BITS    0x30    /* Bits [5:4] */
     76          
     77          #define HAL_ADC_CHN_AIN0    0x00    /* AIN0 */
     78          #define HAL_ADC_CHN_AIN1    0x01    /* AIN1 */
     79          #define HAL_ADC_CHN_AIN2    0x02    /* AIN2 */
     80          #define HAL_ADC_CHN_AIN3    0x03    /* AIN3 */
     81          #define HAL_ADC_CHN_AIN4    0x04    /* AIN4 */
     82          #define HAL_ADC_CHN_AIN5    0x05    /* AIN5 */
     83          #define HAL_ADC_CHN_AIN6    0x06    /* AIN6 */
     84          #define HAL_ADC_CHN_AIN7    0x07    /* AIN7 */
     85          #define HAL_ADC_CHN_A0A1    0x08    /* AIN0,AIN1 */
     86          #define HAL_ADC_CHN_A2A3    0x09    /* AIN2,AIN3 */
     87          #define HAL_ADC_CHN_A4A5    0x0a    /* AIN4,AIN5 */
     88          #define HAL_ADC_CHN_A6A7    0x0b    /* AIN6,AIN7 */
     89          #define HAL_ADC_CHN_GND     0x0c    /* GND */
     90          #define HAL_ADC_CHN_VREF    0x0d    /* Positive voltage reference */
     91          #define HAL_ADC_CHN_TEMP    0x0e    /* Temperature sensor */
     92          #define HAL_ADC_CHN_VDD3    0x0f    /* VDD/3 */
     93          #define HAL_ADC_CHN_BITS    0x0f    /* Bits [3:0] */
     94          
     95          #define HAL_ADC_STSEL       HAL_ADC_STSEL_ST
     96          #define HAL_ADC_RAND_GEN    HAL_ADC_RAND_STOP
     97          #define HAL_ADC_REF_VOLT    HAL_ADC_REF_AVDD
     98          #define HAL_ADC_DEC_RATE    HAL_ADC_DEC_064
     99          #define HAL_ADC_SCHN        HAL_ADC_CHN_VDD3
    100          #define HAL_ADC_ECHN        HAL_ADC_CHN_GND
    101          
    102          
    103          /* Vdd limit values */

   \                                 In  segment CODE_C, align 1
    104          static __code const uint16 HalAdcVddLimit[] =
   \                     HalAdcVddLimit:
   \   000000   9C36063A     DW 13980, 14854, 15728, 16601, 17475, 18349, 19223, 20097, 20970
   \            703DD940
   \            4344AD47
   \            174B814E
   \            EA51    
    105          {
    106            0x369C,       /*  VDD Limit - 1.6v  */
    107            0x3A06,       /*  VDD Limit - 1.7v  */
    108            0x3D70,       /*  VDD Limit - 1.8v  */
    109            0x40D9,       /*  VDD Limit - 1.9v  */
    110            0x4443,       /*  VDD Limit - 2.0v  */
    111            0x47AD,       /*  VDD Limit - 2.1v  */
    112            0x4B17,       /*  VDD Limit - 2.2v  */
    113            0x4E81,       /*  VDD Limit - 2.3v  */
    114            0x51EA,       /*  VDD Limit - 2.4v  */
    115          };
    116          
    117          
    118          /**************************************************************************************************
    119           *                                              MACROS
    120           **************************************************************************************************/
    121          #define HAL_ADC_CLR_EOC()   asm("PUSH A"); asm("MOV A,ADCL"); asm("MOV A,ADCH"); asm("POP A");
    122          
    123          /**************************************************************************************************
    124           *                                            TYPEDEFS
    125           **************************************************************************************************/
    126          
    127          /**************************************************************************************************
    128           *                                         GLOBAL VARIABLES
    129           **************************************************************************************************/
    130          
    131          /**************************************************************************************************
    132           *                                          FUNCTIONS - API
    133           **************************************************************************************************/
    134          extern bool HalAdcCheckVdd (uint8 limit);
    135          
    136          /**************************************************************************************************
    137           * @fn      HalAdcInit
    138           *
    139           * @brief   Initialize ADC Service
    140           *
    141           * @param   None
    142           *
    143           * @return  None
    144           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    145          void HalAdcInit (void)
   \                     HalAdcInit:
    146          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 1
   \   000004   74FF         MOV     A,#-0x1
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    147          #if (HAL_ADC == TRUE)
    148            volatile uint8  tmp;
    149          
    150            ADCCON1 = HAL_ADC_STSEL | HAL_ADC_RAND_GEN | 0x03;
   \   000009   75B43F       MOV     0xb4,#0x3f
    151            ADCCON2 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_SCHN;
   \   00000C   75B58F       MOV     0xb5,#-0x71
    152            /*
    153            *  After reset, the first ADC reading of the extra conversion always reads GND level.
    154            *  We will do a few dummy conversions to bypass this bug.
    155            */
    156            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   00000F   E5BA         MOV     A,0xba
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   F0           MOVX    @DPTR,A
    157            tmp = ADCH;
   \   000018   E5BB         MOV     A,0xbb
   \   00001A   F0           MOVX    @DPTR,A
    158            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00001B   75B68C       MOV     0xb6,#-0x74
    159            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_0:
   \   00001E   E5B4         MOV     A,0xb4
   \   000020   A2E7         MOV     C,0xE0 /* A   */.7
   \   000022   50FA         JNC     ??HalAdcInit_0
    160            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000024   E5BA         MOV     A,0xba
   \   000026   F0           MOVX    @DPTR,A
    161            tmp = ADCH;
   \   000027   E5BB         MOV     A,0xbb
   \   000029   F0           MOVX    @DPTR,A
    162            ADCCON3 = HAL_ADC_REF_VOLT | HAL_ADC_DEC_RATE | HAL_ADC_ECHN;
   \   00002A   75B68C       MOV     0xb6,#-0x74
    163            while ((ADCCON1 & HAL_ADC_EOC) != HAL_ADC_EOC);   /* Wait for conversion */
   \                     ??HalAdcInit_1:
   \   00002D   E5B4         MOV     A,0xb4
   \   00002F   A2E7         MOV     C,0xE0 /* A   */.7
   \   000031   50FA         JNC     ??HalAdcInit_1
    164            tmp = ADCL;     /* read ADCL,ADCH to clear EOC */
   \   000033   E5BA         MOV     A,0xba
   \   000035   F0           MOVX    @DPTR,A
    165            tmp = ADCH;
   \   000036   E5BB         MOV     A,0xbb
   \   000038   F0           MOVX    @DPTR,A
    166          #endif
    167          }
   \   000039   7401         MOV     A,#0x1
   \   00003B   12....       LCALL   ?DEALLOC_XSTACK8
   \   00003E   D083         POP     DPH
   \   000040   D082         POP     DPL
   \   000042   02....       LJMP    ?BRET
   \   000045                REQUIRE ADCCON1
   \   000045                REQUIRE ADCCON2
   \   000045                REQUIRE ADCCON3
   \   000045                REQUIRE ADCL
   \   000045                REQUIRE ADCH
    168          
    169          /**************************************************************************************************
    170           * @fn      HalAdcRead
    171           *
    172           * @brief   Read the ADC based on given channel and resolution
    173           *
    174           * @param   channel - channel where ADC will be read
    175           * @param   resolution - the resolution of the value
    176           *
    177           * @return  16 bit value of the ADC in offset binary format.
    178           *          Note that the ADC is "bipolar", which means the GND (0V) level is mid-scale.
    179           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    180          uint16 HalAdcRead (uint8 channel, uint8 resolution)
   \                     HalAdcRead:
    181          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 1
   \   000005   74FF         MOV     A,#-0x1
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    182            int16  reading = 0;
    183          
    184          #if (HAL_ADC == TRUE)
    185          
    186            uint8   i, resbits;
    187            uint8   adctemp;
    188            volatile  uint8 tmp;
    189            uint8  adcChannel = 1;
   \   00000A   7C01         MOV     R4,#0x1
    190          
    191            /*
    192            * If Analog input channel is AIN0..AIN7, make sure corresponing P0 I/O pin is enabled.  The code
    193            * does NOT disable the pin at the end of this function.  I think it is better to leave the pin
    194            * enabled because the results will be more accurate.  Because of the inherent capacitance on the
    195            * pin, it takes time for the voltage on the pin to charge up to its steady-state level.  If
    196            * HalAdcRead() has to turn on the pin for every conversion, the results may show a lower voltage
    197            * than actuality because the pin did not have time to fully charge.
    198            */
    199            if (channel < 8)
   \   00000C   E9           MOV     A,R1
   \   00000D   C3           CLR     C
   \   00000E   9408         SUBB    A,#0x8
   \   000010   500E         JNC     ??HalAdcRead_0
    200            {
    201              for (i=0; i < channel; i++)
   \   000012   7B00         MOV     R3,#0x0
   \   000014   8005         SJMP    ??HalAdcRead_1
    202              {
    203                adcChannel <<= 1;
   \                     ??HalAdcRead_2:
   \   000016   EC           MOV     A,R4
   \   000017   C3           CLR     C
   \   000018   33           RLC     A
   \   000019   FC           MOV     R4,A
    204              }
   \   00001A   0B           INC     R3
   \                     ??HalAdcRead_1:
   \   00001B   EB           MOV     A,R3
   \   00001C   C3           CLR     C
   \   00001D   99           SUBB    A,R1
   \   00001E   40F6         JC      ??HalAdcRead_2
    205            }
    206          
    207            /* Enable channel */
    208            ADCCFG |= adcChannel;
   \                     ??HalAdcRead_0:
   \   000020   EC           MOV     A,R4
   \   000021   45F2         ORL     A,0xf2
   \   000023   F5F2         MOV     0xf2,A
    209          
    210            /* Convert resolution to decimation rate */
    211            switch (resolution)
   \   000025   EA           MOV     A,R2
   \   000026   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_0`:
   \   000029   01           DB        1
   \   00002A   02           DB        2
   \   00002B   ....         DW        ??HalAdcRead_3
   \   00002D   ....         DW        ??HalAdcRead_4
   \   00002F   ....         DW        ??HalAdcRead_5
   \   000031   ....         DW        ??HalAdcRead_6
    212            {
    213              case HAL_ADC_RESOLUTION_8:
    214                resbits = HAL_ADC_DEC_064;
   \                     ??HalAdcRead_4:
   \   000033   7B00         MOV     R3,#0x0
   \   000035   800A         SJMP    ??HalAdcRead_7
    215                break;
    216              case HAL_ADC_RESOLUTION_10:
    217                resbits = HAL_ADC_DEC_128;
   \                     ??HalAdcRead_5:
   \   000037   7B10         MOV     R3,#0x10
   \   000039   8006         SJMP    ??HalAdcRead_7
    218                break;
    219              case HAL_ADC_RESOLUTION_12:
    220                resbits = HAL_ADC_DEC_256;
   \                     ??HalAdcRead_6:
   \   00003B   7B20         MOV     R3,#0x20
   \   00003D   8002         SJMP    ??HalAdcRead_7
    221                break;
    222              case HAL_ADC_RESOLUTION_14:
    223              default:
    224                resbits = HAL_ADC_DEC_512;
   \                     ??HalAdcRead_3:
   \   00003F   7B30         MOV     R3,#0x30
    225                break;
    226            }
    227          
    228            /* read ADCL,ADCH to clear EOC */
    229            tmp = ADCL;
   \                     ??HalAdcRead_7:
   \   000041   E5BA         MOV     A,0xba
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   F0           MOVX    @DPTR,A
    230            tmp = ADCH;
   \   00004A   E5BB         MOV     A,0xbb
   \   00004C   F0           MOVX    @DPTR,A
    231          
    232            /* Setup Sample */
    233            adctemp = ADCCON3;
   \   00004D   E5B6         MOV     A,0xb6
    234            adctemp &= ~(HAL_ADC_CHN_BITS | HAL_ADC_DEC_BITS | HAL_ADC_REF_BITS);
    235            adctemp |= channel | resbits | HAL_ADC_REF_VOLT;
    236          
    237            /* writing to this register starts the extra conversion */
    238            ADCCON3 = adctemp;
   \   00004F   EB           MOV     A,R3
   \   000050   49           ORL     A,R1
   \   000051   4480         ORL     A,#0x80
   \   000053   F5B6         MOV     0xb6,A
    239          
    240            /* Wait for the conversion to be done */
    241            while (!(ADCCON1 & HAL_ADC_EOC));
   \                     ??HalAdcRead_8:
   \   000055   E5B4         MOV     A,0xb4
   \   000057   A2E7         MOV     C,0xE0 /* A   */.7
   \   000059   50FA         JNC     ??HalAdcRead_8
    242          
    243            /* Disable channel after done conversion */
    244            ADCCFG &= (adcChannel ^ 0xFF);
   \   00005B   74FF         MOV     A,#-0x1
   \   00005D   6C           XRL     A,R4
   \   00005E   55F2         ANL     A,0xf2
   \   000060   F5F2         MOV     0xf2,A
    245          
    246            /* Read the result */
    247            reading = (int16) (ADCL);
   \   000062   ABBA         MOV     R3,0xba
   \   000064   8B82         MOV     DPL,R3
   \   000066   A882         MOV     R0,DPL
    248            reading |= (int16) (ADCH << 8);
   \   000068   E5BB         MOV     A,0xbb
   \   00006A   F9           MOV     R1,A
    249          
    250            /* Treat small negative as 0 */
    251            if (reading < 0)
   \   00006B   C3           CLR     C
   \   00006C   9400         SUBB    A,#0x0
   \   00006E   A2D2         MOV     C,0xD0 /* PSW */.2
   \   000070   65D0         XRL     A,PSW
   \   000072   33           RLC     A
   \   000073   5004         JNC     ??HalAdcRead_9
    252              reading = 0;
   \   000075   7800         MOV     R0,#0x0
   \   000077   7900         MOV     R1,#0x0
    253          
    254            switch (resolution)
   \                     ??HalAdcRead_9:
   \   000079   EA           MOV     A,R2
   \   00007A   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for HalAdcRead>_1`:
   \   00007D   01           DB        1
   \   00007E   02           DB        2
   \   00007F   ....         DW        ??HalAdcRead_10
   \   000081   ....         DW        ??HalAdcRead_11
   \   000083   ....         DW        ??HalAdcRead_12
   \   000085   ....         DW        ??HalAdcRead_13
    255            {
    256              case HAL_ADC_RESOLUTION_8:
    257                reading >>= 8;
   \                     ??HalAdcRead_11:
   \   000087   88..         MOV     ?V0 + 0,R0
   \   000089   89..         MOV     ?V0 + 1,R1
   \   00008B   7408         MOV     A,#0x8
   \   00008D   800E         SJMP    ??HalAdcRead_14
    258                break;
    259              case HAL_ADC_RESOLUTION_10:
    260                reading >>= 6;
   \                     ??HalAdcRead_12:
   \   00008F   88..         MOV     ?V0 + 0,R0
   \   000091   89..         MOV     ?V0 + 1,R1
   \   000093   7406         MOV     A,#0x6
   \   000095   8006         SJMP    ??HalAdcRead_14
    261                break;
    262              case HAL_ADC_RESOLUTION_12:
    263                reading >>= 4;
   \                     ??HalAdcRead_13:
   \   000097   88..         MOV     ?V0 + 0,R0
   \   000099   89..         MOV     ?V0 + 1,R1
   \   00009B   7404         MOV     A,#0x4
   \                     ??HalAdcRead_14:
   \   00009D   78..         MOV     R0,#?V0 + 0
   \   00009F   12....       LCALL   ?SS_SHR
   \   0000A2   A8..         MOV     R0,?V0 + 0
   \   0000A4   A9..         MOV     R1,?V0 + 1
    264                break;
    265              case HAL_ADC_RESOLUTION_14:
    266              default:
    267              break;
    268            }
    269          #else
    270            // unused arguments
    271            (void) channel;
    272            (void) resolution;
    273          #endif
    274          
    275            return ((uint16)reading);
   \                     ??HalAdcRead_10:
   \   0000A6   E8           MOV     A,R0
   \   0000A7   FA           MOV     R2,A
   \   0000A8   E9           MOV     A,R1
   \   0000A9   FB           MOV     R3,A
   \   0000AA   7401         MOV     A,#0x1
   \   0000AC   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000AF   7F02         MOV     R7,#0x2
   \   0000B1   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   0000B4                REQUIRE ADCCON1
   \   0000B4                REQUIRE ADCCON3
   \   0000B4                REQUIRE ADCL
   \   0000B4                REQUIRE ADCH
   \   0000B4                REQUIRE ADCCFG
    276          }
    277          
    278          /**************************************************************************************************
    279           * @fn      HalAdcCheckVdd
    280           *
    281           * @brief   Check the Vdd and return TRUE if it greater than or equal the limit
    282           *
    283           * @param   limit - limit that needs to be checked with the Vdd
    284           *
    285           * @return  TRUE if Vdd >= limit, FALSE otherwise
    286           *
    287           **************************************************************************************************/

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    288          bool HalAdcCheckVdd (uint8 limit)
   \                     HalAdcCheckVdd:
    289          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    290            uint16 value;
    291          
    292            /* Clear ADC interrupt flag */
    293            ADCIF = 0;
   \   000004   C28D         CLR     0x88.5
    294          
    295            /* Setup the new value for conversion */
    296            ADCCON3 = (HAL_ADC_REF_125V | HAL_ADC_DEC_064 | HAL_ADC_CHN_VDD3);
   \   000006   75B60F       MOV     0xb6,#0xf
    297          
    298            /* Wait for the conversion to finish */
    299            while ( !ADCIF );
   \                     ??HalAdcCheckVdd_0:
   \   000009   A28D         MOV     C,0x88.5
   \   00000B   50FC         JNC     ??HalAdcCheckVdd_0
    300          
    301            /* Get the result */
    302            value = ADCL;
   \   00000D   AABA         MOV     R2,0xba
    303            value |= ((uint16) ADCH) << 8;
   \   00000F   E5BB         MOV     A,0xbb
   \   000011   FB           MOV     R3,A
    304          
    305            /* Check the limit and return */
    306            return ( value >= HalAdcVddLimit[limit] );
   \   000012   E9           MOV     A,R1
   \   000013   C3           CLR     C
   \   000014   33           RLC     A
   \   000015   F8           MOV     R0,A
   \   000016   E4           CLR     A
   \   000017   33           RLC     A
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   24..         ADD     A,#(HalAdcVddLimit & 0xff)
   \   00001C   F582         MOV     DPL,A
   \   00001E   E9           MOV     A,R1
   \   00001F   34..         ADDC    A,#((HalAdcVddLimit >> 8) & 0xff)
   \   000021   F583         MOV     DPH,A
   \   000023   E4           CLR     A
   \   000024   93           MOVC    A,@A+DPTR
   \   000025   F8           MOV     R0,A
   \   000026   7401         MOV     A,#0x1
   \   000028   93           MOVC    A,@A+DPTR
   \   000029   F9           MOV     R1,A
   \   00002A   C3           CLR     C
   \   00002B   EA           MOV     A,R2
   \   00002C   98           SUBB    A,R0
   \   00002D   EB           MOV     A,R3
   \   00002E   99           SUBB    A,R1
   \   00002F   4004         JC      ??HalAdcCheckVdd_1
   \   000031   7901         MOV     R1,#0x1
   \   000033   8002         SJMP    ??HalAdcCheckVdd_2
   \                     ??HalAdcCheckVdd_1:
   \   000035   7900         MOV     R1,#0x0
   \                     ??HalAdcCheckVdd_2:
   \   000037   D083         POP     DPH
   \   000039   D082         POP     DPL
   \   00003B   02....       LJMP    ?BRET
   \   00003E                REQUIRE ADCCON3
   \   00003E                REQUIRE ADCL
   \   00003E                REQUIRE ADCH
   \   00003E                REQUIRE _A_TCON
    307          }

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcRead?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcRead

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??HalAdcCheckVdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    HalAdcCheckVdd
    308          
    309          /**************************************************************************************************
    310          **************************************************************************************************/
    311          
    312          
    313          
    314          

   Maximum stack usage in bytes:

     Function       ISTACK PSTACK XSTACK
     --------       ------ ------ ------
     HalAdcCheckVdd     2      0      0
     HalAdcInit         3      0      1
     HalAdcRead         1      0     11


   Segment part sizes:

     Function/Label         Bytes
     --------------         -----
     _A_TCON                   1
     ADCCON1                   1
     ADCCON2                   1
     ADCCON3                   1
     ADCL                      1
     ADCH                      1
     ADCCFG                    1
     HalAdcVddLimit           18
     HalAdcInit               69
     HalAdcRead              180
     HalAdcCheckVdd           62
     ??HalAdcInit?relay        6
     ??HalAdcRead?relay        6
     ??HalAdcCheckVdd?relay    6

 
 311 bytes in segment BANKED_CODE
  18 bytes in segment BANK_RELAYS
  18 bytes in segment CODE_C
   7 bytes in segment SFR_AN
 
 347 bytes of CODE memory
   0 bytes of DATA memory (+ 7 bytes shared)

Errors: none
Warnings: none
