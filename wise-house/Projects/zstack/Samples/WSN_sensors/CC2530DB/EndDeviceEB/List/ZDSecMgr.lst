###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                29/Sep/2011  15:47:16 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Com #
#                          ponents\stack\zdo\ZDSecMgr.c                       #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0 #
#                          \Projects\zstack\Samples\LightCtlPrj\CC2530DB\..\. #
#                          .\..\Tools\CC2530DB\f8wEndev.cfg" (-DCPU32MHZ      #
#                          -DROOT=__near_func -DBLINK_LEDS) -f "C:\Texas      #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wConfig.cfg" (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00001000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1212                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Co #
#                          mponents\stack\zdo\ZDSecMgr.c" -D NWK_AUTO_POLL    #
#                          -D ZTOOL_P1 -D MT_TASK -D MT_SYS_FUNC -D           #
#                          MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG -D              #
#                          HAL_UART=TRUE -D xPOWER_SAVING -lC "C:\Texas       #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\EndDeviceEB\List\ #
#                          " -lA "C:\Texas Instruments\ZStack-CC2530-2.2.2-1. #
#                          3.0\Projects\zstack\Samples\LightCtlPrj\CC2530DB\E #
#                          ndDeviceEB\List\" --diag_suppress Pe001,Pa010 -o   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevi #
#                          ceEB\Obj\" -e --require_prototypes --debug         #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\" -I "C:\Texas    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\SOURCE\" -I    #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\LightCtlPrj\CC2530DB\..\..\. #
#                          .\ZMAIN\TI2530DB\" -I "C:\Texas                    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MT\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\TARGET\CC2530EB\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\INCLUDE\" -I "C:\Texas               #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\AF\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\NWK\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SEC\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SAPI\" -I "C:\Texas                 #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SYS\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\ZDO\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\F8W\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SADDR\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SDATA\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I      #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3\8051\INC\" -I "C:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevic #
#                          eEB\List\ZDSecMgr.lst                              #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevic #
#                          eEB\Obj\ZDSecMgr.r51                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Components\stack\zdo\ZDSecMgr.c
      1          /**************************************************************************************************
      2            Filename:       ZDSecMgr.c
      3            Revised:        $Date: 2009-03-31 09:06:47 -0700 (Tue, 31 Mar 2009) $
      4            Revision:       $Revision: 19604 $
      5          
      6            Description:    The ZigBee Device Security Manager.
      7          
      8          
      9            Copyright 2005-2008 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          #ifdef __cplusplus
     41          extern "C"
     42          {
     43          #endif
     44          
     45          /******************************************************************************
     46           * INCLUDES
     47           */
     48          #include "ZComdef.h"
     49          #include "OSAL.h"
     50          #include "OSAL_NV.h"
     51          #include "ZGlobals.h"
     52          #include "ssp.h"
     53          #include "nwk_globals.h"
     54          #include "nwk.h"
     55          #include "NLMEDE.h"
     56          #include "AddrMgr.h"
     57          #include "AssocList.h"
     58          #include "APSMEDE.h"
     59          #include "AF.h"
     60          #include "ZDConfig.h"
     61          #include "ZDApp.h"
     62          #include "ZDSecMgr.h"
     63          
     64          
     65          /******************************************************************************
     66           * CONSTANTS
     67           */
     68          // maximum number of devices managed by this Security Manager
     69          #if !defined ( ZDSECMGR_DEVICE_MAX )
     70            #define ZDSECMGR_DEVICE_MAX 3
     71          #endif
     72          
     73          // total number of preconfigured devices (EXT address, MASTER key)
     74          //devtag.pro.security
     75          //#define ZDSECMGR_PRECONFIG_MAX ZDSECMGR_DEVICE_MAX
     76          #define ZDSECMGR_PRECONFIG_MAX 0
     77          
     78          // maximum number of MASTER keys this device may hold
     79          #define ZDSECMGR_MASTERKEY_MAX ZDSECMGR_DEVICE_MAX
     80          
     81          // maximum number of LINK keys this device may store
     82          #define ZDSECMGR_ENTRY_MAX ZDSECMGR_DEVICE_MAX
     83          
     84          // total number of devices under control - authentication, SKKE, etc.
     85          #define ZDSECMGR_CTRL_MAX ZDSECMGR_DEVICE_MAX
     86          
     87          // total number of stored devices
     88          #if !defined ( ZDSECMGR_STORED_DEVICES )
     89            #define ZDSECMGR_STORED_DEVICES 3
     90          #endif
     91            
     92          #define ZDSECMGR_CTRL_NONE       0
     93          #define ZDSECMGR_CTRL_INIT       1
     94          #define ZDSECMGR_CTRL_TK_MASTER  2
     95          #define ZDSECMGR_CTRL_SKKE_INIT  3
     96          #define ZDSECMGR_CTRL_SKKE_WAIT  4
     97          #define ZDSECMGR_CTRL_SKKE_DONE  5
     98          #define ZDSECMGR_CTRL_SKKE_FAIL  6
     99          #define ZDSECMGR_CTRL_TK_NWK     7
    100          
    101          #define ZDSECMGR_CTRL_BASE_CNTR      1
    102          #define ZDSECMGR_CTRL_SKKE_INIT_CNTR 1
    103          #define ZDSECMGR_CTRL_TK_NWK_CNTR    1
    104          
    105          // set SKA slot maximum
    106          #define ZDSECMGR_SKA_SLOT_MAX 1
    107          
    108          // APSME Stub Implementations
    109          #define ZDSecMgrMasterKeyGet   APSME_MasterKeyGet
    110          #define ZDSecMgrLinkKeySet     APSME_LinkKeySet
    111          #define ZDSecMgrLinkKeyDataGet APSME_LinkKeyDataGet
    112          #define ZDSecMgrKeyFwdToChild  APSME_KeyFwdToChild
    113          
    114          #if !defined( MAX_APS_FRAMECOUNTER_CHANGES )
    115            // The number of times the frame counter can change before
    116            // saving to NV
    117            #define MAX_APS_FRAMECOUNTER_CHANGES    10
    118          #endif
    119          
    120          /******************************************************************************
    121           * TYPEDEFS
    122           */
    123          typedef struct
    124          {
    125            uint8 extAddr[Z_EXTADDR_LEN];
    126            uint8 key[SEC_KEY_LEN];
    127          } ZDSecMgrPreConfigData_t;
    128          
    129          typedef struct
    130          {
    131            uint16 ami;
    132            uint8  key[SEC_KEY_LEN];
    133          } ZDSecMgrMasterKeyData_t;
    134          
    135          //should match APSME_LinkKeyData_t;
    136          typedef struct
    137          {
    138            uint8               key[SEC_KEY_LEN];
    139            APSME_LinkKeyData_t apsmelkd;
    140          } ZDSecMgrLinkKeyData_t;
    141          
    142          typedef struct
    143          {
    144            uint16                ami;
    145            ZDSecMgrLinkKeyData_t lkd;
    146            ZDSecMgr_Authentication_Option authenticateOption;
    147          } ZDSecMgrEntry_t;
    148          
    149          typedef struct
    150          {
    151            ZDSecMgrEntry_t* entry;
    152            uint16           parentAddr;
    153            uint8            secure;
    154            uint8            state;
    155            uint8            cntr;
    156            //uint8          next;
    157          } ZDSecMgrCtrl_t;
    158          
    159          typedef struct
    160          {
    161            uint16          nwkAddr;
    162            uint8*          extAddr;
    163            uint16          parentAddr;
    164            uint8           secure;
    165            uint8           devStatus;
    166            ZDSecMgrCtrl_t* ctrl;
    167          } ZDSecMgrDevice_t;
    168          
    169          /******************************************************************************
    170           * LOCAL VARIABLES
    171           */
    172          #if 0 // Taken out because the following functionality is only used for test
    173                // purpose. A more efficient (above) way is used. It can be put
    174                // back in if customers request for a white/black list feature.
    175          uint8 ZDSecMgrStoredDeviceList[ZDSECMGR_STORED_DEVICES][Z_EXTADDR_LEN] =
    176          {
    177            { 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    178            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01 },
    179            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 },
    180          };
    181          #endif
    182          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          uint8 ZDSecMgrTCExtAddr[Z_EXTADDR_LEN]=
   \                     ZDSecMgrTCExtAddr:
   \   000000                DS 8
   \   000008                REQUIRE __INIT_XDATA_Z
    184            { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
    185          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    186          uint8 ZDSecMgrTCMasterKey[SEC_KEY_LEN] =
   \                     ZDSecMgrTCMasterKey:
   \   000000                DS 16
   \   000010                REQUIRE `?<Initializer for ZDSecMgrTCMasterKey>`
   \   000010                REQUIRE __INIT_XDATA_I
    187            {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    188             0x89,0x67,0x45,0x23,0x01,0xEF,0xCD,0xAB};
    189          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    190          uint8 ZDSecMgrTCAuthenticated = FALSE;
   \                     ZDSecMgrTCAuthenticated:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    191          uint8 ZDSecMgrTCDataLoaded    = FALSE;
   \                     ZDSecMgrTCDataLoaded:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    192          
    193          //devtag.pro.security - remove this
    194          #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    195          const ZDSecMgrPreConfigData_t ZDSecMgrPreConfigData[ZDSECMGR_PRECONFIG_MAX] =
    196          {
    197            //---------------------------------------------------------------------------
    198            // DEVICE A
    199            //---------------------------------------------------------------------------
    200            {
    201              // extAddr
    202              {0x7C,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    203          
    204              // key
    205              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    206               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    207            },
    208            //---------------------------------------------------------------------------
    209            // DEVICE B
    210            //---------------------------------------------------------------------------
    211            {
    212              // extAddr
    213              {0x84,0x03,0x00,0x00,0x00,0x4B,0x12,0x00},
    214          
    215              // key
    216              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    217               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    218            },
    219            //---------------------------------------------------------------------------
    220            // DEVICE C
    221            //---------------------------------------------------------------------------
    222            {
    223              // extAddr
    224              {0x3E,0x01,0x12,0x13,0x14,0x15,0x16,0x17},
    225          
    226              // key
    227              {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    228               0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}
    229            },
    230          };
    231          #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    232          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    233          ZDSecMgrMasterKeyData_t* ZDSecMgrMasterKeyData = NULL;
   \                     ZDSecMgrMasterKeyData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    234          ZDSecMgrEntry_t*         ZDSecMgrEntries       = NULL;
   \                     ZDSecMgrEntries:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    235          ZDSecMgrCtrl_t*          ZDSecMgrCtrlData      = NULL;
   \                     ZDSecMgrCtrlData:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    236          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr );
    237          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
    238          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    239          uint8 ZDSecMgrPermitJoiningEnabled;
   \                     ZDSecMgrPermitJoiningEnabled:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    240          uint8 ZDSecMgrPermitJoiningTimed;
   \                     ZDSecMgrPermitJoiningTimed:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    241          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    242          APSME_LinkKeyData_t TrustCenterLinkKey;
   \                     TrustCenterLinkKey:
   \   000000                DS 10
   \   00000A                REQUIRE __INIT_XDATA_Z
    243          
    244          /******************************************************************************
    245           * PRIVATE FUNCTIONS
    246           *
    247           *   ZDSecMgrMasterKeyInit
    248           *   ZDSecMgrAddrStore
    249           *   ZDSecMgrExtAddrStore
    250           *   ZDSecMgrExtAddrLookup
    251           *   ZDSecMgrMasterKeyLookup
    252           *   ZDSecMgrMasterKeyStore
    253           *   ZDSecMgrEntryInit
    254           *   ZDSecMgrEntryLookup
    255           *   ZDSecMgrEntryLookupAMI
    256           *   ZDSecMgrEntryLookupExt
    257           *   ZDSecMgrEntryFree
    258           *   ZDSecMgrEntryNew
    259           *   ZDSecMgrCtrlInit
    260           *   ZDSecMgrCtrlRelease
    261           *   ZDSecMgrCtrlLookup
    262           *   ZDSecMgrCtrlSet
    263           *   ZDSecMgrCtrlAdd
    264           *   ZDSecMgrCtrlTerm
    265           *   ZDSecMgrCtrlReset
    266           *   ZDSecMgrMasterKeyLoad
    267           *   ZDSecMgrAppKeyGet
    268           *   ZDSecMgrAppKeyReq
    269           *   ZDSecMgrEstablishKey
    270           *   ZDSecMgrSendMasterKey
    271           *   ZDSecMgrSendNwkKey
    272           *   ZDSecMgrDeviceEntryRemove
    273           *   ZDSecMgrDeviceEntryAdd
    274           *   ZDSecMgrDeviceCtrlHandler
    275           *   ZDSecMgrDeviceCtrlSetup
    276           *   ZDSecMgrDeviceCtrlUpdate
    277           *   ZDSecMgrDeviceRemove
    278           *   ZDSecMgrDeviceValidateSKKE
    279           *   ZDSecMgrDeviceValidateRM
    280           *   ZDSecMgrDeviceValidateCM
    281           *   ZDSecMgrDeviceValidate
    282           *   ZDSecMgrDeviceJoin
    283           *   ZDSecMgrDeviceJoinDirect
    284           *   ZDSecMgrDeviceJoinFwd
    285           *   ZDSecMgrDeviceNew
    286           *   ZDSecMgrAssocDeviceAuth
    287           *   ZDSecMgrAuthInitiate
    288           *   ZDSecMgrAuthNwkKey
    289           */
    290          //-----------------------------------------------------------------------------
    291          // master key data
    292          //-----------------------------------------------------------------------------
    293          void ZDSecMgrMasterKeyInit( void );
    294          
    295          //-----------------------------------------------------------------------------
    296          // address management
    297          //-----------------------------------------------------------------------------
    298          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    299          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami );
    300          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami );
    301          
    302          //-----------------------------------------------------------------------------
    303          // MASTER key data
    304          //-----------------------------------------------------------------------------
    305          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key );
    306          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key );
    307          
    308          //-----------------------------------------------------------------------------
    309          // entry data
    310          //-----------------------------------------------------------------------------
    311          void ZDSecMgrEntryInit( void );
    312          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry );
    313          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry );
    314          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry );
    315          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry );
    316          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry );
    317          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option );
    318          
    319          //-----------------------------------------------------------------------------
    320          // control data
    321          //-----------------------------------------------------------------------------
    322          void ZDSecMgrCtrlInit( void );
    323          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl );
    324          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl );
    325          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
    326                                ZDSecMgrEntry_t*  entry,
    327                                ZDSecMgrCtrl_t*   ctrl );
    328          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry );
    329          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry );
    330          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device,
    331                                       ZDSecMgrEntry_t*  entry );
    332          
    333          //-----------------------------------------------------------------------------
    334          // key support
    335          //-----------------------------------------------------------------------------
    336          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key );
    337          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
    338                                       uint8*  initExtAddr,
    339                                       uint16  partNwkAddr,
    340                                       uint8*  partExtAddr,
    341                                       uint8** key,
    342                                       uint8*  keyType );
    343          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind );
    344          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device );
    345          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device );
    346          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device );
    347          
    348          //-----------------------------------------------------------------------------
    349          // device entry
    350          //-----------------------------------------------------------------------------
    351          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry );
    352          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami );
    353          
    354          //-----------------------------------------------------------------------------
    355          // device control
    356          //-----------------------------------------------------------------------------
    357          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device );
    358          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device );
    359          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state );
    360          
    361          //-----------------------------------------------------------------------------
    362          // device management
    363          //-----------------------------------------------------------------------------
    364          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device );
    365          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device );
    366          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device );
    367          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device );
    368          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device );
    369          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device );
    370          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device );
    371          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device );
    372          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* device );
    373          
    374          //-----------------------------------------------------------------------------
    375          // association management
    376          //-----------------------------------------------------------------------------
    377          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc );
    378          
    379          //-----------------------------------------------------------------------------
    380          // authentication management
    381          //-----------------------------------------------------------------------------
    382          void ZDSecMgrAuthInitiate( uint8* responder );
    383          void ZDSecMgrAuthNwkKey( void );
    384          
    385          /******************************************************************************
    386           * @fn          ZDSecMgrMasterKeyInit                     ]
    387           *
    388           * @brief       Initialize master key data.
    389           *
    390           * @param       none
    391           *
    392           * @return      none
    393           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    394          void ZDSecMgrMasterKeyInit( void )
   \                     ZDSecMgrMasterKeyInit:
    395          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    396            uint16 index;
    397            uint16 size;
    398          
    399            // allocate MASTER key data
    400            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    401          
    402            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A36         MOV     R2,#0x36
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000E   12....       LCALL   ??Subroutine101_0 & 0xFFFF
    403          
    404            // initialize MASTER key data
    405            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_184:
   \   000011   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrMasterKeyInit_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrMasterKeyInit_0:
   \   000019   601F         JZ      ??ZDSecMgrMasterKeyInit_1
    406            {
    407              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    408              {
    409                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrMasterKeyInit_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F012       MOV     B,#0x12
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   ACF0         MOV     R4,B
   \   00002B   75F012       MOV     B,#0x12
   \   00002E   EB           MOV     A,R3
   \   00002F   A4           MUL     AB
   \   000030   2C           ADD     A,R4
   \   000031   FB           MOV     R3,A
   \   000032   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000035   12....       LCALL   ?Subroutine2 & 0xFFFF
    410              }
    411            }
   \                     ??CrossCallReturnLabel_103:
   \   000038   40E5         JC      ??ZDSecMgrMasterKeyInit_2
    412          }
   \                     ??ZDSecMgrMasterKeyInit_1:
   \   00003A   02....       LJMP    ??Subroutine97_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ?Subroutine52 & 0xFFFF
   \                     ??CrossCallReturnLabel_75:
   \   000003   74FE         MOV     A,#-0x2
   \   000005   F0           MOVX    @DPTR,A
   \   000006   A3           INC     DPTR
   \   000007   74FF         MOV     A,#-0x1
   \   000009                REQUIRE ??Subroutine83_0
   \   000009                ; // Fall through to label ??Subroutine83_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine83_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_106:
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine62:
   \   000000   E8           MOV     A,R0
   \   000001   2401         ADD     A,#0x1
   \   000003   08           INC     R0
   \   000004   E9           MOV     A,R1
   \   000005   3400         ADDC    A,#0x0
   \   000007   F9           MOV     R1,A
   \   000008   C3           CLR     C
   \   000009   E8           MOV     A,R0
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   E9           MOV     A,R1
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine52:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   FC           MOV     R4,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3B           ADDC    A,R3
   \   000006   8C82         MOV     DPL,R4
   \   000008   F583         MOV     DPH,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine97_0:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine101_0:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    413          //devtag.pro.security
    414          #if 0
    415          void ZDSecMgrMasterKeyInit( void )
    416          {
    417            uint16         index;
    418            uint16         size;
    419            AddrMgrEntry_t entry;
    420          
    421          
    422            // allocate MASTER key data
    423            size = (short)( sizeof(ZDSecMgrMasterKeyData_t) * ZDSECMGR_MASTERKEY_MAX );
    424          
    425            ZDSecMgrMasterKeyData = osal_mem_alloc( size );
    426          
    427            // initialize MASTER key data
    428            if ( ZDSecMgrMasterKeyData != NULL )
    429            {
    430              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX; index++ )
    431              {
    432                ZDSecMgrMasterKeyData[index].ami = INVALID_NODE_ADDR;
    433              }
    434          
    435              // check if preconfigured keys are enabled
    436              //-------------------------------------------------------------------------
    437              #if ( ZDSECMGR_PRECONFIG_MAX != 0 )
    438              //-------------------------------------------------------------------------
    439              if ( zgPreConfigKeys == TRUE )
    440              {
    441                // sync configured data
    442                entry.user = ADDRMGR_USER_SECURITY;
    443          
    444                for ( index = 0; index < ZDSECMGR_PRECONFIG_MAX; index++ )
    445                {
    446                  // check for Address Manager entry
    447                  AddrMgrExtAddrSet( entry.extAddr,
    448                                     (uint8*)ZDSecMgrPreConfigData[index].extAddr );
    449          
    450                  if ( AddrMgrEntryLookupExt( &entry ) != TRUE )
    451                  {
    452                    // update Address Manager
    453                    AddrMgrEntryUpdate( &entry );
    454                  }
    455          
    456                  if ( entry.index != INVALID_NODE_ADDR )
    457                  {
    458                    // sync MASTER keys with Address Manager index
    459                    ZDSecMgrMasterKeyData[index].ami = entry.index;
    460          
    461                    osal_memcpy( ZDSecMgrMasterKeyData[index].key,
    462                             (void*)ZDSecMgrPreConfigData[index].key, SEC_KEY_LEN );
    463                  }
    464                }
    465              }
    466              //-------------------------------------------------------------------------
    467              #endif // ( ZDSECMGR_PRECONFIG_MAX != 0 )
    468              //-------------------------------------------------------------------------
    469            }
    470          }
    471          #endif
    472          
    473          /******************************************************************************
    474           * @fn          ZDSecMgrAddrStore
    475           *
    476           * @brief       Store device addresses.
    477           *
    478           * @param       nwkAddr - [in] NWK address
    479           * @param       extAddr - [in] EXT address
    480           * @param       ami     - [out] Address Manager index
    481           *
    482           * @return      ZStatus_t
    483           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    484          ZStatus_t ZDSecMgrAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrAddrStore:
    485          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine18 & 0xFFFF
    486            ZStatus_t      status;
    487            AddrMgrEntry_t entry;
    488          
    489          
    490            // add entry
    491            entry.user    = ADDRMGR_USER_SECURITY;
    492            entry.nwkAddr = nwkAddr;
   \                     ??CrossCallReturnLabel_19:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ??Subroutine101_0 & 0xFFFF
    493            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_185:
   \   000018                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine44 & 0xFFFF
    494          
    495            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_61:
   \   000020   700A         JNZ     ??ZDSecMgrAddrStore_0
    496            {
    497              // return successful results
    498              *ami   = entry.index;
   \   000022   740B         MOV     A,#0xb
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine12 & 0xFFFF
    499              status = ZSuccess;
    500            }
   \                     ??CrossCallReturnLabel_13:
   \   00002A   8008         SJMP    ??CrossCallReturnLabel_16
    501            else
    502            {
    503              // return failed results
    504              *ami   = entry.index;
   \                     ??ZDSecMgrAddrStore_0:
   \   00002C   740B         MOV     A,#0xb
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine13 & 0xFFFF
    505              status = ZNwkUnknownDevice;
    506            }
    507          
    508            return status;
   \                     ??CrossCallReturnLabel_16:
   \   000034   02....       LJMP    ?Subroutine78 & 0xFFFF
    509          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine44:
   \   000000   12....       LCALL   ?Subroutine63 & 0xFFFF
   \                     ??CrossCallReturnLabel_165:
   \   000003   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000006   E9           MOV     A,R1
   \   000007   6401         XRL     A,#0x1
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine18:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005   7402         MOV     A,#0x2
   \   000007   85..82       MOV     DPL,?XSP + 0
   \   00000A   85..83       MOV     DPH,?XSP + 1
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   7401         MOV     A,#0x1
   \   000010   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine13:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_73:
   \   000003   79C8         MOV     R1,#-0x38
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine12:
   \   000000   12....       LCALL   ?Subroutine48 & 0xFFFF
   \                     ??CrossCallReturnLabel_72:
   \   000003   7900         MOV     R1,#0x0
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine48:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   8E82         MOV     DPL,R6
   \   000007   8F83         MOV     DPH,R7
   \   000009   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_202:
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine78:
   \   000000   740D         MOV     A,#0xd
   \   000002   02....       LJMP    ??Subroutine92_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine63:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   12....       LCALL   ??AddrMgrExtAddrSet?relay
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000007                ; Setup parameters for call to function AddrMgrEntryLookupExt
   \   000007                REQUIRE ?Subroutine67
   \   000007                ; // Fall through to label ?Subroutine67

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine67:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   AA82         MOV     R2,DPL
   \   000008   AB83         MOV     R3,DPH
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine92_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine93_0
   \   000003                ; // Fall through to label ??Subroutine93_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine93_0:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine65:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET
    510          
    511          /******************************************************************************
    512           * @fn          ZDSecMgrExtAddrStore
    513           *
    514           * @brief       Store EXT address.
    515           *
    516           * @param       extAddr - [in] EXT address
    517           * @param       ami     - [out] Address Manager index
    518           *
    519           * @return      ZStatus_t
    520           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    521          ZStatus_t ZDSecMgrExtAddrStore( uint16 nwkAddr, uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrStore:
    522          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   7416         MOV     A,#0x16
   \   00000C   12....       LCALL   ?XSTACK_DISP0_8
   \   00000F   12....       LCALL   ?Subroutine18 & 0xFFFF
    523            ZStatus_t      status;
    524            AddrMgrEntry_t entry;
    525          
    526          
    527            // add entry
    528            entry.user    = ADDRMGR_USER_SECURITY;
    529            entry.nwkAddr = nwkAddr;
   \                     ??CrossCallReturnLabel_20:
   \   000012   12....       LCALL   ?XSTACK_DISP0_8
   \   000015   12....       LCALL   ??Subroutine101_0 & 0xFFFF
    530            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \                     ??CrossCallReturnLabel_186:
   \   000018                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000018   7403         MOV     A,#0x3
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   12....       LCALL   ?Subroutine44 & 0xFFFF
    531          
    532            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_62:
   \   000020   700A         JNZ     ??ZDSecMgrExtAddrStore_0
    533            {
    534              // return successful results
    535              *ami   = entry.index;
   \   000022   740B         MOV     A,#0xb
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   12....       LCALL   ?Subroutine12 & 0xFFFF
    536              status = ZSuccess;
    537            }
   \                     ??CrossCallReturnLabel_14:
   \   00002A   8008         SJMP    ??CrossCallReturnLabel_17
    538            else
    539            {
    540              // return failed results
    541              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrStore_0:
   \   00002C   740B         MOV     A,#0xb
   \   00002E   12....       LCALL   ?XSTACK_DISP0_8
   \   000031   12....       LCALL   ?Subroutine13 & 0xFFFF
    542              status = ZNwkUnknownDevice;
    543            }
    544          
    545            return status;
   \                     ??CrossCallReturnLabel_17:
   \   000034   80..         SJMP    ?Subroutine78
    546          }
    547          
    548          /******************************************************************************
    549           * @fn          ZDSecMgrExtAddrLookup
    550           *
    551           * @brief       Lookup index for specified EXT address.
    552           *
    553           * @param       extAddr - [in] EXT address
    554           * @param       ami     - [out] Address Manager index
    555           *
    556           * @return      ZStatus_t
    557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    558          ZStatus_t ZDSecMgrExtAddrLookup( uint8* extAddr, uint16* ami )
   \                     ZDSecMgrExtAddrLookup:
    559          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    560            ZStatus_t      status;
    561            AddrMgrEntry_t entry;
    562          
    563          
    564            // lookup entry
    565            entry.user = ADDRMGR_USER_SECURITY;
   \   00000E   7402         MOV     A,#0x2
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   F0           MOVX    @DPTR,A
    566            AddrMgrExtAddrSet( entry.extAddr, extAddr );
   \   000017                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000017   EA           MOV     A,R2
   \   000018   FC           MOV     R4,A
   \   000019   EB           MOV     A,R3
   \   00001A   FD           MOV     R5,A
   \   00001B   7403         MOV     A,#0x3
   \   00001D   12....       LCALL   ?XSTACK_DISP0_8
   \   000020   12....       LCALL   ?Subroutine63 & 0xFFFF
    567          
    568            if ( AddrMgrEntryLookupExt( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_166:
   \   000023   12....       LCALL   ??AddrMgrEntryLookupExt?relay
   \   000026   E9           MOV     A,R1
   \   000027   6401         XRL     A,#0x1
   \   000029   700A         JNZ     ??ZDSecMgrExtAddrLookup_0
    569            {
    570              // return successful results
    571              *ami   = entry.index;
   \   00002B   740B         MOV     A,#0xb
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   12....       LCALL   ?Subroutine12 & 0xFFFF
    572              status = ZSuccess;
    573            }
   \                     ??CrossCallReturnLabel_15:
   \   000033   8008         SJMP    ??CrossCallReturnLabel_18
    574            else
    575            {
    576              // return failed results
    577              *ami   = entry.index;
   \                     ??ZDSecMgrExtAddrLookup_0:
   \   000035   740B         MOV     A,#0xb
   \   000037   12....       LCALL   ?XSTACK_DISP0_8
   \   00003A   12....       LCALL   ?Subroutine13 & 0xFFFF
    578              status = ZNwkUnknownDevice;
    579            }
    580          
    581            return status;
   \                     ??CrossCallReturnLabel_18:
   \   00003D                REQUIRE ?Subroutine78
   \   00003D                ; // Fall through to label ?Subroutine78
    582          }
    583          
    584          /******************************************************************************
    585           * @fn          ZDSecMgrMasterKeyLookup
    586           *
    587           * @brief       Lookup MASTER key for specified address index.
    588           *
    589           * @param       ami - [in] Address Manager index
    590           * @param       key - [out] valid MASTER key
    591           *
    592           * @return      ZStatus_t
    593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    594          ZStatus_t ZDSecMgrMasterKeyLookup( uint16 ami, uint8** key )
   \                     ZDSecMgrMasterKeyLookup:
    595          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   12....       LCALL   ?Subroutine60 & 0xFFFF
    596            ZStatus_t status;
    597            uint16    index;
    598          
    599          
    600            // initialize results
    601            *key   = NULL;
    602            status = ZNwkUnknownDevice;
    603          
    604            // verify data is available
    605            if ( ZDSecMgrMasterKeyData != NULL )
   \                     ??CrossCallReturnLabel_114:
   \   000008   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   7002         JNZ     ??ZDSecMgrMasterKeyLookup_0
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrMasterKeyLookup_0:
   \   000010   603F         JZ      ??ZDSecMgrMasterKeyLookup_1
    606            {
    607              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000012   7800         MOV     R0,#0x0
   \   000014   7900         MOV     R1,#0x0
    608              {
    609                if ( ZDSecMgrMasterKeyData[index].ami == ami )
   \                     ??ZDSecMgrMasterKeyLookup_2:
   \   000016   E8           MOV     A,R0
   \   000017   FC           MOV     R4,A
   \   000018   E9           MOV     A,R1
   \   000019   FD           MOV     R5,A
   \   00001A   EC           MOV     A,R4
   \   00001B   75F012       MOV     B,#0x12
   \   00001E   A4           MUL     AB
   \   00001F   FC           MOV     R4,A
   \   000020   85F0..       MOV     ?V0 + 1,B
   \   000023   75F012       MOV     B,#0x12
   \   000026   ED           MOV     A,R5
   \   000027   A4           MUL     AB
   \   000028   25..         ADD     A,?V0 + 1
   \   00002A   FD           MOV     R5,A
   \   00002B   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   2C           ADD     A,R4
   \   000030   FC           MOV     R4,A
   \   000031   A3           INC     DPTR
   \   000032   E0           MOVX    A,@DPTR
   \   000033   3D           ADDC    A,R5
   \   000034   FD           MOV     R5,A
   \   000035   8C82         MOV     DPL,R4
   \   000037   8D83         MOV     DPH,R5
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6A           XRL     A,R2
   \   00003B   7003         JNZ     ??ZDSecMgrMasterKeyLookup_3
   \   00003D   A3           INC     DPTR
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   6B           XRL     A,R3
   \                     ??ZDSecMgrMasterKeyLookup_3:
   \   000040   700A         JNZ     ??CrossCallReturnLabel_108
    610                {
    611                  // return successful results
    612                  *key   = ZDSecMgrMasterKeyData[index].key;
   \   000042   EC           MOV     A,R4
   \   000043   2402         ADD     A,#0x2
   \   000045   F8           MOV     R0,A
   \   000046   ED           MOV     A,R5
   \   000047   3400         ADDC    A,#0x0
   \   000049   12....       LCALL   ?Subroutine3 & 0xFFFF
    613                  status = ZSuccess;
    614          
    615                  // break from loop
    616                  index  = ZDSECMGR_MASTERKEY_MAX;
    617                }
    618              }
   \                     ??CrossCallReturnLabel_108:
   \   00004C   12....       LCALL   ?Subroutine38 & 0xFFFF
    619            }
   \                     ??CrossCallReturnLabel_50:
   \   00004F   40C5         JC      ??ZDSecMgrMasterKeyLookup_2
    620          
    621            return status;
   \                     ??ZDSecMgrMasterKeyLookup_1:
   \   000051                REQUIRE ?Subroutine80
   \   000051                ; // Fall through to label ?Subroutine80
    622          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine80:
   \   000000   A9..         MOV     R1,?V0 + 0
   \   000002   02....       LJMP    ??Subroutine104_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine60:
   \   000000   EC           MOV     A,R4
   \   000001   FE           MOV     R6,A
   \   000002   ED           MOV     A,R5
   \   000003   FF           MOV     R7,A
   \   000004   8E82         MOV     DPL,R6
   \   000006   8F83         MOV     DPH,R7
   \   000008                REQUIRE ??Subroutine84_0
   \   000008                ; // Fall through to label ??Subroutine84_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine84_0:
   \   000000   E4           CLR     A
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   F0           MOVX    @DPTR,A
   \   000004   75..C8       MOV     ?V0 + 0,#-0x38
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   F9           MOV     R1,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine85_0
   \   000005                ; // Fall through to label ??Subroutine85_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine85_0:
   \   000000   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_203:
   \   000003   75..00       MOV     ?V0 + 0,#0x0
   \   000006   7803         MOV     R0,#0x3
   \   000008   7900         MOV     R1,#0x0
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine38:
   \   000000   12....       LCALL   ?Subroutine62 & 0xFFFF
   \                     ??CrossCallReturnLabel_107:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine104_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    623          
    624          /******************************************************************************
    625           * @fn          ZDSecMgrMasterKeyStore
    626           *
    627           * @brief       Store MASTER key for specified address index.
    628           *
    629           * @param       ami - [in] Address Manager index
    630           * @param       key - [in] valid key to store
    631           *
    632           * @return      ZStatus_t
    633           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    634          ZStatus_t ZDSecMgrMasterKeyStore( uint16 ami, uint8* key )
   \                     ZDSecMgrMasterKeyStore:
    635          {
   \   000000   74F2         MOV     A,#-0xe
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 14
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 4,R2
   \   000007   8B..         MOV     ?V0 + 5,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
    636            ZStatus_t status;
    637            uint16    index;
    638            uint8*    entry;
    639          
    640          
    641            // initialize results
    642            status = ZNwkUnknownDevice;
   \   00000D   7CC8         MOV     R4,#-0x38
    643          
    644            // verify data is available
    645            if ( ZDSecMgrMasterKeyData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7002         JNZ     ??ZDSecMgrMasterKeyStore_0
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrMasterKeyStore_0:
   \   000017   606F         JZ      ??ZDSecMgrMasterKeyStore_1
    646            {
    647              for ( index = 0; index < ZDSECMGR_MASTERKEY_MAX ; index++ )
   \   000019   7800         MOV     R0,#0x0
   \   00001B   7900         MOV     R1,#0x0
    648              {
    649                if ( ZDSecMgrMasterKeyData[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrMasterKeyStore_2:
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   EA           MOV     A,R2
   \   000022   75F012       MOV     B,#0x12
   \   000025   A4           MUL     AB
   \   000026   FA           MOV     R2,A
   \   000027   ADF0         MOV     R5,B
   \   000029   75F012       MOV     B,#0x12
   \   00002C   EB           MOV     A,R3
   \   00002D   A4           MUL     AB
   \   00002E   2D           ADD     A,R5
   \   00002F   FB           MOV     R3,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrMasterKeyData
   \   000033   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_30:
   \   000036   64FE         XRL     A,#0xfe
   \   000038   7004         JNZ     ??ZDSecMgrMasterKeyStore_3
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrMasterKeyStore_3:
   \   00003E   7043         JNZ     ??ZDSecMgrMasterKeyStore_4
    650                {
    651                  // store EXT address index
    652                  ZDSecMgrMasterKeyData[index].ami = ami;
   \   000040   8A82         MOV     DPL,R2
   \   000042   8B83         MOV     DPH,R3
   \   000044   E5..         MOV     A,?V0 + 4
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   E5..         MOV     A,?V0 + 5
   \   00004A   F0           MOVX    @DPTR,A
    653          
    654                  entry = ZDSecMgrMasterKeyData[index].key;
   \   00004B   EA           MOV     A,R2
   \   00004C   2402         ADD     A,#0x2
   \   00004E   0A           INC     R2
   \   00004F   0A           INC     R2
   \   000050   EB           MOV     A,R3
   \   000051   3400         ADDC    A,#0x0
   \   000053   FB           MOV     R3,A
    655          
    656                  if ( key != NULL )
   \   000054   EE           MOV     A,R6
   \   000055   7001         JNZ     ??ZDSecMgrMasterKeyStore_5
   \   000057   EF           MOV     A,R7
   \                     ??ZDSecMgrMasterKeyStore_5:
   \   000058   601A         JZ      ??ZDSecMgrMasterKeyStore_6
    657                  {
    658                    osal_memcpy( entry, key,  SEC_KEY_LEN );
   \   00005A                ; Setup parameters for call to function osal_memcpy
   \   00005A   8E..         MOV     ?V0 + 0,R6
   \   00005C   8F..         MOV     ?V0 + 1,R7
   \   00005E   75..00       MOV     ?V0 + 2,#0x0
   \   000061   78..         MOV     R0,#?V0 + 0
   \   000063   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000066   7C10         MOV     R4,#0x10
   \   000068   7D00         MOV     R5,#0x0
   \   00006A   12....       LCALL   ??osal_memcpy?relay
   \   00006D   7403         MOV     A,#0x3
   \   00006F   12....       LCALL   ?DEALLOC_XSTACK8
   \   000072   8009         SJMP    ??ZDSecMgrMasterKeyStore_7
    659                  }
    660                  else
    661                  {
    662                    osal_memset( entry, 0, SEC_KEY_LEN );
   \                     ??ZDSecMgrMasterKeyStore_6:
   \   000074                ; Setup parameters for call to function osal_memset
   \   000074   7C10         MOV     R4,#0x10
   \   000076   7D00         MOV     R5,#0x0
   \   000078   7900         MOV     R1,#0x0
   \   00007A   12....       LCALL   ??osal_memset?relay
    663                  }
    664          
    665                  // return successful results
    666                  status = ZSuccess;
   \                     ??ZDSecMgrMasterKeyStore_7:
   \   00007D   7C00         MOV     R4,#0x0
    667          
    668                  // break from loop
    669                  index  = ZDSECMGR_MASTERKEY_MAX;
   \   00007F   7803         MOV     R0,#0x3
   \   000081   7900         MOV     R1,#0x0
    670                }
    671              }
   \                     ??ZDSecMgrMasterKeyStore_4:
   \   000083   12....       LCALL   ?Subroutine38 & 0xFFFF
    672            }
   \                     ??CrossCallReturnLabel_51:
   \   000086   4095         JC      ??ZDSecMgrMasterKeyStore_2
    673          
    674            return status;
   \                     ??ZDSecMgrMasterKeyStore_1:
   \   000088   EC           MOV     A,R4
   \   000089   F9           MOV     R1,A
   \   00008A   7F06         MOV     R7,#0x6
   \   00008C   02....       LJMP    ?BANKED_LEAVE_XDATA
    675          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine24:
   \   000000   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_98:
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine51:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2A           ADD     A,R2
   \   000002   FA           MOV     R2,A
   \   000003   A3           INC     DPTR
   \   000004   E0           MOVX    A,@DPTR
   \   000005   3B           ADDC    A,R3
   \   000006   FB           MOV     R3,A
   \   000007                REQUIRE ?Subroutine71
   \   000007                ; // Fall through to label ?Subroutine71

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine71:
   \   000000   8A82         MOV     DPL,R2
   \   000002   8B83         MOV     DPH,R3
   \   000004   22           RET
    676          
    677          /******************************************************************************
    678           * @fn          ZDSecMgrEntryInit
    679           *
    680           * @brief       Initialize entry sub module
    681           *
    682           * @param       none
    683           *
    684           * @return      none
    685           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    686          void ZDSecMgrEntryInit( void )
   \                     ZDSecMgrEntryInit:
    687          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    688            uint16 size;
    689            uint16 index;
    690          
    691            // allocate entry data
    692            size = (short)( sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX );
    693          
    694            ZDSecMgrEntries = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A57         MOV     R2,#0x57
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00000E   12....       LCALL   ??Subroutine101_0 & 0xFFFF
    695          
    696            // initialize data
    697            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_187:
   \   000011   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrEntryInit_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryInit_0:
   \   000019   601F         JZ      ??ZDSecMgrEntryInit_1
    698            {
    699              for( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    700              {
    701                ZDSecMgrEntries[index].ami = INVALID_NODE_ADDR;
   \                     ??ZDSecMgrEntryInit_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F01D       MOV     B,#0x1d
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   ACF0         MOV     R4,B
   \   00002B   75F01D       MOV     B,#0x1d
   \   00002E   EB           MOV     A,R3
   \   00002F   A4           MUL     AB
   \   000030   2C           ADD     A,R4
   \   000031   FB           MOV     R3,A
   \   000032   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000035   12....       LCALL   ?Subroutine2 & 0xFFFF
    702              }
    703            }
   \                     ??CrossCallReturnLabel_104:
   \   000038   40E5         JC      ??ZDSecMgrEntryInit_2
    704            ZDSecMgrRestoreFromNV();
   \                     ??ZDSecMgrEntryInit_1:
   \   00003A                ; Setup parameters for call to function ZDSecMgrRestoreFromNV
   \   00003A   12....       LCALL   ??ZDSecMgrRestoreFromNV?relay
    705          }
   \   00003D   02....       LJMP    ??Subroutine97_0 & 0xFFFF
    706          
    707          /******************************************************************************
    708           * @fn          ZDSecMgrEntryLookup
    709           *
    710           * @brief       Lookup entry index using specified NWK address.
    711           *
    712           * @param       nwkAddr - [in] NWK address
    713           * @param       entry   - [out] valid entry
    714           *
    715           * @return      ZStatus_t
    716           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    717          ZStatus_t ZDSecMgrEntryLookup( uint16 nwkAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookup:
    718          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   12....       LCALL   ?Subroutine6 & 0xFFFF
    719            ZStatus_t      status;
    720            uint16         index;
    721            AddrMgrEntry_t addrMgrEntry;
    722          
    723          
    724            // initialize results
    725            *entry = NULL;
    726            status = ZNwkUnknownDevice;
    727          
    728            // verify data is available
    729            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_111:
   \   000010   7002         JNZ     ??ZDSecMgrEntryLookup_0
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryLookup_0:
   \   000014   605C         JZ      ??ZDSecMgrEntryLookup_1
    730            {
    731              addrMgrEntry.user    = ADDRMGR_USER_SECURITY;
   \   000016   7402         MOV     A,#0x2
   \   000018   85..82       MOV     DPL,?XSP + 0
   \   00001B   85..83       MOV     DPH,?XSP + 1
   \   00001E   F0           MOVX    @DPTR,A
    732              addrMgrEntry.nwkAddr = nwkAddr;
   \   00001F   7401         MOV     A,#0x1
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   12....       LCALL   ?Subroutine1 & 0xFFFF
    733          
    734              if ( AddrMgrEntryLookupNwk( &addrMgrEntry ) == TRUE )
   \                     ??CrossCallReturnLabel_152:
   \   000027   12....       LCALL   ??AddrMgrEntryLookupNwk?relay
   \   00002A   E9           MOV     A,R1
   \   00002B   6401         XRL     A,#0x1
   \   00002D   7043         JNZ     ??ZDSecMgrEntryLookup_1
    735              {
    736                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   00002F   7800         MOV     R0,#0x0
   \   000031   7900         MOV     R1,#0x0
    737                {
    738                  if ( addrMgrEntry.index == ZDSecMgrEntries[index].ami )
   \                     ??ZDSecMgrEntryLookup_2:
   \   000033   E8           MOV     A,R0
   \   000034   FA           MOV     R2,A
   \   000035   E9           MOV     A,R1
   \   000036   FB           MOV     R3,A
   \   000037   EA           MOV     A,R2
   \   000038   75F01D       MOV     B,#0x1d
   \   00003B   A4           MUL     AB
   \   00003C   FA           MOV     R2,A
   \   00003D   ACF0         MOV     R4,B
   \   00003F   75F01D       MOV     B,#0x1d
   \   000042   EB           MOV     A,R3
   \   000043   A4           MUL     AB
   \   000044   2C           ADD     A,R4
   \   000045   FB           MOV     R3,A
   \   000046   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   2A           ADD     A,R2
   \   00004B   FA           MOV     R2,A
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   3B           ADDC    A,R3
   \   00004F   FB           MOV     R3,A
   \   000050   740B         MOV     A,#0xb
   \   000052   12....       LCALL   ?XSTACK_DISP0_8
   \   000055   E0           MOVX    A,@DPTR
   \   000056   FC           MOV     R4,A
   \   000057   A3           INC     DPTR
   \   000058   E0           MOVX    A,@DPTR
   \   000059   FD           MOV     R5,A
   \   00005A   8A82         MOV     DPL,R2
   \   00005C   8B83         MOV     DPH,R3
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   6C           XRL     A,R4
   \   000060   7003         JNZ     ??ZDSecMgrEntryLookup_3
   \   000062   A3           INC     DPTR
   \   000063   E0           MOVX    A,@DPTR
   \   000064   6D           XRL     A,R5
   \                     ??ZDSecMgrEntryLookup_3:
   \   000065   7006         JNZ     ??CrossCallReturnLabel_109
    739                  {
    740                    // return successful results
    741                    *entry = &ZDSecMgrEntries[index];
   \   000067   EA           MOV     A,R2
   \   000068   F8           MOV     R0,A
   \   000069   EB           MOV     A,R3
   \   00006A   12....       LCALL   ?Subroutine3 & 0xFFFF
    742                    status = ZSuccess;
    743          
    744                    // break from loop
    745                    index = ZDSECMGR_ENTRY_MAX;
    746                  }
    747                }
   \                     ??CrossCallReturnLabel_109:
   \   00006D   12....       LCALL   ?Subroutine38 & 0xFFFF
    748              }
    749            }
   \                     ??CrossCallReturnLabel_52:
   \   000070   40C1         JC      ??ZDSecMgrEntryLookup_2
    750          
    751            return status;
   \                     ??ZDSecMgrEntryLookup_1:
   \   000072   A9..         MOV     R1,?V0 + 0
   \   000074                REQUIRE ?Subroutine81
   \   000074                ; // Fall through to label ?Subroutine81
    752          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine81:
   \   000000   740D         MOV     A,#0xd
   \   000002   02....       LJMP    ??Subroutine103_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   FF           MOV     R7,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ??Subroutine86_0
   \   000005                ; // Fall through to label ??Subroutine86_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine86_0:
   \   000000   12....       LCALL   ??Subroutine84_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_116:
   \   000003   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   EA           MOV     A,R2
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   EB           MOV     A,R3
   \   000004                REQUIRE ??Subroutine98_0
   \   000004                ; // Fall through to label ??Subroutine98_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine98_0:
   \   000000   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_163:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine103_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine104_0
   \   000003                ; // Fall through to label ??Subroutine104_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine58:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AddrMgrEntryLookupNwk
   \   000001                ; Setup parameters for call to function AddrMgrEntryGet
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyReq
   \   000001                ; Setup parameters for call to function APSME_TransportKeyReq
   \   000001                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   000001                ; Setup parameters for call to function NLME_LeaveReq
   \   000001                ; Setup parameters for call to function APSME_UpdateDeviceReq
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceNew
   \   000001                ; Setup parameters for call to function APSME_EstablishKeyRsp
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000001                ; Setup parameters for call to function APSME_AuthenticateReq
   \   000001                ; Setup parameters for call to function APSME_RequestKeyReq
   \   000001                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   000001   02....       LJMP    ?Subroutine67 & 0xFFFF
    753          
    754          /******************************************************************************
    755           * @fn          ZDSecMgrEntryLookupAMI
    756           *
    757           * @brief       Lookup entry using specified address index
    758           *
    759           * @param       ami   - [in] Address Manager index
    760           * @param       entry - [out] valid entry
    761           *
    762           * @return      ZStatus_t
    763           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    764          ZStatus_t ZDSecMgrEntryLookupAMI( uint16 ami, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupAMI:
    765          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    766            ZStatus_t status;
    767            uint16    index;
    768          
    769          
    770            // initialize results
    771            *entry = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   12....       LCALL   ??Subroutine86_0 & 0xFFFF
    772            status = ZNwkUnknownDevice;
    773          
    774            // verify data is available
    775            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_113:
   \   000010   7002         JNZ     ??ZDSecMgrEntryLookupAMI_0
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryLookupAMI_0:
   \   000014   6037         JZ      ??ZDSecMgrEntryLookupAMI_1
    776            {
    777              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000016   7800         MOV     R0,#0x0
   \   000018   7900         MOV     R1,#0x0
    778              {
    779                if ( ZDSecMgrEntries[index].ami == ami )
   \                     ??ZDSecMgrEntryLookupAMI_2:
   \   00001A   E8           MOV     A,R0
   \   00001B   FA           MOV     R2,A
   \   00001C   E9           MOV     A,R1
   \   00001D   FB           MOV     R3,A
   \   00001E   EA           MOV     A,R2
   \   00001F   75F01D       MOV     B,#0x1d
   \   000022   A4           MUL     AB
   \   000023   FA           MOV     R2,A
   \   000024   85F0..       MOV     ?V0 + 1,B
   \   000027   75F01D       MOV     B,#0x1d
   \   00002A   EB           MOV     A,R3
   \   00002B   A4           MUL     AB
   \   00002C   25..         ADD     A,?V0 + 1
   \   00002E   FB           MOV     R3,A
   \   00002F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000032   12....       LCALL   ?Subroutine24 & 0xFFFF
   \                     ??CrossCallReturnLabel_31:
   \   000035   6E           XRL     A,R6
   \   000036   7003         JNZ     ??ZDSecMgrEntryLookupAMI_3
   \   000038   A3           INC     DPTR
   \   000039   E0           MOVX    A,@DPTR
   \   00003A   6F           XRL     A,R7
   \                     ??ZDSecMgrEntryLookupAMI_3:
   \   00003B   700B         JNZ     ??CrossCallReturnLabel_110
    780                {
    781                  // return successful results
    782                  *entry = &ZDSecMgrEntries[index];
   \   00003D   EA           MOV     A,R2
   \   00003E   F8           MOV     R0,A
   \   00003F   EB           MOV     A,R3
   \   000040   F9           MOV     R1,A
   \   000041   8C82         MOV     DPL,R4
   \   000043   8D83         MOV     DPH,R5
   \   000045   12....       LCALL   ??Subroutine85_0 & 0xFFFF
    783                  status = ZSuccess;
    784          
    785                  // break from loop
    786                  index = ZDSECMGR_ENTRY_MAX;
    787                }
    788              }
   \                     ??CrossCallReturnLabel_110:
   \   000048   12....       LCALL   ?Subroutine38 & 0xFFFF
    789            }
   \                     ??CrossCallReturnLabel_53:
   \   00004B   40CD         JC      ??ZDSecMgrEntryLookupAMI_2
    790          
    791            return status;
   \                     ??ZDSecMgrEntryLookupAMI_1:
   \   00004D   02....       LJMP    ?Subroutine80 & 0xFFFF
    792          }
    793          
    794          /******************************************************************************
    795           * @fn          ZDSecMgrEntryLookupExt
    796           *
    797           * @brief       Lookup entry index using specified EXT address.
    798           *
    799           * @param       extAddr - [in] EXT address
    800           * @param       entry   - [out] valid entry
    801           *
    802           * @return      ZStatus_t
    803           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    804          ZStatus_t ZDSecMgrEntryLookupExt( uint8* extAddr, ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryLookupExt:
    805          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine60 & 0xFFFF
    806            ZStatus_t status;
    807            uint16    ami;
    808          
    809          
    810            // initialize results
    811            *entry = NULL;
    812            status = ZNwkUnknownDevice;
    813          
    814            // lookup address index
    815            if ( ZDSecMgrExtAddrLookup( extAddr, &ami ) == ZSuccess )
   \                     ??CrossCallReturnLabel_115:
   \   00000D                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000D   85..82       MOV     DPL,?XSP + 0
   \   000010   85..83       MOV     DPH,?XSP + 1
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001A   E9           MOV     A,R1
   \   00001B   7010         JNZ     ??ZDSecMgrEntryLookupExt_0
    816            {
    817              status = ZDSecMgrEntryLookupAMI( ami, entry );
   \   00001D                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00001D   EE           MOV     A,R6
   \   00001E   FC           MOV     R4,A
   \   00001F   EF           MOV     A,R7
   \   000020   FD           MOV     R5,A
   \   000021   85..82       MOV     DPL,?XSP + 0
   \   000024   85..83       MOV     DPH,?XSP + 1
   \   000027   12....       LCALL   ?Subroutine31 & 0xFFFF
    818            }
   \                     ??CrossCallReturnLabel_40:
   \   00002A   E9           MOV     A,R1
   \   00002B   F5..         MOV     ?V0 + 0,A
    819          
    820            return status;
   \                     ??ZDSecMgrEntryLookupExt_0:
   \   00002D   02....       LJMP    ?Subroutine73 & 0xFFFF
    821          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine73:
   \   000000   A9..         MOV     R1,?V0 + 0
   \   000002                REQUIRE ??Subroutine91_0
   \   000002                ; // Fall through to label ??Subroutine91_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine91_0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine92_0
   \   000002                ; // Fall through to label ??Subroutine92_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine55:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine31:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_143:
   \   000003   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000006   22           RET
    822          
    823          /******************************************************************************
    824           * @fn          ZDSecMgrEntryFree
    825           *
    826           * @brief       Free entry.
    827           *
    828           * @param       entry - [in] valid entry
    829           *
    830           * @return      ZStatus_t
    831           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    832          void ZDSecMgrEntryFree( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrEntryFree:
   \   000000   02....       LJMP    ?Subroutine66 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine66:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   74FE         MOV     A,#-0x2
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   74FF         MOV     A,#-0x1
   \   00000E                REQUIRE ??Subroutine96_0
   \   00000E                ; // Fall through to label ??Subroutine96_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine96_0:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                REQUIRE ??Subroutine97_0
   \   000001                ; // Fall through to label ??Subroutine97_0
    833          {
    834            entry->ami = INVALID_NODE_ADDR;
    835          }
    836          
    837          /******************************************************************************
    838           * @fn          ZDSecMgrEntryNew
    839           *
    840           * @brief       Get a new entry.
    841           *
    842           * @param       entry - [out] valid entry
    843           *
    844           * @return      ZStatus_t
    845           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    846          ZStatus_t ZDSecMgrEntryNew( ZDSecMgrEntry_t** entry )
   \                     ZDSecMgrEntryNew:
    847          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   12....       LCALL   ?Subroutine6 & 0xFFFF
    848            ZStatus_t status;
    849            uint16    index;
    850          
    851          
    852            // initialize results
    853            *entry = NULL;
    854            status = ZNwkUnknownDevice;
    855          
    856            // verify data is available
    857            if ( ZDSecMgrEntries != NULL )
   \                     ??CrossCallReturnLabel_112:
   \   00000B   7002         JNZ     ??ZDSecMgrEntryNew_0
   \   00000D   A3           INC     DPTR
   \   00000E   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEntryNew_0:
   \   00000F   605B         JZ      ??ZDSecMgrEntryNew_1
    858            {
    859              // find available entry
    860              for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   \   000011   7A00         MOV     R2,#0x0
   \   000013   7B00         MOV     R3,#0x0
    861              {
    862                if ( ZDSecMgrEntries[index].ami == INVALID_NODE_ADDR )
   \                     ??ZDSecMgrEntryNew_2:
   \   000015   EA           MOV     A,R2
   \   000016   F8           MOV     R0,A
   \   000017   EB           MOV     A,R3
   \   000018   F9           MOV     R1,A
   \   000019   E8           MOV     A,R0
   \   00001A   75F01D       MOV     B,#0x1d
   \   00001D   A4           MUL     AB
   \   00001E   F8           MOV     R0,A
   \   00001F   ACF0         MOV     R4,B
   \   000021   75F01D       MOV     B,#0x1d
   \   000024   E9           MOV     A,R1
   \   000025   A4           MUL     AB
   \   000026   2C           ADD     A,R4
   \   000027   F9           MOV     R1,A
   \   000028   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002B   E0           MOVX    A,@DPTR
   \   00002C   28           ADD     A,R0
   \   00002D   FC           MOV     R4,A
   \   00002E   A3           INC     DPTR
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   39           ADDC    A,R1
   \   000031   FD           MOV     R5,A
   \   000032   8C82         MOV     DPL,R4
   \   000034   8D83         MOV     DPH,R5
   \   000036   E0           MOVX    A,@DPTR
   \   000037   64FE         XRL     A,#0xfe
   \   000039   7004         JNZ     ??ZDSecMgrEntryNew_3
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrEntryNew_3:
   \   00003F   7026         JNZ     ??ZDSecMgrEntryNew_4
    863                {
    864                  // return successful result
    865                  *entry = &ZDSecMgrEntries[index];
   \   000041   EC           MOV     A,R4
   \   000042   FA           MOV     R2,A
   \   000043   ED           MOV     A,R5
   \   000044   FB           MOV     R3,A
   \   000045   8E82         MOV     DPL,R6
   \   000047   8F83         MOV     DPH,R7
   \   000049   12....       LCALL   ??Subroutine101_0 & 0xFFFF
    866                  status = ZSuccess;
   \                     ??CrossCallReturnLabel_188:
   \   00004C   75..00       MOV     ?V0 + 0,#0x0
    867          
    868                  // Set the authentication option to default
    869                  ZDSecMgrEntries[index].authenticateOption = ZDSecMgr_Not_Authenticated;
   \   00004F   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000052   E0           MOVX    A,@DPTR
   \   000053   28           ADD     A,R0
   \   000054   F8           MOV     R0,A
   \   000055   A3           INC     DPTR
   \   000056   E0           MOVX    A,@DPTR
   \   000057   39           ADDC    A,R1
   \   000058   F9           MOV     R1,A
   \   000059   741C         MOV     A,#0x1c
   \   00005B   28           ADD     A,R0
   \   00005C   F582         MOV     DPL,A
   \   00005E   E4           CLR     A
   \   00005F   39           ADDC    A,R1
   \   000060   F583         MOV     DPH,A
   \   000062   E4           CLR     A
   \   000063   F0           MOVX    @DPTR,A
    870          
    871                  // break from loop
    872                  index = ZDSECMGR_ENTRY_MAX;
   \   000064   7A03         MOV     R2,#0x3
   \   000066   FB           MOV     R3,A
    873                }
    874              }
   \                     ??ZDSecMgrEntryNew_4:
   \   000067   12....       LCALL   ?Subroutine39 & 0xFFFF
    875            }
   \                     ??CrossCallReturnLabel_55:
   \   00006A   40A9         JC      ??ZDSecMgrEntryNew_2
    876          
    877            return status;
   \                     ??ZDSecMgrEntryNew_1:
   \   00006C   02....       LJMP    ?Subroutine80 & 0xFFFF
    878          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine39:
   \   000000   EA           MOV     A,R2
   \   000001   2401         ADD     A,#0x1
   \   000003   0A           INC     R2
   \   000004   EB           MOV     A,R3
   \   000005   3400         ADDC    A,#0x0
   \   000007   FB           MOV     R3,A
   \   000008   C3           CLR     C
   \   000009   EA           MOV     A,R2
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   EB           MOV     A,R3
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET
    879          
    880          /******************************************************************************
    881           * @fn          ZDSecMgrCtrlInit
    882           *
    883           * @brief       Initialize control sub module
    884           *
    885           * @param       none
    886           *
    887           * @return      none
    888           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    889          void ZDSecMgrCtrlInit( void )
   \                     ZDSecMgrCtrlInit:
    890          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    891            uint16 size;
    892            uint16 index;
    893          
    894            // allocate entry data
    895            size = (short)( sizeof(ZDSecMgrCtrl_t) * ZDSECMGR_CTRL_MAX );
    896          
    897            ZDSecMgrCtrlData = osal_mem_alloc( size );
   \   000004                ; Setup parameters for call to function osal_mem_alloc
   \   000004   7A15         MOV     R2,#0x15
   \   000006   7B00         MOV     R3,#0x0
   \   000008   12....       LCALL   ??osal_mem_alloc?relay
   \   00000B   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000E   12....       LCALL   ??Subroutine101_0 & 0xFFFF
    898          
    899            // initialize data
    900            if ( ZDSecMgrCtrlData != NULL )
   \                     ??CrossCallReturnLabel_189:
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrCtrlInit_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlInit_0:
   \   000019   6028         JZ      ??ZDSecMgrCtrlInit_1
    901            {
    902              for( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    903              {
    904                ZDSecMgrCtrlData[index].state = ZDSECMGR_CTRL_NONE;
   \                     ??ZDSecMgrCtrlInit_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F007       MOV     B,#0x7
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   ACF0         MOV     R4,B
   \   00002B   75F007       MOV     B,#0x7
   \   00002E   EB           MOV     A,R3
   \   00002F   A4           MUL     AB
   \   000030   2C           ADD     A,R4
   \   000031   FB           MOV     R3,A
   \   000032   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000035   12....       LCALL   ?Subroutine52 & 0xFFFF
    905              }
    906            }
   \                     ??CrossCallReturnLabel_74:
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   E4           CLR     A
   \   00003E   12....       LCALL   ??Subroutine83_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_105:
   \   000041   40DC         JC      ??ZDSecMgrCtrlInit_2
    907          }
   \                     ??ZDSecMgrCtrlInit_1:
   \   000043   02....       LJMP    ??Subroutine97_0 & 0xFFFF
    908          
    909          /******************************************************************************
    910           * @fn          ZDSecMgrCtrlRelease
    911           *
    912           * @brief       Release control data.
    913           *
    914           * @param       ctrl - [in] valid control data
    915           *
    916           * @return      none
    917           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    918          void ZDSecMgrCtrlRelease( ZDSecMgrCtrl_t* ctrl )
   \                     ZDSecMgrCtrlRelease:
    919          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    920            // should always be enough entry control data
    921            ctrl->state = ZDSECMGR_CTRL_NONE;
   \   000004   E4           CLR     A
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   A3           INC     DPTR
   \   00000E   02....       LJMP    ??Subroutine96_0 & 0xFFFF
    922          }
    923          
    924          /******************************************************************************
    925           * @fn          ZDSecMgrCtrlLookup
    926           *
    927           * @brief       Lookup control data.
    928           *
    929           * @param       entry - [in] valid entry data
    930           * @param       ctrl  - [out] control data - NULL if not found
    931           *
    932           * @return      none
    933           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    934          void ZDSecMgrCtrlLookup( ZDSecMgrEntry_t* entry, ZDSecMgrCtrl_t** ctrl )
   \                     ZDSecMgrCtrlLookup:
    935          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
    936            uint16 index;
    937          
    938          
    939            // initialize search results
    940            *ctrl = NULL;
   \   000009   8C82         MOV     DPL,R4
   \   00000B   8D83         MOV     DPH,R5
   \   00000D   E4           CLR     A
   \   00000E   F0           MOVX    @DPTR,A
   \   00000F   A3           INC     DPTR
   \   000010   F0           MOVX    @DPTR,A
    941          
    942            // verify data is available
    943            if ( ZDSecMgrCtrlData != NULL )
   \   000011   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000014   E0           MOVX    A,@DPTR
   \   000015   7002         JNZ     ??ZDSecMgrCtrlLookup_0
   \   000017   A3           INC     DPTR
   \   000018   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlLookup_0:
   \   000019   6050         JZ      ??ZDSecMgrCtrlLookup_1
    944            {
    945              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   00001B   7800         MOV     R0,#0x0
   \   00001D   7900         MOV     R1,#0x0
    946              {
    947                // make sure control data is in use
    948                if ( ZDSecMgrCtrlData[index].state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlLookup_2:
   \   00001F   E8           MOV     A,R0
   \   000020   FA           MOV     R2,A
   \   000021   E9           MOV     A,R1
   \   000022   FB           MOV     R3,A
   \   000023   EA           MOV     A,R2
   \   000024   75F007       MOV     B,#0x7
   \   000027   A4           MUL     AB
   \   000028   FA           MOV     R2,A
   \   000029   85F0..       MOV     ?V0 + 0,B
   \   00002C   75F007       MOV     B,#0x7
   \   00002F   EB           MOV     A,R3
   \   000030   A4           MUL     AB
   \   000031   25..         ADD     A,?V0 + 0
   \   000033   FB           MOV     R3,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000037   12....       LCALL   ?Subroutine51 & 0xFFFF
   \                     ??CrossCallReturnLabel_97:
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   E0           MOVX    A,@DPTR
   \   000040   6024         JZ      ??ZDSecMgrCtrlLookup_3
    949                {
    950                  // check for entry match
    951                  if ( ZDSecMgrCtrlData[index].entry == entry )
   \   000042   8A82         MOV     DPL,R2
   \   000044   8B83         MOV     DPH,R3
   \   000046   E0           MOVX    A,@DPTR
   \   000047   F5..         MOV     ?V0 + 0,A
   \   000049   A3           INC     DPTR
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   F5..         MOV     ?V0 + 1,A
   \   00004D   EE           MOV     A,R6
   \   00004E   65..         XRL     A,?V0 + 0
   \   000050   7003         JNZ     ??ZDSecMgrCtrlLookup_4
   \   000052   EF           MOV     A,R7
   \   000053   65..         XRL     A,?V0 + 1
   \                     ??ZDSecMgrCtrlLookup_4:
   \   000055   700F         JNZ     ??ZDSecMgrCtrlLookup_3
    952                  {
    953                    // return this control data
    954                    *ctrl = &ZDSecMgrCtrlData[index];
   \   000057   EA           MOV     A,R2
   \   000058   F8           MOV     R0,A
   \   000059   EB           MOV     A,R3
   \   00005A   F9           MOV     R1,A
   \   00005B   8C82         MOV     DPL,R4
   \   00005D   8D83         MOV     DPH,R5
   \   00005F   12....       LCALL   ??Subroutine100_0 & 0xFFFF
    955          
    956                    // break from loop
    957                    index = ZDSECMGR_CTRL_MAX;
   \                     ??CrossCallReturnLabel_167:
   \   000062   7803         MOV     R0,#0x3
   \   000064   7900         MOV     R1,#0x0
    958                  }
    959                }
    960              }
   \                     ??ZDSecMgrCtrlLookup_3:
   \   000066   12....       LCALL   ?Subroutine38 & 0xFFFF
    961            }
   \                     ??CrossCallReturnLabel_54:
   \   000069   40B4         JC      ??ZDSecMgrCtrlLookup_2
    962          }
   \                     ??ZDSecMgrCtrlLookup_1:
   \   00006B   02....       LJMP    ??Subroutine104_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine100_0:
   \   000000   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_206:
   \   000003   22           RET
    963          
    964          /******************************************************************************
    965           * @fn          ZDSecMgrCtrlSet
    966           *
    967           * @brief       Set control data.
    968           *
    969           * @param       device - [in] valid device data
    970           * @param       entry  - [in] valid entry data
    971           * @param       ctrl   - [in] valid control data
    972           *
    973           * @return      none
    974           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    975          void ZDSecMgrCtrlSet( ZDSecMgrDevice_t* device,
   \                     ZDSecMgrCtrlSet:
    976                                ZDSecMgrEntry_t*  entry,
    977                                ZDSecMgrCtrl_t*   ctrl )
    978          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   7409         MOV     A,#0x9
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ??Subroutine110_0 & 0xFFFF
    979            // set control date
    980            ctrl->parentAddr = device->parentAddr;
   \                     ??CrossCallReturnLabel_210:
   \   00000D   8A82         MOV     DPL,R2
   \   00000F   8B83         MOV     DPH,R3
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   A3           INC     DPTR
   \   000015   12....       LCALL   ?Subroutine32 & 0xFFFF
   \                     ??CrossCallReturnLabel_100:
   \   000018   A3           INC     DPTR
   \   000019   A3           INC     DPTR
   \   00001A   EE           MOV     A,R6
   \   00001B   F0           MOVX    @DPTR,A
   \   00001C   A3           INC     DPTR
   \   00001D   EF           MOV     A,R7
   \   00001E   12....       LCALL   ?Subroutine10 & 0xFFFF
    981            ctrl->secure     = device->secure;
   \                     ??CrossCallReturnLabel_125:
   \   000021   E0           MOVX    A,@DPTR
   \   000022   8882         MOV     DPL,R0
   \   000024   8983         MOV     DPH,R1
   \   000026   A3           INC     DPTR
   \   000027   A3           INC     DPTR
   \   000028   A3           INC     DPTR
   \   000029   A3           INC     DPTR
   \   00002A   F0           MOVX    @DPTR,A
    982            ctrl->entry      = entry;
   \   00002B   8882         MOV     DPL,R0
   \   00002D   8983         MOV     DPH,R1
   \   00002F   EC           MOV     A,R4
   \   000030   F0           MOVX    @DPTR,A
   \   000031   A3           INC     DPTR
   \   000032   ED           MOV     A,R5
   \   000033   F0           MOVX    @DPTR,A
    983            ctrl->state      = ZDSECMGR_CTRL_INIT;
   \   000034   7401         MOV     A,#0x1
   \   000036   8882         MOV     DPL,R0
   \   000038   8983         MOV     DPH,R1
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   F0           MOVX    @DPTR,A
    984            ctrl->cntr       = 0;
   \   000040   E4           CLR     A
   \   000041   8882         MOV     DPL,R0
   \   000043   8983         MOV     DPH,R1
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   A3           INC     DPTR
   \   000048   A3           INC     DPTR
   \   000049   A3           INC     DPTR
   \   00004A   A3           INC     DPTR
   \   00004B   12....       LCALL   ?Subroutine10 & 0xFFFF
    985          
    986            // set device pointer
    987            device->ctrl = ctrl;
   \                     ??CrossCallReturnLabel_126:
   \   00004E   A3           INC     DPTR
   \   00004F   A3           INC     DPTR
   \   000050   12....       LCALL   ??Subroutine100_0 & 0xFFFF
    988          }
   \                     ??CrossCallReturnLabel_168:
   \   000053   02....       LJMP    ??Subroutine93_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_93:
   \   000003   A3           INC     DPTR
   \   000004                REQUIRE ?Subroutine69
   \   000004                ; // Fall through to label ?Subroutine69

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine69:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002   A3           INC     DPTR
   \   000003   A3           INC     DPTR
   \   000004   A3           INC     DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine32:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FE           MOV     R6,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FF           MOV     R7,A
   \   000005                ; Setup parameters for call to function SSP_GetTrueRand
   \   000005                REQUIRE ?Subroutine72
   \   000005                ; // Fall through to label ?Subroutine72

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine72:
   \   000000   8882         MOV     DPL,R0
   \   000002   8983         MOV     DPH,R1
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine61:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function AssocGetWithExt
   \   000001   02....       LJMP    ?Subroutine71 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine110_0:
   \   000000   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_229:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine111_0:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F9           MOV     R1,A
   \   000005   22           RET
    989          
    990          /******************************************************************************
    991           * @fn          ZDSecMgrCtrlAdd
    992           *
    993           * @brief       Add control data.
    994           *
    995           * @param       device - [in] valid device data
    996           * @param       entry  - [in] valid entry data
    997           *
    998           * @return      ZStatus_t
    999           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1000          ZStatus_t ZDSecMgrCtrlAdd( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t*  entry )
   \                     ZDSecMgrCtrlAdd:
   1001          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   EC           MOV     A,R4
   \   00000A   FE           MOV     R6,A
   \   00000B   ED           MOV     A,R5
   \   00000C   FF           MOV     R7,A
   1002            ZStatus_t status;
   1003            uint16    index;
   1004          
   1005          
   1006            // initialize results
   1007            status = ZNwkUnknownDevice;
   \   00000D   79C8         MOV     R1,#-0x38
   1008          
   1009            // verify data is available
   1010            if ( ZDSecMgrCtrlData != NULL )
   \   00000F   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000012   E0           MOVX    A,@DPTR
   \   000013   7002         JNZ     ??ZDSecMgrCtrlAdd_0
   \   000015   A3           INC     DPTR
   \   000016   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlAdd_0:
   \   000017   6050         JZ      ??ZDSecMgrCtrlAdd_1
   1011            {
   1012              // look for an empty slot
   1013              for ( index = 0; index < ZDSECMGR_CTRL_MAX; index++ )
   \   000019   7A00         MOV     R2,#0x0
   \   00001B   7B00         MOV     R3,#0x0
   1014              {
   1015                if ( ZDSecMgrCtrlData[index].state == ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrCtrlAdd_2:
   \   00001D   EA           MOV     A,R2
   \   00001E   FC           MOV     R4,A
   \   00001F   EB           MOV     A,R3
   \   000020   FD           MOV     R5,A
   \   000021   EC           MOV     A,R4
   \   000022   75F007       MOV     B,#0x7
   \   000025   A4           MUL     AB
   \   000026   FC           MOV     R4,A
   \   000027   A8F0         MOV     R0,B
   \   000029   75F007       MOV     B,#0x7
   \   00002C   ED           MOV     A,R5
   \   00002D   A4           MUL     AB
   \   00002E   28           ADD     A,R0
   \   00002F   FD           MOV     R5,A
   \   000030   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000033   E0           MOVX    A,@DPTR
   \   000034   2C           ADD     A,R4
   \   000035   F5..         MOV     ?V0 + 2,A
   \   000037   A3           INC     DPTR
   \   000038   E0           MOVX    A,@DPTR
   \   000039   3D           ADDC    A,R5
   \   00003A   F5..         MOV     ?V0 + 3,A
   \   00003C   85..82       MOV     DPL,?V0 + 2
   \   00003F   F583         MOV     DPH,A
   \   000041   A3           INC     DPTR
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   E0           MOVX    A,@DPTR
   \   000047   701B         JNZ     ??ZDSecMgrCtrlAdd_3
   1016                {
   1017                  // return successful results
   1018                  ZDSecMgrCtrlSet( device, entry, &ZDSecMgrCtrlData[index] );
   \   000049                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000049   78..         MOV     R0,#?V0 + 2
   \   00004B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004E   EE           MOV     A,R6
   \   00004F   FC           MOV     R4,A
   \   000050   EF           MOV     A,R7
   \   000051   FD           MOV     R5,A
   \   000052   AA..         MOV     R2,?V0 + 0
   \   000054   AB..         MOV     R3,?V0 + 1
   \   000056   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   000059   7402         MOV     A,#0x2
   \   00005B   12....       LCALL   ?DEALLOC_XSTACK8
   1019          
   1020                  status = ZSuccess;
   \   00005E   7900         MOV     R1,#0x0
   1021          
   1022                  // break from loop
   1023                  index = ZDSECMGR_CTRL_MAX;
   \   000060   7A03         MOV     R2,#0x3
   \   000062   7B00         MOV     R3,#0x0
   1024                }
   1025              }
   \                     ??ZDSecMgrCtrlAdd_3:
   \   000064   12....       LCALL   ?Subroutine39 & 0xFFFF
   1026            }
   \                     ??CrossCallReturnLabel_56:
   \   000067   40B4         JC      ??ZDSecMgrCtrlAdd_2
   1027          
   1028            return status;
   \                     ??ZDSecMgrCtrlAdd_1:
   \   000069   02....       LJMP    ??Subroutine107_0 & 0xFFFF
   1029          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine107_0:
   \   000000   7F04         MOV     R7,#0x4
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
   1030          
   1031          /******************************************************************************
   1032           * @fn          ZDSecMgrCtrlTerm
   1033           *
   1034           * @brief       Terminate device control.
   1035           *
   1036           * @param       entry - [in] valid entry data
   1037           *
   1038           * @return      none
   1039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1040          void ZDSecMgrCtrlTerm( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlTerm:
   1041          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 2
   \   000004   74FE         MOV     A,#-0x2
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   1042            ZDSecMgrCtrl_t* ctrl;
   1043          
   1044            // remove device from control data
   1045            ZDSecMgrCtrlLookup ( entry, &ctrl );
   \   000009                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   AC82         MOV     R4,DPL
   \   000011   AD83         MOV     R5,DPH
   \   000013   12....       LCALL   ?Subroutine46 & 0xFFFF
   1046          
   1047            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_66:
   \   000016   7002         JNZ     ??ZDSecMgrCtrlTerm_0
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlTerm_0:
   \   00001A   6009         JZ      ??CrossCallReturnLabel_24
   1048            {
   1049              ZDSecMgrCtrlRelease ( ctrl );
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   12....       LCALL   ?Subroutine20 & 0xFFFF
   1050            }
   1051          }
   \                     ??CrossCallReturnLabel_24:
   \   000025   7402         MOV     A,#0x2
   \   000027   80..         SJMP    ??Subroutine87_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine87_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   02....       LJMP    ??Subroutine97_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine46:
   \   000000   12....       LCALL   ??ZDSecMgrCtrlLookup?relay
   \   000003   85..82       MOV     DPL,?XSP + 0
   \   000006   85..83       MOV     DPH,?XSP + 1
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   22           RET
   1052          
   1053          /******************************************************************************
   1054           * @fn          ZDSecMgrCtrlReset
   1055           *
   1056           * @brief       Reset control data.
   1057           *
   1058           * @param       device - [in] valid device data
   1059           * @param       entry  - [in] valid entry data
   1060           *
   1061           * @return      ZStatus_t
   1062           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1063          ZStatus_t ZDSecMgrCtrlReset( ZDSecMgrDevice_t* device, ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrCtrlReset:
   1064          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1065            ZStatus_t       status;
   1066            ZDSecMgrCtrl_t* ctrl;
   1067          
   1068          
   1069            // initialize results
   1070            status = ZNwkUnknownDevice;
   1071          
   1072            // look for a match for the entry
   1073            ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000012                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000012   85..82       MOV     DPL,?XSP + 0
   \   000015   85..83       MOV     DPH,?XSP + 1
   \   000018   AC82         MOV     R4,DPL
   \   00001A   AD83         MOV     R5,DPH
   \   00001C   EE           MOV     A,R6
   \   00001D   FA           MOV     R2,A
   \   00001E   EF           MOV     A,R7
   \   00001F   FB           MOV     R3,A
   \   000020   12....       LCALL   ?Subroutine46 & 0xFFFF
   1074          
   1075            if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_67:
   \   000023   7002         JNZ     ??ZDSecMgrCtrlReset_0
   \   000025   A3           INC     DPTR
   \   000026   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrCtrlReset_0:
   \   000027   601D         JZ      ??ZDSecMgrCtrlReset_1
   1076            {
   1077              ZDSecMgrCtrlSet( device, entry, ctrl );
   \   000029                ; Setup parameters for call to function ZDSecMgrCtrlSet
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   12....       LCALL   ?PUSH_XSTACK8_X_TWO
   \   000032   EE           MOV     A,R6
   \   000033   FC           MOV     R4,A
   \   000034   EF           MOV     A,R7
   \   000035   FD           MOV     R5,A
   \   000036   AA..         MOV     R2,?V0 + 0
   \   000038   AB..         MOV     R3,?V0 + 1
   \   00003A   12....       LCALL   ??ZDSecMgrCtrlSet?relay
   \   00003D   7402         MOV     A,#0x2
   \   00003F   12....       LCALL   ?DEALLOC_XSTACK8
   1078          
   1079              status = ZSuccess;
   \   000042   7900         MOV     R1,#0x0
   \   000044   800B         SJMP    ??ZDSecMgrCtrlReset_2
   1080            }
   1081            else
   1082            {
   1083              status = ZDSecMgrCtrlAdd( device, entry );
   \                     ??ZDSecMgrCtrlReset_1:
   \   000046                ; Setup parameters for call to function ZDSecMgrCtrlAdd
   \   000046   EE           MOV     A,R6
   \   000047   FC           MOV     R4,A
   \   000048   EF           MOV     A,R7
   \   000049   FD           MOV     R5,A
   \   00004A   AA..         MOV     R2,?V0 + 0
   \   00004C   AB..         MOV     R3,?V0 + 1
   \   00004E   12....       LCALL   ??ZDSecMgrCtrlAdd?relay
   1084            }
   1085          
   1086            return status;
   \                     ??ZDSecMgrCtrlReset_2:
   \   000051   02....       LJMP    ??Subroutine102_0 & 0xFFFF
   1087          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine102_0:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine103_0
   \   000002                ; // Fall through to label ??Subroutine103_0
   1088          
   1089          /******************************************************************************
   1090           * @fn          ZDSecMgrMasterKeyLoad
   1091           *
   1092           * @brief       Load the MASTER key for device with specified EXT
   1093           *              address.
   1094           *
   1095           * @param       extAddr - [in] EXT address of device
   1096           * @param       key     - [in] MASTER key shared with device
   1097           *
   1098           * @return      ZStatus_t
   1099           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1100          ZStatus_t ZDSecMgrMasterKeyLoad( uint8* extAddr, uint8* key )
   \                     ZDSecMgrMasterKeyLoad:
   1101          {
   \   000000   74F1         MOV     A,#-0xf
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 15
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1102            ZStatus_t status;
   1103            uint8*    loaded;
   1104            uint16    ami;
   1105          
   1106          
   1107            // set status based on policy
   1108            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   1109          
   1110            if ( status == ZSuccess )
   \   00001E   7036         JNZ     ??ZDSecMgrMasterKeyLoad_0
   1111            {
   1112              // get the address index
   1113              if ( ZDSecMgrMasterKeyLookup( ami, &loaded ) == ZSuccess )
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   7402         MOV     A,#0x2
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000028   7022         JNZ     ??ZDSecMgrMasterKeyLoad_1
   1114              {
   1115                // overwrite old key
   1116                osal_memcpy( loaded, key, SEC_KEY_LEN );
   \   00002A                ; Setup parameters for call to function osal_memcpy
   \   00002A   8E..         MOV     ?V0 + 4,R6
   \   00002C   8F..         MOV     ?V0 + 5,R7
   \   00002E   75..00       MOV     ?V0 + 6,#0x0
   \   000031   78..         MOV     R0,#?V0 + 4
   \   000033   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   000036   7C10         MOV     R4,#0x10
   \   000038   7D00         MOV     R5,#0x0
   \   00003A   7405         MOV     A,#0x5
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   1117              }
   \                     ??CrossCallReturnLabel_132:
   \   000042   12....       LCALL   ??osal_memcpy?relay
   \   000045   7403         MOV     A,#0x3
   \   000047   12....       LCALL   ?DEALLOC_XSTACK8
   \   00004A   800A         SJMP    ??ZDSecMgrMasterKeyLoad_0
   1118              else
   1119              {
   1120                // store new key -- NULL will zero key
   1121                status = ZDSecMgrMasterKeyStore( ami, key );
   \                     ??ZDSecMgrMasterKeyLoad_1:
   \   00004C                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   00004C   EE           MOV     A,R6
   \   00004D   FC           MOV     R4,A
   \   00004E   EF           MOV     A,R7
   \   00004F   FD           MOV     R5,A
   \   000050   12....       LCALL   ?Subroutine33 & 0xFFFF
   1122              }
   1123            }
   \                     ??CrossCallReturnLabel_42:
   \   000053   E9           MOV     A,R1
   \   000054   F5..         MOV     ?V0 + 0,A
   1124          
   1125            return status;
   \                     ??ZDSecMgrMasterKeyLoad_0:
   \   000056   A9..         MOV     R1,?V0 + 0
   \   000058   7404         MOV     A,#0x4
   \   00005A   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005D   7F07         MOV     R7,#0x7
   \   00005F   02....       LJMP    ?BANKED_LEAVE_XDATA
   1126          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine94_0:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_146:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine19:
   \   000000   AC82         MOV     R4,DPL
   \   000002   AD83         MOV     R5,DPH
   \   000004   85..82       MOV     DPL,?XSP + 0
   \   000007   85..83       MOV     DPH,?XSP + 1
   \   00000A   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_78:
   \   00000D   E9           MOV     A,R1
   \   00000E   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine33:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_144:
   \   000009   12....       LCALL   ??ZDSecMgrMasterKeyStore?relay
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine54:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FA           MOV     R2,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FB           MOV     R3,A
   \   000005   12....       LCALL   ??ZDSecMgrMasterKeyLookup?relay
   \   000008   22           RET
   1127          
   1128          /******************************************************************************
   1129           * @fn          ZDSecMgrAppKeyGet
   1130           *
   1131           * @brief       get an APP key - option APP(MASTER or LINK) key
   1132           *
   1133           * @param       initNwkAddr - [in] NWK address of initiator device
   1134           * @param       initExtAddr - [in] EXT address of initiator device
   1135           * @param       partNwkAddr - [in] NWK address of partner device
   1136           * @param       partExtAddr - [in] EXT address of partner device
   1137           * @param       key         - [out] APP(MASTER or LINK) key
   1138           * @param       keyType     - [out] APP(MASTER or LINK) key type
   1139           *
   1140           * @return      ZStatus_t
   1141           */

   \                                 In  segment XDATA_I, align 1, keep-with-next
   1142          uint8 ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;    // Set the default key type
   \                     ZDSecMgrAppKeyType:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for ZDSecMgrAppKeyType>`
   \   000001                REQUIRE __INIT_XDATA_I
   1143                                                           // to KEY_TYPE_APP_LINK since
   1144                                                           // only specific requirement
   1145                                                           // right now comes from SE profile
   1146          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1147          ZStatus_t ZDSecMgrAppKeyGet( uint16  initNwkAddr,
   \                     ZDSecMgrAppKeyGet:
   1148                                       uint8*  initExtAddr,
   1149                                       uint16  partNwkAddr,
   1150                                       uint8*  partExtAddr,
   1151                                       uint8** key,
   1152                                       uint8*  keyType )
   1153          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   740D         MOV     A,#0xd
   \   000007   12....       LCALL   ?XSTACK_DISP0_8
   \   00000A   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_211:
   \   00000D   740F         MOV     A,#0xf
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   12....       LCALL   ?Subroutine32 & 0xFFFF
   1154            // Intentionally unreferenced parameters
   1155            (void)initNwkAddr;
   1156            (void)initExtAddr;
   1157            (void)partNwkAddr;
   1158            (void)partExtAddr;
   1159            
   1160            //---------------------------------------------------------------------------
   1161            // note:
   1162            // should use a robust mechanism to generate keys, for example
   1163            // combine EXT addresses and call a hash function
   1164            //---------------------------------------------------------------------------
   1165            SSP_GetTrueRand( SEC_KEY_LEN, *key );
   \                     ??CrossCallReturnLabel_99:
   \   000015   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_133:
   \   000018   7910         MOV     R1,#0x10
   \   00001A   12....       LCALL   ??SSP_GetTrueRand?relay
   1166          
   1167            *keyType = ZDSecMgrAppKeyType;
   \   00001D   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000020   E0           MOVX    A,@DPTR
   \   000021   8E82         MOV     DPL,R6
   \   000023   8F83         MOV     DPH,R7
   \   000025   F0           MOVX    @DPTR,A
   1168          
   1169            return ZSuccess;
   \   000026   7900         MOV     R1,#0x0
   \   000028   02....       LJMP    ??Subroutine93_0 & 0xFFFF
   1170          }
   1171          
   1172          /******************************************************************************
   1173           * @fn          ZDSecMgrAppKeyReq
   1174           *
   1175           * @brief       Process request for APP key between two devices.
   1176           *
   1177           * @param       device - [in] ZDO_RequestKeyInd_t, request info
   1178           *
   1179           * @return      none
   1180           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1181          void ZDSecMgrAppKeyReq( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrAppKeyReq:
   1182          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 39
   \   000005   74D9         MOV     A,#-0x27
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1183            APSME_TransportKeyReq_t req;
   1184            uint8                   initExtAddr[Z_EXTADDR_LEN];
   1185            uint16                  partNwkAddr;
   1186            uint8                   key[SEC_KEY_LEN];
   1187          
   1188          
   1189            // validate initiator and partner
   1190            if ( ( APSME_LookupNwkAddr( ind->partExtAddr, &partNwkAddr ) == TRUE ) &&
   1191                 ( APSME_LookupExtAddr( ind->srcAddr, initExtAddr ) == TRUE      )   )
   \   00000E   EE           MOV     A,R6
   \   00000F   2405         ADD     A,#0x5
   \   000011   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_87:
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   AA..         MOV     R2,?V0 + 0
   \   00001A   FB           MOV     R3,A
   \   00001B   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001E   E9           MOV     A,R1
   \   00001F   6401         XRL     A,#0x1
   \   000021   6003         JZ      $+5
   \   000023   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   \   000026   EE           MOV     A,R6
   \   000027   2402         ADD     A,#0x2
   \   000029   0E           INC     R6
   \   00002A   0E           INC     R6
   \   00002B   EF           MOV     A,R7
   \   00002C   3400         ADDC    A,#0x0
   \   00002E   FF           MOV     R7,A
   \   00002F                ; Setup parameters for call to function APSME_LookupExtAddr
   \   00002F   740F         MOV     A,#0xf
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   AC82         MOV     R4,DPL
   \   000036   AD83         MOV     R5,DPH
   \   000038   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_140:
   \   00003B   12....       LCALL   ??APSME_LookupExtAddr?relay
   \   00003E   E9           MOV     A,R1
   \   00003F   6401         XRL     A,#0x1
   \   000041   6003         JZ      $+5
   \   000043   02....       LJMP    ??ZDSecMgrAppKeyReq_0 & 0xFFFF
   1192            {
   1193              // point the key to some memory
   1194              req.key = key;
   \   000046   7417         MOV     A,#0x17
   \   000048   12....       LCALL   ?XSTACK_DISP0_8
   \   00004B   A882         MOV     R0,DPL
   \   00004D   A983         MOV     R1,DPH
   \   00004F   7406         MOV     A,#0x6
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   1195          
   1196              // get an APP key - option APP (MASTER or LINK) key
   1197              if ( ZDSecMgrAppKeyGet( ind->srcAddr,
   1198                                      initExtAddr,
   1199                                      partNwkAddr,
   1200                                      ind->partExtAddr,
   1201                                      &req.key,
   1202                                      &req.keyType ) == ZSuccess )
   \                     ??CrossCallReturnLabel_169:
   \   000057                ; Setup parameters for call to function SSP_GetTrueRand
   \   000057   7417         MOV     A,#0x17
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   AA82         MOV     R2,DPL
   \   00005E   AB83         MOV     R3,DPH
   \   000060   7910         MOV     R1,#0x10
   \   000062   12....       LCALL   ??SSP_GetTrueRand?relay
   \   000065   90....       MOV     DPTR,#ZDSecMgrAppKeyType
   \   000068   E0           MOVX    A,@DPTR
   \   000069   C0E0         PUSH    A
   \   00006B   7404         MOV     A,#0x4
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   D0E0         POP     A
   \   000072   F0           MOVX    @DPTR,A
   1203              {
   1204                // always secure
   1205                req.nwkSecure = TRUE;
   \   000073   740C         MOV     A,#0xc
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   7401         MOV     A,#0x1
   \   00007A   F0           MOVX    @DPTR,A
   1206                req.apsSecure = TRUE;
   \   00007B   740B         MOV     A,#0xb
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   7401         MOV     A,#0x1
   \   000082   F0           MOVX    @DPTR,A
   1207                req.tunnel    = NULL;
   \   000083   740D         MOV     A,#0xd
   \   000085   12....       LCALL   ?XSTACK_DISP0_8
   \   000088   E4           CLR     A
   \   000089   F0           MOVX    @DPTR,A
   \   00008A   A3           INC     DPTR
   \   00008B   12....       LCALL   ?Subroutine17 & 0xFFFF
   1208          
   1209                // send key to initiator device
   1210                req.dstAddr   = ind->srcAddr;
   \                     ??CrossCallReturnLabel_89:
   \   00008E   F9           MOV     R1,A
   \   00008F   7402         MOV     A,#0x2
   \   000091   12....       LCALL   ?XSTACK_DISP0_8
   \   000094   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   1211                req.extAddr   = ind->partExtAddr;
   \                     ??CrossCallReturnLabel_170:
   \   000097   7408         MOV     A,#0x8
   \   000099   12....       LCALL   ?XSTACK_DISP0_8
   \   00009C   E5..         MOV     A,?V0 + 0
   \   00009E   F0           MOVX    @DPTR,A
   \   00009F   A3           INC     DPTR
   \   0000A0   E5..         MOV     A,?V0 + 1
   \   0000A2   F0           MOVX    @DPTR,A
   1212                req.initiator = TRUE;
   \   0000A3   740A         MOV     A,#0xa
   \   0000A5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A8   7401         MOV     A,#0x1
   \   0000AA   F0           MOVX    @DPTR,A
   1213                APSME_TransportKeyReq( &req );
   \   0000AB                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000AB   7402         MOV     A,#0x2
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   AA82         MOV     R2,DPL
   \   0000B2   AB83         MOV     R3,DPH
   \   0000B4   12....       LCALL   ??APSME_TransportKeyReq?relay
   1214          
   1215                // send key to partner device
   1216                req.dstAddr   = partNwkAddr;
   \   0000B7   85..82       MOV     DPL,?XSP + 0
   \   0000BA   85..83       MOV     DPH,?XSP + 1
   \   0000BD   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_35:
   \   0000C0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C3   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   1217                req.extAddr   = initExtAddr;
   \                     ??CrossCallReturnLabel_171:
   \   0000C6   740F         MOV     A,#0xf
   \   0000C8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000CB   A882         MOV     R0,DPL
   \   0000CD   A983         MOV     R1,DPH
   \   0000CF   7408         MOV     A,#0x8
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   1218                req.initiator = FALSE;
   \                     ??CrossCallReturnLabel_198:
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   E4           CLR     A
   \   0000DB   F0           MOVX    @DPTR,A
   1219          
   1220                APSME_TransportKeyReq( &req );
   \   0000DC                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000DC   7402         MOV     A,#0x2
   \   0000DE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E1   AA82         MOV     R2,DPL
   \   0000E3   AB83         MOV     R3,DPH
   \   0000E5   12....       LCALL   ??APSME_TransportKeyReq?relay
   1221              }
   1222            }
   1223          }
   \                     ??ZDSecMgrAppKeyReq_0:
   \   0000E8   7427         MOV     A,#0x27
   \   0000EA   02....       LJMP    ??Subroutine103_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine27:
   \   000000   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_225:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine17:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005                REQUIRE ?Subroutine70
   \   000005                ; // Fall through to label ?Subroutine70

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine70:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine68:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine36:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine94_0
   \   000004                ; // Fall through to label ??Subroutine94_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine42:
   \   000000   F5..         MOV     ?V0 + 0,A
   \   000002   EF           MOV     A,R7
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   000007                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000007   02....       LJMP    ?Subroutine68 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine105_0:
   \   000000   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_207:
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003                ; Setup parameters for call to function AddrMgrEntryGet
   \   000003   740A         MOV     A,#0xa
   \   000005   22           RET
   1224          
   1225          /******************************************************************************
   1226           * @fn          ZDSecMgrEstablishKey
   1227           *
   1228           * @brief       Start SKKE with device joining network.
   1229           *
   1230           * @param       device - [in] ZDSecMgrDevice_t, device info
   1231           *
   1232           * @return      ZStatus_t
   1233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1234          ZStatus_t ZDSecMgrEstablishKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrEstablishKey:
   1235          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1236            ZStatus_t               status;
   1237            APSME_EstablishKeyReq_t req;
   1238          
   1239          
   1240            req.respExtAddr = device->extAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   A3           INC     DPTR
   \   000013   A3           INC     DPTR
   \   000014   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_36:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   1241            req.method      = APSME_SKKE_METHOD;
   \                     ??CrossCallReturnLabel_172:
   \   00001D   7404         MOV     A,#0x4
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
   1242          
   1243            if ( device->parentAddr == NLME_GetShortAddr() )
   \   000024                ; Setup parameters for call to function NLME_GetShortAddr
   \   000024   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_208:
   \   000027   EA           MOV     A,R2
   \   000028   68           XRL     A,R0
   \   000029   7002         JNZ     ??ZDSecMgrEstablishKey_0
   \   00002B   EB           MOV     A,R3
   \   00002C   69           XRL     A,R1
   \                     ??ZDSecMgrEstablishKey_0:
   \   00002D   7017         JNZ     ??ZDSecMgrEstablishKey_1
   1244            {
   1245              req.dstAddr   = device->nwkAddr;
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_212:
   \   000036   12....       LCALL   ?Subroutine14 & 0xFFFF
   1246              //devtag.0604.todo - remove obsolete
   1247              req.apsSecure = FALSE;
   \                     ??CrossCallReturnLabel_117:
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E4           CLR     A
   \   00003D   F0           MOVX    @DPTR,A
   1248              req.nwkSecure = FALSE;
   \   00003E   7406         MOV     A,#0x6
   \   000040   12....       LCALL   ?XSTACK_DISP0_8
   \   000043   E4           CLR     A
   \   000044   8010         SJMP    ??ZDSecMgrEstablishKey_2
   1249            }
   1250            else
   1251            {
   1252              req.dstAddr   = device->parentAddr;
   \                     ??ZDSecMgrEstablishKey_1:
   \   000046   12....       LCALL   ?Subroutine14 & 0xFFFF
   1253              //devtag.0604.todo - remove obsolete
   1254              req.apsSecure = TRUE;
   \                     ??CrossCallReturnLabel_118:
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   7401         MOV     A,#0x1
   \   00004E   F0           MOVX    @DPTR,A
   1255              req.nwkSecure = TRUE;
   \   00004F   7406         MOV     A,#0x6
   \   000051   12....       LCALL   ?XSTACK_DISP0_8
   \   000054   7401         MOV     A,#0x1
   1256            }
   \                     ??ZDSecMgrEstablishKey_2:
   \   000056   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   1257          
   1258            status = APSME_EstablishKeyReq( &req );
   1259          
   1260            return status;
   \                     ??CrossCallReturnLabel_154:
   \   000059   12....       LCALL   ??APSME_EstablishKeyReq?relay
   \   00005C   7407         MOV     A,#0x7
   \   00005E   02....       LJMP    ??Subroutine103_0 & 0xFFFF
   1261          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine14:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine88_0
   \   000006                ; // Fall through to label ??Subroutine88_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine88_0:
   \   000000   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_204:
   \   000003                ; Setup parameters for call to function APSME_RemoveDeviceReq
   \   000003   7405         MOV     A,#0x5
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine29:
   \   000000   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000003   8E82         MOV     DPL,R6
   \   000005   8F83         MOV     DPH,R7
   \   000007                REQUIRE ??Subroutine108_0
   \   000007                ; // Fall through to label ??Subroutine108_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine108_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine109_0
   \   000002                ; // Fall through to label ??Subroutine109_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine109_0:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine110_0
   \   000002                ; // Fall through to label ??Subroutine110_0
   1262          
   1263          /******************************************************************************
   1264           * @fn          ZDSecMgrSendMasterKey
   1265           *
   1266           * @brief       Send MASTER key to device joining network.
   1267           *
   1268           * @param       device - [in] ZDSecMgrDevice_t, device info
   1269           *
   1270           * @return      ZStatus_t
   1271           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1272          ZStatus_t ZDSecMgrSendMasterKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendMasterKey:
   1273          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1274            ZStatus_t               status;
   1275            APSME_TransportKeyReq_t req;
   1276          
   1277          
   1278            req.keyType = KEY_TYPE_TC_MASTER;
   \   00000E   7402         MOV     A,#0x2
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E4           CLR     A
   \   000014   12....       LCALL   ?Subroutine8 & 0xFFFF
   1279            req.extAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_7:
   \   000017   12....       LCALL   ?XSTACK_DISP0_8
   \   00001A   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   1280            req.tunnel  = NULL;
   \                     ??CrossCallReturnLabel_173:
   \   00001D   740B         MOV     A,#0xb
   \   00001F   12....       LCALL   ?XSTACK_DISP0_8
   \   000022   E4           CLR     A
   \   000023   F0           MOVX    @DPTR,A
   \   000024   A3           INC     DPTR
   \   000025   F0           MOVX    @DPTR,A
   1281          
   1282            ZDSecMgrMasterKeyLookup( device->ctrl->entry->ami, &req.key );
   \   000026                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000026   7404         MOV     A,#0x4
   \   000028   12....       LCALL   ?XSTACK_DISP0_8
   \   00002B   AC82         MOV     R4,DPL
   \   00002D   AD83         MOV     R5,DPH
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   A3           INC     DPTR
   \   000034   A3           INC     DPTR
   \   000035   A3           INC     DPTR
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_91:
   \   00003E   F583         MOV     DPH,A
   \   000040   8882         MOV     DPL,R0
   \   000042   12....       LCALL   ?Subroutine34 & 0xFFFF
   1283          
   1284            //check if using secure hop to to parent
   1285            if ( device->parentAddr != NLME_GetShortAddr() )
   \                     ??CrossCallReturnLabel_44:
   \   000045                ; Setup parameters for call to function NLME_GetShortAddr
   \   000045   12....       LCALL   ?Subroutine29 & 0xFFFF
   \                     ??CrossCallReturnLabel_209:
   \   000048   EA           MOV     A,R2
   \   000049   68           XRL     A,R0
   \   00004A   7002         JNZ     ??ZDSecMgrSendMasterKey_0
   \   00004C   EB           MOV     A,R3
   \   00004D   69           XRL     A,R1
   \                     ??ZDSecMgrSendMasterKey_0:
   \   00004E   6012         JZ      ??ZDSecMgrSendMasterKey_1
   1286            {
   1287              //send to parent with security
   1288              req.dstAddr   = device->parentAddr;
   \   000050   12....       LCALL   ?Subroutine4 & 0xFFFF
   1289              req.nwkSecure = TRUE;
   \                     ??CrossCallReturnLabel_196:
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   7401         MOV     A,#0x1
   \   000058   F0           MOVX    @DPTR,A
   1290              req.apsSecure = TRUE;
   \   000059   7409         MOV     A,#0x9
   \   00005B   12....       LCALL   ?XSTACK_DISP0_8
   \   00005E   7401         MOV     A,#0x1
   \   000060   8015         SJMP    ??ZDSecMgrSendMasterKey_2
   1291            }
   1292            else
   1293            {
   1294              //direct with no security
   1295              req.dstAddr   = device->nwkAddr;
   \                     ??ZDSecMgrSendMasterKey_1:
   \   000062   8E82         MOV     DPL,R6
   \   000064   8F83         MOV     DPH,R7
   \   000066   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_213:
   \   000069   12....       LCALL   ?Subroutine4 & 0xFFFF
   1296              req.nwkSecure = FALSE;
   \                     ??CrossCallReturnLabel_197:
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   E4           CLR     A
   \   000070   F0           MOVX    @DPTR,A
   1297              req.apsSecure = FALSE;
   \   000071   7409         MOV     A,#0x9
   \   000073   12....       LCALL   ?XSTACK_DISP0_8
   \   000076   E4           CLR     A
   1298            }
   \                     ??ZDSecMgrSendMasterKey_2:
   \   000077   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   1299          
   1300            status = APSME_TransportKeyReq( &req );
   1301          
   1302            return status;
   \                     ??CrossCallReturnLabel_155:
   \   00007A   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   00007D   02....       LJMP    ?Subroutine81 & 0xFFFF
   1303          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8E82         MOV     DPL,R6
   \   000003   8F83         MOV     DPH,R7
   \   000005   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_228:
   \   000008   7406         MOV     A,#0x6
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine25:
   \   000000   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_80:
   \   000003   02....       LJMP    ?Subroutine70 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine105_0
   \   000006                ; // Fall through to label ??Subroutine105_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine49:
   \   000000   A3           INC     DPTR
   \   000001   A3           INC     DPTR
   \   000002                REQUIRE ??Subroutine111_0
   \   000002                ; // Fall through to label ??Subroutine111_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine34:
   \   000000   12....       LCALL   ?Subroutine54 & 0xFFFF
   \                     ??CrossCallReturnLabel_79:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine56:
   \   000000   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_123:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine64:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
   1304          
   1305          /******************************************************************************
   1306           * @fn          ZDSecMgrSendNwkKey
   1307           *
   1308           * @brief       Send NWK key to device joining network.
   1309           *
   1310           * @param       device - [in] ZDSecMgrDevice_t, device info
   1311           *
   1312           * @return      ZStatus_t
   1313           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1314          ZStatus_t ZDSecMgrSendNwkKey( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrSendNwkKey:
   1315          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1316            ZStatus_t               status;
   1317            APSME_TransportKeyReq_t req;
   1318            APSDE_FrameTunnel_t     tunnel;
   1319          
   1320            req.dstAddr   = device->nwkAddr;
   \   00000E   8E82         MOV     DPL,R6
   \   000010   8F83         MOV     DPH,R7
   \   000012   12....       LCALL   ?Subroutine28 & 0xFFFF
   \                     ??CrossCallReturnLabel_85:
   \   000015   E8           MOV     A,R0
   \   000016   F0           MOVX    @DPTR,A
   \   000017   A3           INC     DPTR
   \   000018   E9           MOV     A,R1
   \   000019   12....       LCALL   ?Subroutine8 & 0xFFFF
   1321            req.extAddr   = device->extAddr;
   \                     ??CrossCallReturnLabel_8:
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   12....       LCALL   ??Subroutine90_0 & 0xFFFF
   1322          
   1323            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1324              req.keyType   = KEY_TYPE_NWK_HIGH;
   1325            else
   1326              req.keyType   = KEY_TYPE_NWK;
   \                     ??CrossCallReturnLabel_131:
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   7401         MOV     A,#0x1
   \   000027   F0           MOVX    @DPTR,A
   1327          
   1328            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   1329                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   1330            {
   1331              // set values
   1332              req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   1333              req.key       = _NIB.nwkActiveKey.key;
   1334              //devtag.pro.security.todo - make sure that if there is no link key the NWK
   1335              //key isn't used to secure the frame at the APS layer -- since the receiving
   1336              //device may not have a NWK key yet
   1337              req.apsSecure = TRUE;
   1338          
   1339              // check if using secure hop to to parent
   1340              if ( device->parentAddr == NLME_GetShortAddr() )
   1341              {
   1342                req.nwkSecure = FALSE;
   1343                req.tunnel    = NULL;
   1344              }
   1345              else
   1346              {
   1347                req.nwkSecure   = TRUE;
   1348                req.tunnel      = &tunnel;
   1349                req.tunnel->tna = device->parentAddr;
   1350                req.tunnel->dea = device->extAddr;
   1351              }
   1352            }
   1353            else
   1354            {
   1355              // default values
   1356              //devtag.0604.verify
   1357              req.nwkSecure = TRUE;
   \   000028   740A         MOV     A,#0xa
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   7401         MOV     A,#0x1
   \   00002F   F0           MOVX    @DPTR,A
   1358              req.apsSecure = FALSE;
   \   000030   7409         MOV     A,#0x9
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   E4           CLR     A
   \   000036   F0           MOVX    @DPTR,A
   1359              req.tunnel    = NULL;
   \   000037   740B         MOV     A,#0xb
   \   000039   12....       LCALL   ?XSTACK_DISP0_8
   \   00003C   E4           CLR     A
   \   00003D   F0           MOVX    @DPTR,A
   \   00003E   A3           INC     DPTR
   \   00003F   F0           MOVX    @DPTR,A
   1360          
   1361              if ( device->parentAddr != NLME_GetShortAddr() )
   \   000040                ; Setup parameters for call to function NLME_GetShortAddr
   \   000040   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000043   8A..         MOV     ?V0 + 0,R2
   \   000045   8B..         MOV     ?V0 + 1,R3
   \   000047   A8..         MOV     R0,?V0 + 0
   \   000049   A9..         MOV     R1,?V0 + 1
   \   00004B   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_69:
   \   00004E   85..82       MOV     DPL,?V0 + 0
   \   000051   F583         MOV     DPH,A
   \   000053   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_134:
   \   000056   E8           MOV     A,R0
   \   000057   6A           XRL     A,R2
   \   000058   7002         JNZ     ??ZDSecMgrSendNwkKey_0
   \   00005A   E9           MOV     A,R1
   \   00005B   6B           XRL     A,R3
   \                     ??ZDSecMgrSendNwkKey_0:
   \   00005C   6003         JZ      ??CrossCallReturnLabel_194
   1362              {
   1363                req.dstAddr = device->parentAddr;
   \   00005E   12....       LCALL   ?Subroutine7 & 0xFFFF
   1364              }
   1365          
   1366              // special cases
   1367              //devtag.0604.todo - modify to preconfig flag
   1368              if ( device->secure == FALSE )
   \                     ??CrossCallReturnLabel_194:
   \   000061   8E82         MOV     DPL,R6
   \   000063   8F83         MOV     DPH,R7
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   A3           INC     DPTR
   \   00006B   E0           MOVX    A,@DPTR
   \   00006C   7038         JNZ     ??ZDSecMgrSendNwkKey_1
   1369              {
   1370                req.keySeqNum = _NIB.nwkActiveKey.keySeqNum;
   \   00006E   90....       MOV     DPTR,#(_NIB + 62)
   \   000071   E0           MOVX    A,@DPTR
   \   000072   C0E0         PUSH    A
   \   000074   7403         MOV     A,#0x3
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   D0E0         POP     A
   \   00007B   F0           MOVX    @DPTR,A
   1371                req.key       = _NIB.nwkActiveKey.key;
   \   00007C   7404         MOV     A,#0x4
   \   00007E   12....       LCALL   ?XSTACK_DISP0_8
   \   000081   74..         MOV     A,#((_NIB + 63) & 0xff)
   \   000083   F0           MOVX    @DPTR,A
   \   000084   A3           INC     DPTR
   \   000085   74..         MOV     A,#(((_NIB + 63) >> 8) & 0xff)
   \   000087   F0           MOVX    @DPTR,A
   1372          
   1373                // check if using secure hop to to parent
   1374                if ( device->parentAddr == NLME_GetShortAddr() )
   \   000088                ; Setup parameters for call to function NLME_GetShortAddr
   \   000088   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00008B   8A..         MOV     ?V0 + 2,R2
   \   00008D   8B..         MOV     ?V0 + 3,R3
   \   00008F   A8..         MOV     R0,?V0 + 2
   \   000091   A9..         MOV     R1,?V0 + 3
   \   000093   85..82       MOV     DPL,?V0 + 0
   \   000096   85..83       MOV     DPH,?V0 + 1
   \   000099   E0           MOVX    A,@DPTR
   \   00009A   68           XRL     A,R0
   \   00009B   7003         JNZ     ??ZDSecMgrSendNwkKey_2
   \   00009D   A3           INC     DPTR
   \   00009E   E0           MOVX    A,@DPTR
   \   00009F   69           XRL     A,R1
   \                     ??ZDSecMgrSendNwkKey_2:
   \   0000A0   7014         JNZ     ??ZDSecMgrSendNwkKey_3
   1375                {
   1376                  req.nwkSecure = FALSE;
   \   0000A2   740A         MOV     A,#0xa
   \   0000A4   800B         SJMP    ??ZDSecMgrSendNwkKey_4
   1377                }
   1378              }
   1379              else
   1380              {
   1381                req.key       = NULL;
   \                     ??ZDSecMgrSendNwkKey_1:
   \   0000A6   7404         MOV     A,#0x4
   \   0000A8   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AB   E4           CLR     A
   \   0000AC   F0           MOVX    @DPTR,A
   \   0000AD   A3           INC     DPTR
   \   0000AE   F0           MOVX    @DPTR,A
   1382                req.keySeqNum = 0;
   \   0000AF   7403         MOV     A,#0x3
   \                     ??ZDSecMgrSendNwkKey_4:
   \   0000B1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B4   E4           CLR     A
   \   0000B5   F0           MOVX    @DPTR,A
   1383              }
   1384            }
   1385          
   1386            status = APSME_TransportKeyReq( &req );
   1387          
   1388            return status;
   \                     ??ZDSecMgrSendNwkKey_3:
   \   0000B6                ; Setup parameters for call to function APSME_TransportKeyReq
   \   0000B6   85..82       MOV     DPL,?XSP + 0
   \   0000B9   85..83       MOV     DPH,?XSP + 1
   \   0000BC   AA82         MOV     R2,DPL
   \   0000BE   AB83         MOV     R3,DPH
   \   0000C0   12....       LCALL   ??APSME_TransportKeyReq?relay
   \   0000C3   740D         MOV     A,#0xd
   \   0000C5   02....       LJMP    ??Subroutine106_0 & 0xFFFF
   1389          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine90_0:
   \   000000   12....       LCALL   ?Subroutine65 & 0xFFFF
   \                     ??CrossCallReturnLabel_205:
   \   000003   7402         MOV     A,#0x2
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine101_0
   \   000006                ; // Fall through to label ??Subroutine101_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine106_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine107_0
   \   000003                ; // Fall through to label ??Subroutine107_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine47:
   \   000000   EE           MOV     A,R6
   \   000001   2404         ADD     A,#0x4
   \   000003   F5..         MOV     ?V0 + 0,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 1,A
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine28:
   \   000000   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_226:
   \   000003   02....       LJMP    ?Subroutine68 & 0xFFFF
   1390          
   1391          /******************************************************************************
   1392           * @fn          ZDSecMgrDeviceEntryRemove
   1393           *
   1394           * @brief       Remove device entry.
   1395           *
   1396           * @param       entry - [in] valid entry
   1397           *
   1398           * @return      none
   1399           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1400          void ZDSecMgrDeviceEntryRemove( ZDSecMgrEntry_t* entry )
   \                     ZDSecMgrDeviceEntryRemove:
   \   000000   02....       LJMP    ?Subroutine66 & 0xFFFF
   1401          {
   1402            // terminate device control
   1403            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1404            {
   1405              ZDSecMgrCtrlTerm( entry );
   1406            }
   1407          
   1408            // remove device from entry data
   1409            ZDSecMgrEntryFree( entry );
   1410          
   1411            // remove EXT address
   1412            //ZDSecMgrExtAddrRelease( aiOld );
   1413          }
   1414          
   1415          /******************************************************************************
   1416           * @fn          ZDSecMgrDeviceEntryAdd
   1417           *
   1418           * @brief       Add entry.
   1419           *
   1420           * @param       device - [in] ZDSecMgrDevice_t, device info
   1421           * @param       ami    - [in] Address Manager index
   1422           *
   1423           * @return      ZStatus_t
   1424           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1425          void ZDSecMgrAddrMgrUpdate( uint16 ami, uint16 nwkAddr )
   \                     ZDSecMgrAddrMgrUpdate:
   1426          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   1427            AddrMgrEntry_t entry;
   1428          
   1429            // get the ami data
   1430            entry.user  = ADDRMGR_USER_SECURITY;
   \   00000E   7402         MOV     A,#0x2
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   F0           MOVX    @DPTR,A
   1431            entry.index = ami;
   \   000017   740B         MOV     A,#0xb
   \   000019   12....       LCALL   ?XSTACK_DISP0_8
   \   00001C   12....       LCALL   ?Subroutine1 & 0xFFFF
   1432          
   1433            AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_153:
   \   00001F   12....       LCALL   ??AddrMgrEntryGet?relay
   1434          
   1435            // check if NWK address is same
   1436            if ( entry.nwkAddr != nwkAddr )
   \   000022   7401         MOV     A,#0x1
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   E0           MOVX    A,@DPTR
   \   000028   6E           XRL     A,R6
   \   000029   7003         JNZ     ??ZDSecMgrAddrMgrUpdate_0
   \   00002B   A3           INC     DPTR
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   6F           XRL     A,R7
   \                     ??ZDSecMgrAddrMgrUpdate_0:
   \   00002E   600F         JZ      ??ZDSecMgrAddrMgrUpdate_1
   1437            {
   1438              // update NWK address
   1439              entry.nwkAddr = nwkAddr;
   \   000030   7401         MOV     A,#0x1
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   EE           MOV     A,R6
   \   000036   F0           MOVX    @DPTR,A
   \   000037   A3           INC     DPTR
   \   000038   EF           MOV     A,R7
   \   000039   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   1440          
   1441              AddrMgrEntryUpdate( &entry );
   1442            }
   \                     ??CrossCallReturnLabel_156:
   \   00003C   12....       LCALL   ??AddrMgrEntryUpdate?relay
   1443          }
   \                     ??ZDSecMgrAddrMgrUpdate_1:
   \   00003F   02....       LJMP    ?Subroutine78 & 0xFFFF
   1444          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1445          ZStatus_t ZDSecMgrDeviceEntryAdd( ZDSecMgrDevice_t* device, uint16 ami )
   \                     ZDSecMgrDeviceEntryAdd:
   1446          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 2,R2
   \   00000C   8B..         MOV     ?V0 + 3,R3
   \   00000E   EC           MOV     A,R4
   \   00000F   FE           MOV     R6,A
   \   000010   ED           MOV     A,R5
   \   000011   FF           MOV     R7,A
   1447            ZStatus_t        status;
   1448            ZDSecMgrEntry_t* entry;
   1449          
   1450          
   1451            // initialize as unknown until completion
   1452            status = ZNwkUnknownDevice;
   \   000012   75..C8       MOV     ?V0 + 0,#-0x38
   1453          
   1454            device->ctrl = NULL;
   \   000015   8A82         MOV     DPL,R2
   \   000017   8B83         MOV     DPH,R3
   \   000019   A3           INC     DPTR
   \   00001A   A3           INC     DPTR
   \   00001B   A3           INC     DPTR
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   A3           INC     DPTR
   \   00001F   A3           INC     DPTR
   \   000020   A3           INC     DPTR
   \   000021   E4           CLR     A
   \   000022   F0           MOVX    @DPTR,A
   \   000023   A3           INC     DPTR
   \   000024   12....       LCALL   ?Subroutine11 & 0xFFFF
   1455          
   1456            // make sure not already registered
   1457            if ( ZDSecMgrEntryLookup( device->nwkAddr, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_11:
   \   000027   8A82         MOV     DPL,R2
   \   000029   8B83         MOV     DPH,R3
   \   00002B   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_135:
   \   00002E   12....       LCALL   ??ZDSecMgrEntryLookup?relay
   \   000031   E9           MOV     A,R1
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   7030         JNZ     ??ZDSecMgrDeviceEntryAdd_0
   1458            {
   1459              // verify that address index is same
   1460              if ( entry->ami != ami )
   \   00003A   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_32:
   \   00003D   E0           MOVX    A,@DPTR
   \   00003E   6E           XRL     A,R6
   \   00003F   7003         JNZ     ??ZDSecMgrDeviceEntryAdd_1
   \   000041   A3           INC     DPTR
   \   000042   E0           MOVX    A,@DPTR
   \   000043   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceEntryAdd_1:
   \   000044   6032         JZ      ??ZDSecMgrDeviceEntryAdd_2
   1461              {
   1462                // remove conflicting entry
   1463                ZDSecMgrDeviceEntryRemove( entry );
   \   000046   85..82       MOV     DPL,?XSP + 0
   \   000049   85..83       MOV     DPH,?XSP + 1
   \   00004C   A3           INC     DPTR
   \   00004D   E0           MOVX    A,@DPTR
   \   00004E   F583         MOV     DPH,A
   \   000050   8882         MOV     DPL,R0
   \   000052   74FE         MOV     A,#-0x2
   \   000054   F0           MOVX    @DPTR,A
   \   000055   A3           INC     DPTR
   \   000056   74FF         MOV     A,#-0x1
   \   000058   12....       LCALL   ?Subroutine11 & 0xFFFF
   1464          
   1465                if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??CrossCallReturnLabel_12:
   \   00005B   EE           MOV     A,R6
   \   00005C   FA           MOV     R2,A
   \   00005D   EF           MOV     A,R7
   \   00005E   FB           MOV     R3,A
   \   00005F   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000062   E9           MOV     A,R1
   \   000063   7013         JNZ     ??ZDSecMgrDeviceEntryAdd_2
   1466                {
   1467                  // update NWK address
   1468                  ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \                     ??ZDSecMgrDeviceEntryAdd_3:
   \   000065                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   000065   12....       LCALL   ?Subroutine22 & 0xFFFF
   1469                }
   1470              }
   1471            }
   \                     ??CrossCallReturnLabel_26:
   \   000068   800E         SJMP    ??ZDSecMgrDeviceEntryAdd_2
   1472            else if ( ZDSecMgrEntryLookupAMI( ami, &entry ) == ZSuccess )
   \                     ??ZDSecMgrDeviceEntryAdd_0:
   \   00006A                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   00006A   AC82         MOV     R4,DPL
   \   00006C   AD83         MOV     R5,DPH
   \   00006E   EE           MOV     A,R6
   \   00006F   FA           MOV     R2,A
   \   000070   EF           MOV     A,R7
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   ??ZDSecMgrEntryLookupAMI?relay
   \   000075   E9           MOV     A,R1
   \   000076   60ED         JZ      ??ZDSecMgrDeviceEntryAdd_3
   1473            {
   1474              // update NWK address
   1475              ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   1476            }
   1477          
   1478            // check if a new entry needs to be created
   1479            if ( entry == NULL )
   \                     ??ZDSecMgrDeviceEntryAdd_2:
   \   000078   85..82       MOV     DPL,?XSP + 0
   \   00007B   85..83       MOV     DPH,?XSP + 1
   \   00007E   E0           MOVX    A,@DPTR
   \   00007F   7002         JNZ     ??ZDSecMgrDeviceEntryAdd_4
   \   000081   A3           INC     DPTR
   \   000082   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceEntryAdd_4:
   \   000083   7021         JNZ     ??CrossCallReturnLabel_27
   1480            {
   1481              // get new entry
   1482              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000085                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000085   85..82       MOV     DPL,?XSP + 0
   \   000088   85..83       MOV     DPH,?XSP + 1
   \   00008B   AA82         MOV     R2,DPL
   \   00008D   AB83         MOV     R3,DPH
   \   00008F   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   000092   E9           MOV     A,R1
   \   000093   7014         JNZ     ??ZDSecMgrDeviceEntryAdd_5
   1483              {
   1484                // reset entry lkd
   1485          
   1486                // finish setting up entry
   1487                entry->ami = ami;
   \   000095   85..82       MOV     DPL,?XSP + 0
   \   000098   85..83       MOV     DPH,?XSP + 1
   \   00009B   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_33:
   \   00009E   EE           MOV     A,R6
   \   00009F   F0           MOVX    @DPTR,A
   \   0000A0   A3           INC     DPTR
   \   0000A1   EF           MOV     A,R7
   \   0000A2   F0           MOVX    @DPTR,A
   1488          
   1489                // update NWK address
   1490                ZDSecMgrAddrMgrUpdate( ami, device->nwkAddr );
   \   0000A3                ; Setup parameters for call to function ZDSecMgrAddrMgrUpdate
   \   0000A3   12....       LCALL   ?Subroutine22 & 0xFFFF
   1491          
   1492                // enter new device into device control
   1493                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1494                {
   1495                  status = ZDSecMgrCtrlAdd( device, entry );
   1496                }
   1497                else
   1498                {
   1499                  status = ZSuccess;
   1500                }
   1501              }
   1502            }
   1503            else
   1504            {
   1505              // reset entry lkd
   1506          
   1507              // reset entry in entry control
   1508              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1509              {
   1510                status = ZDSecMgrCtrlReset( device, entry );
   1511              }
   1512              else
   1513              {
   1514                status = ZSuccess;
   \                     ??CrossCallReturnLabel_27:
   \   0000A6   75..00       MOV     ?V0 + 0,#0x0
   1515              }
   1516            }
   1517          
   1518            return status;
   \                     ??ZDSecMgrDeviceEntryAdd_5:
   \   0000A9   A9..         MOV     R1,?V0 + 0
   \   0000AB   02....       LJMP    ?Subroutine75 & 0xFFFF
   1519          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine22:
   \   000000   85..82       MOV     DPL,?V0 + 2
   \   000003   85..83       MOV     DPH,?V0 + 3
   \   000006   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_76:
   \   000009   12....       LCALL   ??ZDSecMgrAddrMgrUpdate?relay
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine11:
   \   000000   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_82:
   \   000003   AC82         MOV     R4,DPL
   \   000005   AD83         MOV     R5,DPH
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine59:
   \   000000   F0           MOVX    @DPTR,A
   \   000001                ; Setup parameters for call to function ZDSecMgrEntryLookup
   \   000001                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000001                ; Setup parameters for call to function osal_nv_write
   \   000001                REQUIRE ?Subroutine68
   \   000001                ; // Fall through to label ?Subroutine68

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine53:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   FC           MOV     R4,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   FD           MOV     R5,A
   \   000005   EE           MOV     A,R6
   \   000006   FA           MOV     R2,A
   \   000007   EF           MOV     A,R7
   \   000008   FB           MOV     R3,A
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine75:
   \   000000   7402         MOV     A,#0x2
   \   000002                REQUIRE ??Subroutine106_0
   \   000002                ; // Fall through to label ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine26:
   \   000000   12....       LCALL   ?Subroutine56 & 0xFFFF
   \                     ??CrossCallReturnLabel_81:
   \   000003   22           RET
   1520          
   1521          /******************************************************************************
   1522           * @fn          ZDSecMgrDeviceCtrlHandler
   1523           *
   1524           * @brief       Device control handler.
   1525           *
   1526           * @param       device - [in] ZDSecMgrDevice_t, device info
   1527           *
   1528           * @return      none
   1529           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1530          void ZDSecMgrDeviceCtrlHandler( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlHandler:
   1531          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   1532            uint8 state;
   1533            uint8 cntr;
   1534          
   1535          
   1536            state = device->ctrl->state;
   \   000005   EA           MOV     A,R2
   \   000006   2408         ADD     A,#0x8
   \   000008   FE           MOV     R6,A
   \   000009   EB           MOV     A,R3
   \   00000A   3400         ADDC    A,#0x0
   \   00000C   FF           MOV     R7,A
   \   00000D   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_121:
   \   000010   E0           MOVX    A,@DPTR
   \   000011   F5..         MOV     ?V0 + 0,A
   1537            cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1538          
   1539            switch ( state )
   \   000013   12....       LCALL   ?UC_SWITCH_DENSE
   \                     `?<Jumptable for ZDSecMgrDeviceCtrlHandler>_0`:
   \   000016   02           DB        2
   \   000017   05           DB        5
   \   000018   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   00001A   ....         DW        ??ZDSecMgrDeviceCtrlHandler_1
   \   00001C   ....         DW        ??ZDSecMgrDeviceCtrlHandler_2
   \   00001E   ....         DW        ??ZDSecMgrDeviceCtrlHandler_3
   \   000020   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   000022   ....         DW        ??ZDSecMgrDeviceCtrlHandler_0
   \   000024   ....         DW        ??ZDSecMgrDeviceCtrlHandler_4
   1540            {
   1541              case ZDSECMGR_CTRL_TK_MASTER:
   1542                if ( ZDSecMgrSendMasterKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_1:
   \   000026                ; Setup parameters for call to function ZDSecMgrSendMasterKey
   \   000026   12....       LCALL   ??ZDSecMgrSendMasterKey?relay
   \   000029   E9           MOV     A,R1
   \   00002A   7016         JNZ     ??ZDSecMgrDeviceCtrlHandler_3
   1543                {
   1544                  state = ZDSECMGR_CTRL_SKKE_INIT;
   \   00002C   75..03       MOV     ?V0 + 0,#0x3
   1545                  cntr  = ZDSECMGR_CTRL_SKKE_INIT_CNTR;
   \   00002F   8015         SJMP    ??ZDSecMgrDeviceCtrlHandler_5
   1546                }
   1547                break;
   1548          
   1549              case ZDSECMGR_CTRL_SKKE_INIT:
   1550                if ( ZDSecMgrEstablishKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_2:
   \   000031                ; Setup parameters for call to function ZDSecMgrEstablishKey
   \   000031   12....       LCALL   ??ZDSecMgrEstablishKey?relay
   \   000034   E9           MOV     A,R1
   \   000035   700B         JNZ     ??ZDSecMgrDeviceCtrlHandler_3
   1551                {
   1552                  state = ZDSECMGR_CTRL_SKKE_WAIT;
   \   000037   75..04       MOV     ?V0 + 0,#0x4
   \   00003A   800A         SJMP    ??ZDSecMgrDeviceCtrlHandler_5
   1553                }
   1554                break;
   1555          
   1556              case ZDSECMGR_CTRL_SKKE_WAIT:
   1557                // continue to wait for SKA control timeout
   1558                break;
   1559          
   1560              case ZDSECMGR_CTRL_TK_NWK:
   1561                if ( ZDSecMgrSendNwkKey( device ) == ZSuccess )
   \                     ??ZDSecMgrDeviceCtrlHandler_4:
   \   00003C                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   00003C   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   00003F   E9           MOV     A,R1
   \   000040   602A         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   1562                {
   1563                  state = ZDSECMGR_CTRL_NONE;
   1564                }
   1565                break;
   1566          
   1567              default:
   1568                state = ZDSECMGR_CTRL_NONE;
   1569                break;
   1570            }
   1571          
   1572            if ( state != ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrDeviceCtrlHandler_3:
   \   000042   E5..         MOV     A,?V0 + 0
   \   000044   6026         JZ      ??ZDSecMgrDeviceCtrlHandler_0
   1573            {
   1574              device->ctrl->state = state;
   \                     ??ZDSecMgrDeviceCtrlHandler_5:
   \   000046   12....       LCALL   ?Subroutine21 & 0xFFFF
   \                     ??CrossCallReturnLabel_122:
   \   000049   E5..         MOV     A,?V0 + 0
   \   00004B   12....       LCALL   ?Subroutine17 & 0xFFFF
   1575              device->ctrl->cntr  = cntr;
   \                     ??CrossCallReturnLabel_90:
   \   00004E   F583         MOV     DPH,A
   \   000050   8882         MOV     DPL,R0
   \   000052   A3           INC     DPTR
   \   000053   A3           INC     DPTR
   \   000054   A3           INC     DPTR
   \   000055   A3           INC     DPTR
   \   000056   A3           INC     DPTR
   \   000057   A3           INC     DPTR
   \   000058   7401         MOV     A,#0x1
   \   00005A   F0           MOVX    @DPTR,A
   1576          
   1577              osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   00005B                ; Setup parameters for call to function osal_start_timerEx
   \   00005B   7C64         MOV     R4,#0x64
   \   00005D   7D00         MOV     R5,#0x0
   \   00005F   7A00         MOV     R2,#0x0
   \   000061   FB           MOV     R3,A
   \   000062   90....       MOV     DPTR,#ZDAppTaskID
   \   000065   E0           MOVX    A,@DPTR
   \   000066   F9           MOV     R1,A
   \   000067   12....       LCALL   ??osal_start_timerEx?relay
   \   00006A   8007         SJMP    ??CrossCallReturnLabel_25
   1578            }
   1579            else
   1580            {
   1581              ZDSecMgrCtrlRelease( device->ctrl );
   \                     ??ZDSecMgrDeviceCtrlHandler_0:
   \   00006C   8E82         MOV     DPL,R6
   \   00006E   8F83         MOV     DPH,R7
   \   000070   12....       LCALL   ?Subroutine20 & 0xFFFF
   1582            }
   1583          }
   \                     ??CrossCallReturnLabel_25:
   \   000073   02....       LJMP    ??Subroutine93_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine21:
   \   000000   8E82         MOV     DPL,R6
   \   000002   8F83         MOV     DPH,R7
   \   000004                REQUIRE ??Subroutine89_0
   \   000004                ; // Fall through to label ??Subroutine89_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine89_0:
   \   000000   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_128:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine50:
   \   000000   12....       LCALL   ?Subroutine64 & 0xFFFF
   \                     ??CrossCallReturnLabel_124:
   \   000003   02....       LJMP    ?Subroutine69 & 0xFFFF
   1584          
   1585          /******************************************************************************
   1586           * @fn          ZDSecMgrDeviceCtrlSetup
   1587           *
   1588           * @brief       Setup device control.
   1589           *
   1590           * @param       device - [in] ZDSecMgrDevice_t, device info
   1591           *
   1592           * @return      ZStatus_t
   1593           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1594          void ZDSecMgrDeviceCtrlSetup( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceCtrlSetup:
   1595          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1596            if ( device->ctrl != NULL )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   12....       LCALL   ??Subroutine108_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_222:
   \   00000F   E8           MOV     A,R0
   \   000010   7001         JNZ     ??ZDSecMgrDeviceCtrlSetup_0
   \   000012   E9           MOV     A,R1
   \                     ??ZDSecMgrDeviceCtrlSetup_0:
   \   000013   6023         JZ      ??ZDSecMgrDeviceCtrlSetup_1
   1597            {
   1598              if ( device->secure == FALSE )
   \   000015   E8           MOV     A,R0
   \   000016   2405         ADD     A,#0x5
   \   000018   F8           MOV     R0,A
   \   000019   E9           MOV     A,R1
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F9           MOV     R1,A
   \   00001D   8A82         MOV     DPL,R2
   \   00001F   8B83         MOV     DPH,R3
   \   000021   A3           INC     DPTR
   \   000022   A3           INC     DPTR
   \   000023   A3           INC     DPTR
   \   000024   A3           INC     DPTR
   \   000025   A3           INC     DPTR
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   7004         JNZ     ??ZDSecMgrDeviceCtrlSetup_2
   1599              {
   1600                // send the master key data to the joining device
   1601                device->ctrl->state = ZDSECMGR_CTRL_TK_MASTER;
   \   00002A   7402         MOV     A,#0x2
   \   00002C   8002         SJMP    ??ZDSecMgrDeviceCtrlSetup_3
   1602              }
   1603              else
   1604              {
   1605                // start SKKE
   1606                device->ctrl->state = ZDSECMGR_CTRL_SKKE_INIT;
   \                     ??ZDSecMgrDeviceCtrlSetup_2:
   \   00002E   7403         MOV     A,#0x3
   \                     ??ZDSecMgrDeviceCtrlSetup_3:
   \   000030   8882         MOV     DPL,R0
   \   000032   8983         MOV     DPH,R1
   \   000034   F0           MOVX    @DPTR,A
   1607              }
   1608          
   1609              ZDSecMgrDeviceCtrlHandler( device );
   \   000035                ; Setup parameters for call to function ZDSecMgrDeviceCtrlHandler
   \   000035   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   1610            }
   1611          }
   \                     ??ZDSecMgrDeviceCtrlSetup_1:
   \   000038   02....       LJMP    ??Subroutine97_0 & 0xFFFF
   1612          
   1613          /******************************************************************************
   1614           * @fn          ZDSecMgrDeviceCtrlUpdate
   1615           *
   1616           * @brief       Update control data.
   1617           *
   1618           * @param       extAddr - [in] EXT address
   1619           * @param       state   - [in] new control state
   1620           *
   1621           * @return      none
   1622           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1623          void ZDSecMgrDeviceCtrlUpdate( uint8* extAddr, uint8 state )
   \                     ZDSecMgrDeviceCtrlUpdate:
   1624          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   1625            ZDSecMgrEntry_t* entry;
   1626            ZDSecMgrCtrl_t*  ctrl;
   1627          
   1628          
   1629            // lookup device entry data
   1630            ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   7402         MOV     A,#0x2
   \   00000E   12....       LCALL   ?XSTACK_DISP0_8
   \   000011   AC82         MOV     R4,DPL
   \   000013   AD83         MOV     R5,DPH
   \   000015   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   1631          
   1632            if ( entry != NULL )
   \   000018   7402         MOV     A,#0x2
   \   00001A   12....       LCALL   ?XSTACK_DISP0_8
   \   00001D   E0           MOVX    A,@DPTR
   \   00001E   7002         JNZ     ??ZDSecMgrDeviceCtrlUpdate_0
   \   000020   A3           INC     DPTR
   \   000021   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceCtrlUpdate_0:
   \   000022   6046         JZ      ??ZDSecMgrDeviceCtrlUpdate_1
   1633            {
   1634              // lookup device control data
   1635              ZDSecMgrCtrlLookup( entry, &ctrl );
   \   000024                ; Setup parameters for call to function ZDSecMgrCtrlLookup
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   AC82         MOV     R4,DPL
   \   00002C   AD83         MOV     R5,DPH
   \   00002E   7402         MOV     A,#0x2
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_136:
   \   000036   12....       LCALL   ?Subroutine46 & 0xFFFF
   1636          
   1637              // make sure control data is valid
   1638              if ( ctrl != NULL )
   \                     ??CrossCallReturnLabel_68:
   \   000039   7002         JNZ     ??ZDSecMgrDeviceCtrlUpdate_2
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrDeviceCtrlUpdate_2:
   \   00003D   602B         JZ      ??ZDSecMgrDeviceCtrlUpdate_1
   1639              {
   1640                // possible state transitions
   1641                if ( ctrl->state == ZDSECMGR_CTRL_SKKE_WAIT )
   \   00003F   85..82       MOV     DPL,?XSP + 0
   \   000042   85..83       MOV     DPH,?XSP + 1
   \   000045   E0           MOVX    A,@DPTR
   \   000046   2405         ADD     A,#0x5
   \   000048   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_101:
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   6404         XRL     A,#0x4
   \   00004E   701A         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1642                {
   1643                  if ( state == ZDSECMGR_CTRL_SKKE_DONE )
   \   000050   7405         MOV     A,#0x5
   \   000052   6E           XRL     A,R6
   \   000053   7004         JNZ     ??ZDSecMgrDeviceCtrlUpdate_3
   1644                  {
   1645                    // send the network key
   1646                    ctrl->state = ZDSECMGR_CTRL_TK_NWK;
   \   000055   7407         MOV     A,#0x7
   \   000057   8007         SJMP    ??ZDSecMgrDeviceCtrlUpdate_4
   1647                    ctrl->cntr  = ZDSECMGR_CTRL_TK_NWK_CNTR;
   1648                  }
   1649                  else if ( state == ZDSECMGR_CTRL_SKKE_FAIL )
   \                     ??ZDSecMgrDeviceCtrlUpdate_3:
   \   000059   7406         MOV     A,#0x6
   \   00005B   6E           XRL     A,R6
   \   00005C   700C         JNZ     ??ZDSecMgrDeviceCtrlUpdate_1
   1650                  {
   1651                    // force default timeout in order to cleanup control logic
   1652                    ctrl->state = ZDSECMGR_CTRL_SKKE_FAIL;
   \   00005E   7406         MOV     A,#0x6
   1653                    ctrl->cntr  = ZDSECMGR_CTRL_BASE_CNTR;
   1654                  }
   1655                }
   1656                // timer should be active
   1657              }
   1658            }
   \                     ??ZDSecMgrDeviceCtrlUpdate_4:
   \   000060   12....       LCALL   ?Subroutine59 & 0xFFFF
   \                     ??CrossCallReturnLabel_83:
   \   000063   12....       LCALL   ??Subroutine89_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_120:
   \   000066   A3           INC     DPTR
   \   000067   7401         MOV     A,#0x1
   \   000069   F0           MOVX    @DPTR,A
   1659          }
   \                     ??ZDSecMgrDeviceCtrlUpdate_1:
   \   00006A                REQUIRE ?Subroutine79
   \   00006A                ; // Fall through to label ?Subroutine79

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine79:
   \   000000   7404         MOV     A,#0x4
   \   000002   02....       LJMP    ??Subroutine92_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine57:
   \   000000   F8           MOV     R0,A
   \   000001   A3           INC     DPTR
   \   000002   E0           MOVX    A,@DPTR
   \   000003   3400         ADDC    A,#0x0
   \   000005   F9           MOV     R1,A
   \   000006   02....       LJMP    ?Subroutine72 & 0xFFFF
   1660          
   1661          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1662          void APSME_SKA_TimerExpired( uint8 initiator, uint8* partExtAddr )
   \                     APSME_SKA_TimerExpired:
   1663          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   1664            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   1665            {
   1666              if ( initiator == TRUE )
   1667              {
   1668                ZDSecMgrDeviceCtrlUpdate( partExtAddr, ZDSECMGR_CTRL_SKKE_FAIL );
   1669              }
   1670            }
   1671          }
   \   000000   02....       LJMP    ?BRET
   1672          
   1673          /******************************************************************************
   1674           * @fn          ZDSecMgrDeviceRemove
   1675           *
   1676           * @brief       Remove device from network.
   1677           *
   1678           * @param       device - [in] ZDSecMgrDevice_t, device info
   1679           *
   1680           * @return      none
   1681           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1682          void ZDSecMgrDeviceRemove( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceRemove:
   1683          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 9
   \   000005   74F7         MOV     A,#-0x9
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1684            APSME_RemoveDeviceReq_t remDevReq;
   1685            NLME_LeaveReq_t         leaveReq;
   1686            associated_devices_t*   assoc;
   1687          
   1688          
   1689            // check if parent, remove the device
   1690            if ( device->parentAddr == NLME_GetShortAddr() )
   \   00000E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00000E   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000011   8A..         MOV     ?V0 + 0,R2
   \   000013   8B..         MOV     ?V0 + 1,R3
   \   000015   EE           MOV     A,R6
   \   000016   2402         ADD     A,#0x2
   \   000018   F8           MOV     R0,A
   \   000019   EF           MOV     A,R7
   \   00001A   3400         ADDC    A,#0x0
   \   00001C   F9           MOV     R1,A
   \   00001D   E8           MOV     A,R0
   \   00001E   FA           MOV     R2,A
   \   00001F   E9           MOV     A,R1
   \   000020   FB           MOV     R3,A
   \   000021   8A82         MOV     DPL,R2
   \   000023   8B83         MOV     DPH,R3
   \   000025   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_214:
   \   000028   8E82         MOV     DPL,R6
   \   00002A   8F83         MOV     DPH,R7
   \   00002C   A3           INC     DPTR
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   E0           MOVX    A,@DPTR
   \   000031   FE           MOV     R6,A
   \   000032   A3           INC     DPTR
   \   000033   E0           MOVX    A,@DPTR
   \   000034   FF           MOV     R7,A
   \   000035   E5..         MOV     A,?V0 + 0
   \   000037   6E           XRL     A,R6
   \   000038   7003         JNZ     ??ZDSecMgrDeviceRemove_0
   \   00003A   E5..         MOV     A,?V0 + 1
   \   00003C   6F           XRL     A,R7
   \                     ??ZDSecMgrDeviceRemove_0:
   \   00003D   7055         JNZ     ??ZDSecMgrDeviceRemove_1
   1691            {
   1692              // this is the parent of the device
   1693              leaveReq.extAddr        = device->extAddr;
   \   00003F   12....       LCALL   ?Subroutine15 & 0xFFFF
   1694              leaveReq.removeChildren = FALSE;
   \                     ??CrossCallReturnLabel_129:
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   E4           CLR     A
   \   000046   F0           MOVX    @DPTR,A
   1695              leaveReq.rejoin         = FALSE;
   \   000047   7403         MOV     A,#0x3
   \   000049   12....       LCALL   ?XSTACK_DISP0_8
   \   00004C   E4           CLR     A
   \   00004D   12....       LCALL   ?Subroutine61 & 0xFFFF
   1696          
   1697              // find child association
   1698              assoc = AssocGetWithExt( device->extAddr );
   \                     ??CrossCallReturnLabel_94:
   \   000050   12....       LCALL   ?Subroutine35 & 0xFFFF
   \                     ??CrossCallReturnLabel_46:
   \   000053   8A..         MOV     ?V0 + 0,R2
   \   000055   8B..         MOV     ?V0 + 1,R3
   \   000057   A8..         MOV     R0,?V0 + 0
   \   000059   A9..         MOV     R1,?V0 + 1
   1699          
   1700              if ( ( assoc != NULL                            ) &&
   1701                   ( assoc->nodeRelation >= CHILD_RFD         ) &&
   1702                   ( assoc->nodeRelation <= CHILD_FFD_RX_IDLE )    )
   \   00005B   E8           MOV     A,R0
   \   00005C   7001         JNZ     ??ZDSecMgrDeviceRemove_2
   \   00005E   E9           MOV     A,R1
   \                     ??ZDSecMgrDeviceRemove_2:
   \   00005F   604F         JZ      ??ZDSecMgrDeviceRemove_3
   \   000061   8882         MOV     DPL,R0
   \   000063   8983         MOV     DPH,R1
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   6044         JZ      ??ZDSecMgrDeviceRemove_3
   \   00006C   C3           CLR     C
   \   00006D   9405         SUBB    A,#0x5
   \   00006F   503F         JNC     ??ZDSecMgrDeviceRemove_3
   1703              {
   1704                // check if associated device is authenticated
   1705                if ( assoc->devStatus & DEV_SEC_AUTH_STATUS )
   \   000071   8882         MOV     DPL,R0
   \   000073   8983         MOV     DPH,R1
   \   000075   A3           INC     DPTR
   \   000076   A3           INC     DPTR
   \   000077   A3           INC     DPTR
   \   000078   A3           INC     DPTR
   \   000079   A3           INC     DPTR
   \   00007A   E0           MOVX    A,@DPTR
   \   00007B   A2E3         MOV     C,0xE0 /* A   */.3
   \   00007D   7404         MOV     A,#0x4
   \   00007F   5006         JNC     ??ZDSecMgrDeviceRemove_4
   1706                {
   1707                  leaveReq.silent = FALSE;
   \   000081   12....       LCALL   ?XSTACK_DISP0_8
   \   000084   E4           CLR     A
   \   000085   8005         SJMP    ??ZDSecMgrDeviceRemove_5
   1708                }
   1709                else
   1710                {
   1711                  leaveReq.silent = TRUE;
   \                     ??ZDSecMgrDeviceRemove_4:
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   7401         MOV     A,#0x1
   1712                }
   1713          
   1714                NLME_LeaveReq( &leaveReq );
   1715              }
   1716            }
   \                     ??ZDSecMgrDeviceRemove_5:
   \   00008C   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_157:
   \   00008F   12....       LCALL   ??NLME_LeaveReq?relay
   \   000092   801C         SJMP    ??ZDSecMgrDeviceRemove_3
   1717            else
   1718            {
   1719              // this is not the parent of the device
   1720              remDevReq.parentAddr   = device->parentAddr;
   \                     ??ZDSecMgrDeviceRemove_1:
   \   000094   7405         MOV     A,#0x5
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   EE           MOV     A,R6
   \   00009A   F0           MOVX    @DPTR,A
   \   00009B   A3           INC     DPTR
   \   00009C   EF           MOV     A,R7
   \   00009D   F0           MOVX    @DPTR,A
   1721              remDevReq.childExtAddr = device->extAddr;
   \   00009E   7407         MOV     A,#0x7
   \   0000A0   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A3   12....       LCALL   ??Subroutine88_0 & 0xFFFF
   1722          
   1723              APSME_RemoveDeviceReq( &remDevReq );
   1724            }
   \                     ??CrossCallReturnLabel_119:
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   AA82         MOV     R2,DPL
   \   0000AB   AB83         MOV     R3,DPH
   \   0000AD   12....       LCALL   ??APSME_RemoveDeviceReq?relay
   1725          }
   \                     ??ZDSecMgrDeviceRemove_3:
   \   0000B0   7409         MOV     A,#0x9
   \   0000B2   02....       LJMP    ??Subroutine103_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine15:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine90_0
   \   000006                ; // Fall through to label ??Subroutine90_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine35:
   \   000000   12....       LCALL   ?Subroutine55 & 0xFFFF
   \                     ??CrossCallReturnLabel_145:
   \   000003   12....       LCALL   ??AssocGetWithExt?relay
   \   000006   22           RET
   1726          
   1727          /******************************************************************************
   1728           * @fn          ZDSecMgrDeviceValidateSKKE
   1729           *
   1730           * @brief       Decide whether device is allowed for SKKE.
   1731           *
   1732           * @param       device - [in] ZDSecMgrDevice_t, device info
   1733           *
   1734           * @return      ZStatus_t
   1735           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1736          ZStatus_t ZDSecMgrDeviceValidateSKKE( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateSKKE:
   1737          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1738            ZStatus_t status;
   1739            uint16    ami;
   1740            uint8*    key;
   1741          
   1742          
   1743            // get EXT address
   1744            status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   8E82         MOV     DPL,R6
   \   00001A   8F83         MOV     DPH,R7
   \   00001C   A3           INC     DPTR
   \   00001D   A3           INC     DPTR
   \   00001E   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_137:
   \   000021   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   000024   E9           MOV     A,R1
   1745          
   1746            if ( status == ZSuccess )
   \   000025   700D         JNZ     ??CrossCallReturnLabel_28
   1747            {
   1748              // get MASTER key
   1749              status = ZDSecMgrMasterKeyLookup( ami, &key );
   \   000027                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000027   7402         MOV     A,#0x2
   \   000029   12....       LCALL   ?XSTACK_DISP0_8
   \   00002C   12....       LCALL   ?Subroutine19 & 0xFFFF
   1750          
   1751              if ( status == ZSuccess )
   \                     ??CrossCallReturnLabel_22:
   \   00002F   7003         JNZ     ??CrossCallReturnLabel_28
   1752              {
   1753              //  // check if initiator is Trust Center
   1754              //  if ( device->nwkAddr == APSME_TRUSTCENTER_NWKADDR )
   1755              //  {
   1756              //    // verify NWK key not sent
   1757              //    // devtag.todo
   1758              //    // temporary - add device to internal data
   1759              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1760              //  }
   1761              //  else
   1762              //  {
   1763              //    // initiator not Trust Center - End to End SKKE - set policy
   1764              //    // for accepting an SKKE initiation
   1765              //    // temporary - add device to internal data
   1766              //    status = ZDSecMgrDeviceEntryAdd( device, ami );
   1767              //  }
   1768                  status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   000031                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   000031   12....       LCALL   ?Subroutine23 & 0xFFFF
   1769              }
   1770            }
   1771          
   1772            return status;
   \                     ??CrossCallReturnLabel_28:
   \   000034   02....       LJMP    ?Subroutine79 & 0xFFFF
   1773          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine23:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   12....       LCALL   ?Subroutine53 & 0xFFFF
   \                     ??CrossCallReturnLabel_77:
   \   000009   12....       LCALL   ??ZDSecMgrDeviceEntryAdd?relay
   \   00000C   22           RET
   1774          
   1775          /******************************************************************************
   1776           * @fn          ZDSecMgrDeviceValidateRM (RESIDENTIAL MODE)
   1777           *
   1778           * @brief       Decide whether device is allowed.
   1779           *
   1780           * @param       device - [in] ZDSecMgrDevice_t, device info
   1781           *
   1782           * @return      ZStatus_t
   1783           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1784          ZStatus_t ZDSecMgrDeviceValidateRM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateRM:
   1785          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1786          
   1787            ZStatus_t status;
   1788            status = ZSuccess;
   \   000004   7900         MOV     R1,#0x0
   1789          
   1790            (void)device;  // Intentionally unreferenced parameter
   1791            
   1792            // For test purpose, turning off the zgSecurePermitJoin flag will force
   1793            // the trust center to reject any newly joining devices by sending
   1794            // Remove-device to the parents.
   1795            if ( zgSecurePermitJoin == false )
   \   000006   90....       MOV     DPTR,#zgSecurePermitJoin
   \   000009   E0           MOVX    A,@DPTR
   \   00000A   7002         JNZ     ??ZDSecMgrDeviceValidateRM_0
   1796            {
   1797              status = ZNwkUnknownDevice;
   \   00000C   79C8         MOV     R1,#-0x38
   1798            }
   1799          
   1800          
   1801          
   1802          #if 0  // Taken out because the following functionality is only used for test
   1803                 // purpose. A more efficient (above) way is used. It can be put
   1804                 // back in if customers request for a white/black list feature.
   1805                 // ZDSecMgrStoredDeviceList[] is defined in ZDSecMgr.c
   1806          
   1807            // The following code processes the device black list (stored device list)
   1808            // If the joining device is not part of the forbidden device list
   1809            // Return ZSuccess. Otherwise, return ZNwkUnknownDevice. The trust center
   1810            // will send Remove-device and ban the device from joining.
   1811          
   1812            uint8     index;
   1813            uint8*    restricted;
   1814          
   1815            // Look through the stored device list - used for restricted devices
   1816            for ( index = 0; index < ZDSECMGR_STORED_DEVICES; index++ )
   1817            {
   1818              restricted = ZDSecMgrStoredDeviceList[index];
   1819          
   1820              if ( AddrMgrExtAddrEqual( restricted, device->extAddr )  == TRUE )
   1821              {
   1822                // return as unknown device in regards to validation
   1823                status = ZNwkUnknownDevice;
   1824          
   1825                // break from loop
   1826                index = ZDSECMGR_STORED_DEVICES;
   1827              }
   1828            }
   1829          
   1830          #endif
   1831          
   1832            return status;
   \                     ??ZDSecMgrDeviceValidateRM_0:
   \   00000E   02....       LJMP    ??Subroutine97_0 & 0xFFFF
   1833          }
   1834          
   1835          /******************************************************************************
   1836           * @fn          ZDSecMgrDeviceValidateCM (COMMERCIAL MODE)
   1837           *
   1838           * @brief       Decide whether device is allowed.
   1839           *
   1840           * @param       device - [in] ZDSecMgrDevice_t, device info
   1841           *
   1842           * @return      ZStatus_t
   1843           */
   1844          //devtag.pro.security

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1845          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidateCM:
   1846          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   1847            ZStatus_t status;
   1848            uint16    ami;
   1849            uint8*    key;
   1850          
   1851          
   1852          //  // check for pre configured setting
   1853          //  if ( device->secure == TRUE )
   1854          //  {
   1855          //    // get EXT address and MASTER key
   1856          //    status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1857          //
   1858          //    if ( status == ZSuccess )
   1859          //    {
   1860          //      status = ZDSecMgrMasterKeyLookup( ami, &key );
   1861          //    }
   1862          //  }
   1863          //  else
   1864          //  {
   1865              // implement EXT address and MASTER key policy here -- the total number of
   1866              // Security Manager entries should never exceed the number of EXT addresses
   1867              // and MASTER keys available
   1868          
   1869              // set status based on policy
   1870              //status = ZNwkUnknownDevice;
   1871          
   1872              // set status based on policy
   1873              status = ZSuccess; // ZNwkUnknownDevice;
   1874          
   1875              // get key based on policy
   1876              key = ZDSecMgrTCMasterKey;
   1877          
   1878              // if policy, store new EXT address
   1879              status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   \   00000E   EE           MOV     A,R6
   \   00000F   2402         ADD     A,#0x2
   \   000011   12....       LCALL   ?Subroutine42 & 0xFFFF
   \                     ??CrossCallReturnLabel_88:
   \   000014   8582..       MOV     ?V0 + 2,DPL
   \   000017   8583..       MOV     ?V0 + 3,DPH
   \   00001A   78..         MOV     R0,#?V0 + 2
   \   00001C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001F   85..82       MOV     DPL,?V0 + 0
   \   000022   85..83       MOV     DPH,?V0 + 1
   \   000025   E0           MOVX    A,@DPTR
   \   000026   FC           MOV     R4,A
   \   000027   A3           INC     DPTR
   \   000028   E0           MOVX    A,@DPTR
   \   000029   FD           MOV     R5,A
   \   00002A   12....       LCALL   ?Subroutine36 & 0xFFFF
   \                     ??CrossCallReturnLabel_141:
   \   00002D   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   000030   7402         MOV     A,#0x2
   \   000032   12....       LCALL   ?DEALLOC_XSTACK8
   \   000035   E9           MOV     A,R1
   \   000036   F5..         MOV     ?V0 + 2,A
   1880          
   1881              // set the key
   1882              ZDSecMgrMasterKeyLoad( device->extAddr, key );
   \   000038                ; Setup parameters for call to function ZDSecMgrMasterKeyLoad
   \   000038   7C..         MOV     R4,#(ZDSecMgrTCMasterKey & 0xff)
   \   00003A   7D..         MOV     R5,#((ZDSecMgrTCMasterKey >> 8) & 0xff)
   \   00003C   85..82       MOV     DPL,?V0 + 0
   \   00003F   85..83       MOV     DPH,?V0 + 1
   \   000042   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_138:
   \   000045   12....       LCALL   ??ZDSecMgrMasterKeyLoad?relay
   1883          //  }
   1884          
   1885            // if EXT address and MASTER key available -- add device
   1886            if ( status == ZSuccess )
   \   000048   E5..         MOV     A,?V0 + 2
   \   00004A   7006         JNZ     ??ZDSecMgrDeviceValidateCM_0
   1887            {
   1888              // add device to internal data - with control
   1889              status = ZDSecMgrDeviceEntryAdd( device, ami );
   \   00004C                ; Setup parameters for call to function ZDSecMgrDeviceEntryAdd
   \   00004C   12....       LCALL   ?Subroutine23 & 0xFFFF
   1890            }
   \                     ??CrossCallReturnLabel_29:
   \   00004F   E9           MOV     A,R1
   \   000050   F5..         MOV     ?V0 + 2,A
   1891          
   1892            return status;
   \                     ??ZDSecMgrDeviceValidateCM_0:
   \   000052   A9..         MOV     R1,?V0 + 2
   \   000054   02....       LJMP    ?Subroutine75 & 0xFFFF
   1893          }
   1894          //devtag.pro.security
   1895          #if 0
   1896          ZStatus_t ZDSecMgrDeviceValidateCM( ZDSecMgrDevice_t* device )
   1897          {
   1898            ZStatus_t status;
   1899            uint16    ami;
   1900            uint8*    key;
   1901          
   1902          
   1903            // check for pre configured setting
   1904            if ( device->secure == TRUE )
   1905            {
   1906              // get EXT address and MASTER key
   1907              status = ZDSecMgrExtAddrLookup( device->extAddr, &ami );
   1908          
   1909              if ( status == ZSuccess )
   1910              {
   1911                status = ZDSecMgrMasterKeyLookup( ami, &key );
   1912              }
   1913            }
   1914            else
   1915            {
   1916              // implement EXT address and MASTER key policy here -- the total number of
   1917              // Security Manager entries should never exceed the number of EXT addresses
   1918              // and MASTER keys available
   1919          
   1920              // set status based on policy
   1921              status = ZSuccess; // ZNwkUnknownDevice;
   1922          
   1923              // get the address index
   1924              if ( ZDSecMgrExtAddrLookup( device->extAddr, &ami ) != ZSuccess )
   1925              {
   1926                // if policy, store new EXT address
   1927                status = ZDSecMgrAddrStore( device->nwkAddr, device->extAddr, &ami );
   1928              }
   1929          
   1930              // get the address index
   1931              if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   1932              {
   1933                // if policy, store new key -- NULL will zero key
   1934                status = ZDSecMgrMasterKeyStore( ami, NULL );
   1935              }
   1936            }
   1937          
   1938            // if EXT address and MASTER key available -- add device
   1939            if ( status == ZSuccess )
   1940            {
   1941              // add device to internal data - with control
   1942              status = ZDSecMgrDeviceEntryAdd( device, ami );
   1943            }
   1944          
   1945            return status;
   1946          }
   1947          #endif
   1948          
   1949          /******************************************************************************
   1950           * @fn          ZDSecMgrDeviceValidate
   1951           *
   1952           * @brief       Decide whether device is allowed.
   1953           *
   1954           * @param       device - [in] ZDSecMgrDevice_t, device info
   1955           *
   1956           * @return      ZStatus_t
   1957           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   1958          ZStatus_t ZDSecMgrDeviceValidate( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceValidate:
   1959          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   1960            ZStatus_t status;
   1961          
   1962          
   1963            if ( ZDSecMgrPermitJoiningEnabled == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   701F         JNZ     ??ZDSecMgrDeviceValidate_0
   1964            {
   1965              // device may be joining with a secure flag but it is ultimately the Trust
   1966              // Center that decides -- check if expected pre configured device --
   1967              // override settings
   1968              if ( zgPreConfigKeys == TRUE )
   \   00000C   EA           MOV     A,R2
   \   00000D   2406         ADD     A,#0x6
   \   00000F   F8           MOV     R0,A
   \   000010   EB           MOV     A,R3
   \   000011   3400         ADDC    A,#0x0
   \   000013   F9           MOV     R1,A
   \   000014   90....       MOV     DPTR,#zgPreConfigKeys
   \   000017   E0           MOVX    A,@DPTR
   \   000018   6401         XRL     A,#0x1
   \   00001A   7004         JNZ     ??ZDSecMgrDeviceValidate_1
   1969              {
   1970                device->secure = TRUE;
   \   00001C   7401         MOV     A,#0x1
   \   00001E   8001         SJMP    ??ZDSecMgrDeviceValidate_2
   1971              }
   1972              else
   1973              {
   1974                device->secure = FALSE;
   \                     ??ZDSecMgrDeviceValidate_1:
   \   000020   E4           CLR     A
   \                     ??ZDSecMgrDeviceValidate_2:
   \   000021   8882         MOV     DPL,R0
   \   000023   8983         MOV     DPH,R1
   \   000025   F0           MOVX    @DPTR,A
   1975              }
   1976          
   1977              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   1978              {
   1979                status = ZDSecMgrDeviceValidateCM( device );
   1980              }
   1981              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   1982              {
   1983                status = ZDSecMgrDeviceValidateRM( device );
   \   000026                ; Setup parameters for call to function ZDSecMgrDeviceValidateRM
   \   000026   12....       LCALL   ??ZDSecMgrDeviceValidateRM?relay
   \   000029   8002         SJMP    ??ZDSecMgrDeviceValidate_3
   1984              }
   1985            }
   1986            else
   1987            {
   1988              status = ZNwkUnknownDevice;
   \                     ??ZDSecMgrDeviceValidate_0:
   \   00002B   79C8         MOV     R1,#-0x38
   1989            }
   1990          
   1991            return status;
   \                     ??ZDSecMgrDeviceValidate_3:
   \   00002D   02....       LJMP    ??Subroutine97_0 & 0xFFFF
   1992          }
   1993          
   1994          /******************************************************************************
   1995           * @fn          ZDSecMgrDeviceJoin
   1996           *
   1997           * @brief       Try to join this device.
   1998           *
   1999           * @param       device - [in] ZDSecMgrDevice_t, device info
   2000           *
   2001           * @return      ZStatus_t
   2002           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2003          ZStatus_t ZDSecMgrDeviceJoin( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoin:
   2004          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2005            ZStatus_t status;
   2006          
   2007            // attempt to validate device
   2008            status = ZDSecMgrDeviceValidate( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceValidate
   \   000009   12....       LCALL   ??ZDSecMgrDeviceValidate?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2009          
   2010            if ( status == ZSuccess )
   \   00000F   700C         JNZ     ??ZDSecMgrDeviceJoin_0
   2011            {
   2012              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2013              {
   2014                ZDSecMgrDeviceCtrlSetup( device );
   2015              }
   2016              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2017              {
   2018                //send the nwk key data to the joining device
   2019                status = ZDSecMgrSendNwkKey( device );
   \   000011                ; Setup parameters for call to function ZDSecMgrSendNwkKey
   \   000011   EE           MOV     A,R6
   \   000012   FA           MOV     R2,A
   \   000013   EF           MOV     A,R7
   \   000014   FB           MOV     R3,A
   \   000015   12....       LCALL   ??ZDSecMgrSendNwkKey?relay
   \   000018   E9           MOV     A,R1
   \   000019   F5..         MOV     ?V0 + 0,A
   \   00001B   8007         SJMP    ??ZDSecMgrDeviceJoin_1
   2020              }
   2021            }
   2022            else
   2023            {
   2024              // not allowed, remove the device
   2025              ZDSecMgrDeviceRemove( device );
   \                     ??ZDSecMgrDeviceJoin_0:
   \   00001D                ; Setup parameters for call to function ZDSecMgrDeviceRemove
   \   00001D   EE           MOV     A,R6
   \   00001E   FA           MOV     R2,A
   \   00001F   EF           MOV     A,R7
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2026            }
   2027          
   2028            return status;
   \                     ??ZDSecMgrDeviceJoin_1:
   \   000024                REQUIRE ?Subroutine82
   \   000024                ; // Fall through to label ?Subroutine82
   2029          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine82:
   \   000000   A9..         MOV     R1,?V0 + 0
   \   000002   02....       LJMP    ??Subroutine93_0 & 0xFFFF
   2030          
   2031          /******************************************************************************
   2032           * @fn          ZDSecMgrDeviceJoinDirect
   2033           *
   2034           * @brief       Try to join this device as a direct child.
   2035           *
   2036           * @param       device - [in] ZDSecMgrDevice_t, device info
   2037           *
   2038           * @return      ZStatus_t
   2039           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2040          ZStatus_t ZDSecMgrDeviceJoinDirect( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinDirect:
   2041          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2042            ZStatus_t status;
   2043          
   2044            status = ZDSecMgrDeviceJoin( device );
   \   000009                ; Setup parameters for call to function ZDSecMgrDeviceJoin
   \   000009   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   \   00000C   E9           MOV     A,R1
   \   00000D   F5..         MOV     ?V0 + 0,A
   2045          
   2046            if ( status == ZSuccess )
   \   00000F   7009         JNZ     ??ZDSecMgrDeviceJoinDirect_0
   2047            {
   2048              // set association status to authenticated
   2049              ZDSecMgrAssocDeviceAuth( AssocGetWithShort( device->nwkAddr ) );
   \   000011                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000011                ; Setup parameters for call to function AssocGetWithShort
   \   000011   12....       LCALL   ?Subroutine36 & 0xFFFF
   2050            }
   \                     ??CrossCallReturnLabel_142:
   \   000014   12....       LCALL   ??AssocGetWithShort?relay
   \   000017   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2051          
   2052            return status;
   \                     ??ZDSecMgrDeviceJoinDirect_0:
   \   00001A   80..         SJMP    ?Subroutine82
   2053          }
   2054          
   2055          /******************************************************************************
   2056           * @fn          ZDSecMgrDeviceJoinFwd
   2057           *
   2058           * @brief       Forward join to Trust Center.
   2059           *
   2060           * @param       device - [in] ZDSecMgrDevice_t, device info
   2061           *
   2062           * @return      ZStatus_t
   2063           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2064          ZStatus_t ZDSecMgrDeviceJoinFwd( ZDSecMgrDevice_t* device )
   \                     ZDSecMgrDeviceJoinFwd:
   2065          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 8
   \   000004   74F8         MOV     A,#-0x8
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2066            ZStatus_t               status;
   2067            APSME_UpdateDeviceReq_t req;
   2068          
   2069          
   2070            // forward any joining device to the Trust Center -- the Trust Center will
   2071            // decide if the device is allowed to join
   2072            status = ZSuccess;
   2073          
   2074            // forward authorization to the Trust Center
   2075            req.dstAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000009   85..82       MOV     DPL,?XSP + 0
   \   00000C   85..83       MOV     DPH,?XSP + 1
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   12....       LCALL   ?Subroutine61 & 0xFFFF
   2076            req.devAddr    = device->nwkAddr;
   \                     ??CrossCallReturnLabel_95:
   \   000015   12....       LCALL   ?Subroutine27 & 0xFFFF
   \                     ??CrossCallReturnLabel_37:
   \   000018   12....       LCALL   ?XSTACK_DISP0_8
   \   00001B   12....       LCALL   ?Subroutine5 & 0xFFFF
   2077            req.devExtAddr = device->extAddr;
   \                     ??CrossCallReturnLabel_5:
   \   00001E   12....       LCALL   ?XSTACK_DISP0_8
   \   000021   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   2078          
   2079            // set security status, option for router to reject if policy set
   2080            if ( (device->devStatus & DEV_HIGH_SEC_STATUS) )
   \                     ??CrossCallReturnLabel_174:
   \   000024   EA           MOV     A,R2
   \   000025   2407         ADD     A,#0x7
   \   000027   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_149:
   \   00002A   A2E7         MOV     C,0xE0 /* A   */.7
   \   00002C   502E         JNC     ??ZDSecMgrDeviceJoinFwd_0
   2081            {
   2082              if ( device->devStatus & DEV_REJOIN_STATUS )
   \   00002E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000030   5021         JNC     ??ZDSecMgrDeviceJoinFwd_1
   2083              {
   2084                if ( device->secure == TRUE )
   \   000032   8A82         MOV     DPL,R2
   \   000034   8B83         MOV     DPH,R3
   \   000036   A3           INC     DPTR
   \   000037   A3           INC     DPTR
   \   000038   A3           INC     DPTR
   \   000039   A3           INC     DPTR
   \   00003A   A3           INC     DPTR
   \   00003B   A3           INC     DPTR
   \   00003C   E0           MOVX    A,@DPTR
   \   00003D   6401         XRL     A,#0x1
   \   00003F   7009         JNZ     ??ZDSecMgrDeviceJoinFwd_2
   2085                  req.status = APSME_UD_HIGH_SECURED_REJOIN;
   \   000041   7406         MOV     A,#0x6
   \   000043   12....       LCALL   ?XSTACK_DISP0_8
   \   000046   7404         MOV     A,#0x4
   \   000048   803D         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2086                else
   2087                  req.status = APSME_UD_HIGH_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_2:
   \   00004A   7406         MOV     A,#0x6
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   7407         MOV     A,#0x7
   \   000051   8034         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2088              }
   2089              else
   2090                req.status = APSME_UD_HIGH_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_1:
   \   000053   7406         MOV     A,#0x6
   \   000055   12....       LCALL   ?XSTACK_DISP0_8
   \   000058   7405         MOV     A,#0x5
   \   00005A   802B         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2091            }
   2092            else
   2093            {
   2094              if ( device->devStatus & DEV_REJOIN_STATUS )
   \                     ??ZDSecMgrDeviceJoinFwd_0:
   \   00005C   A2E6         MOV     C,0xE0 /* A   */.6
   \   00005E   5020         JNC     ??ZDSecMgrDeviceJoinFwd_4
   2095              {
   2096                if ( device->secure == TRUE )
   \   000060   8A82         MOV     DPL,R2
   \   000062   8B83         MOV     DPH,R3
   \   000064   A3           INC     DPTR
   \   000065   A3           INC     DPTR
   \   000066   A3           INC     DPTR
   \   000067   A3           INC     DPTR
   \   000068   A3           INC     DPTR
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   6401         XRL     A,#0x1
   \   00006D   7008         JNZ     ??ZDSecMgrDeviceJoinFwd_5
   2097                  req.status = APSME_UD_STANDARD_SECURED_REJOIN;
   \   00006F   7406         MOV     A,#0x6
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E4           CLR     A
   \   000075   8010         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2098                else
   2099                  req.status = APSME_UD_STANDARD_UNSECURED_REJOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_5:
   \   000077   7406         MOV     A,#0x6
   \   000079   12....       LCALL   ?XSTACK_DISP0_8
   \   00007C   7403         MOV     A,#0x3
   \   00007E   8007         SJMP    ??ZDSecMgrDeviceJoinFwd_3
   2100              }
   2101              else
   2102                req.status = APSME_UD_STANDARD_UNSECURED_JOIN;
   \                     ??ZDSecMgrDeviceJoinFwd_4:
   \   000080   7406         MOV     A,#0x6
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   7401         MOV     A,#0x1
   \                     ??ZDSecMgrDeviceJoinFwd_3:
   \   000087   F0           MOVX    @DPTR,A
   2103            }
   2104          
   2105            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2106              req.apsSecure = TRUE;
   2107            else
   2108              req.apsSecure = FALSE;
   \   000088   7407         MOV     A,#0x7
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   E4           CLR     A
   \   00008E   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   2109          
   2110            // send and APSME_UPDATE_DEVICE request to the trust center
   2111            status = APSME_UpdateDeviceReq( &req );
   2112          
   2113            return status;
   \                     ??CrossCallReturnLabel_158:
   \   000091   12....       LCALL   ??APSME_UpdateDeviceReq?relay
   \   000094   7408         MOV     A,#0x8
   \   000096   02....       LJMP    ??Subroutine87_0 & 0xFFFF
   2114          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine41:
   \   000000   F582         MOV     DPL,A
   \   000002   EB           MOV     A,R3
   \   000003                REQUIRE ??Subroutine95_0
   \   000003                ; // Fall through to label ??Subroutine95_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine95_0:
   \   000000   3400         ADDC    A,#0x0
   \   000002   F583         MOV     DPH,A
   \   000004   E0           MOVX    A,@DPTR
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine61 & 0xFFFF
   \                     ??CrossCallReturnLabel_96:
   \   000007   12....       LCALL   ?Subroutine49 & 0xFFFF
   \                     ??CrossCallReturnLabel_227:
   \   00000A   7404         MOV     A,#0x4
   \   00000C   22           RET
   2115          
   2116          /******************************************************************************
   2117           * @fn          ZDSecMgrDeviceNew
   2118           *
   2119           * @brief       Process a new device.
   2120           *
   2121           * @param       device - [in] ZDSecMgrDevice_t, device info
   2122           *
   2123           * @return      ZStatus_t
   2124           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2125          ZStatus_t ZDSecMgrDeviceNew( ZDSecMgrDevice_t* joiner )
   \                     ZDSecMgrDeviceNew:
   2126          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2127            ZStatus_t status;
   2128          
   2129            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2130            {
   2131              // try to join this device
   2132              status = ZDSecMgrDeviceJoinDirect( joiner );
   2133            }
   2134            else
   2135            {
   2136              status = ZDSecMgrDeviceJoinFwd( joiner );
   2137            }
   2138          
   2139            return status;
   \   000004                ; Setup parameters for call to function ZDSecMgrDeviceJoinFwd
   \   000004   12....       LCALL   ??ZDSecMgrDeviceJoinFwd?relay
   \   000007   80..         SJMP    ??Subroutine97_0
   2140          }
   2141          
   2142          /******************************************************************************
   2143           * @fn          ZDSecMgrAssocDeviceAuth
   2144           *
   2145           * @brief       Set associated device status to authenticated
   2146           *
   2147           * @param       assoc - [in, out] associated_devices_t
   2148           *
   2149           * @return      none
   2150           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2151          void ZDSecMgrAssocDeviceAuth( associated_devices_t* assoc )
   \                     ZDSecMgrAssocDeviceAuth:
   2152          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2153            if ( assoc != NULL )
   \   000004   EA           MOV     A,R2
   \   000005   7001         JNZ     ??ZDSecMgrAssocDeviceAuth_0
   \   000007   EB           MOV     A,R3
   \                     ??ZDSecMgrAssocDeviceAuth_0:
   \   000008   600D         JZ      ??ZDSecMgrAssocDeviceAuth_1
   2154            {
   2155              assoc->devStatus |= DEV_SEC_AUTH_STATUS;
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   D2E3         SETB    0xE0 /* A   */.3
   \   000016   F0           MOVX    @DPTR,A
   2156            }
   2157          }
   \                     ??ZDSecMgrAssocDeviceAuth_1:
   \   000017   80..         SJMP    ??Subroutine97_0
   2158          
   2159          /******************************************************************************
   2160           * @fn          ZDSecMgrAuthInitiate
   2161           *
   2162           * @brief       Initiate entity authentication
   2163           *
   2164           * @param       responder - [in] responder EXT address
   2165           *
   2166           * @return      none
   2167           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2168          void ZDSecMgrAuthInitiate( uint8* responder )
   \                     ZDSecMgrAuthInitiate:
   2169          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 7
   \   000005   74F9         MOV     A,#-0x7
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2170            APSME_AuthenticateReq_t req;
   2171          
   2172          
   2173            // make sure NWK address is available
   2174            if ( APSME_LookupNwkAddr( responder, &req.nwkAddr ) )
   \   00000E                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   601F         JZ      ??ZDSecMgrAuthInitiate_0
   2175            {
   2176              // set request fields
   2177              req.extAddr   = responder;
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   F0           MOVX    @DPTR,A
   2178              req.action    = APSME_EA_INITIATE;
   \   000028   7406         MOV     A,#0x6
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   E4           CLR     A
   \   00002E   F0           MOVX    @DPTR,A
   2179              req.challenge = NULL;
   \   00002F   7404         MOV     A,#0x4
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E4           CLR     A
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   2180          
   2181              // start EA processing
   2182              APSME_AuthenticateReq( &req );
   2183            }
   \                     ??CrossCallReturnLabel_159:
   \   00003A   12....       LCALL   ??APSME_AuthenticateReq?relay
   2184          }
   \                     ??ZDSecMgrAuthInitiate_0:
   \   00003D   7407         MOV     A,#0x7
   \   00003F   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2185          
   2186          /******************************************************************************
   2187           * @fn          ZDSecMgrAuthNwkKey
   2188           *
   2189           * @brief       Handle next step in authentication process
   2190           *
   2191           * @param       none
   2192           *
   2193           * @return      none
   2194           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2195          void ZDSecMgrAuthNwkKey()
   \                     ZDSecMgrAuthNwkKey:
   2196          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2197            if ( devState == DEV_END_DEVICE_UNAUTH )
   \   000004   90....       MOV     DPTR,#devState
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6405         XRL     A,#0x5
   \   00000A   700C         JNZ     ??ZDSecMgrAuthNwkKey_0
   2198            {
   2199              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2200              {
   2201                uint8 parent[Z_EXTADDR_LEN];
   2202          
   2203                // get parent's EXT address
   2204                NLME_GetCoordExtAddr( parent );
   2205          
   2206                // begin entity authentication with parent
   2207                ZDSecMgrAuthInitiate( parent );
   2208              }
   2209              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2210              {
   2211                // inform ZDO that device has been authenticated
   2212                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00000C                ; Setup parameters for call to function osal_set_event
   \   00000C   7A80         MOV     R2,#-0x80
   \   00000E   7B00         MOV     R3,#0x0
   \   000010   90....       MOV     DPTR,#ZDAppTaskID
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F9           MOV     R1,A
   \   000015   12....       LCALL   ??osal_set_event?relay
   2213              }
   2214            }
   2215          }
   \                     ??ZDSecMgrAuthNwkKey_0:
   \   000018   80..         SJMP    ??Subroutine97_0
   2216          
   2217          /******************************************************************************
   2218           * PUBLIC FUNCTIONS
   2219           */
   2220          /******************************************************************************
   2221           * @fn          ZDSecMgrInit
   2222           *
   2223           * @brief       Initialize ZigBee Device Security Manager.
   2224           *
   2225           * @param       none
   2226           *
   2227           * @return      none
   2228           */
   2229          #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2230          void ZDSecMgrAddrMgrCB( uint8 update, AddrMgrEntry_t* newEntry, AddrMgrEntry_t* oldEntry );
   2231          void ZDSecMgrAddrMgrCB( uint8           update,
   2232                                  AddrMgrEntry_t* newEntry,
   2233                                  AddrMgrEntry_t* oldEntry )
   2234          {
   2235            (void)update;
   2236            (void)newEntry;
   2237            (void)oldEntry;
   2238          }
   2239          #endif // ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2240          
   2241          void ZDSecMgrInit( void )
   \                     ZDSecMgrInit:
   \   000000                REQUIRE ?Subroutine76
   \   000000                ; // Fall through to label ?Subroutine76

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine76:
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   \   000004                ; Setup parameters for call to function APSME_SecurityNM
   \   000004   12....       LCALL   ??APSME_SecurityNM?relay
   \   000007   80..         SJMP    ??Subroutine97_0
   2242          {
   2243            if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2244                || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2245            {
   2246              // initialize sub modules
   2247              ZDSecMgrMasterKeyInit();
   2248              ZDSecMgrEntryInit();
   2249          
   2250              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2251              {
   2252                ZDSecMgrCtrlInit();
   2253              }
   2254          
   2255              // register with Address Manager
   2256              #if ( ADDRMGR_CALLBACK_ENABLED == 1 )
   2257              AddrMgrRegister( ADDRMGR_REG_SECURITY, ZDSecMgrAddrMgrCB );
   2258              #endif
   2259            }
   2260          
   2261            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2262            {
   2263              // configure SKA slot data
   2264              APSME_SKA_SlotInit( ZDSECMGR_SKA_SLOT_MAX );
   2265            }
   2266            else if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD )
   2267            {
   2268              // Setup the preconfig Trust Center Link Key
   2269              TrustCenterLinkKey.key = zgPreConfigTCLinkKey;
   2270              TrustCenterLinkKey.txFrmCntr = 0;
   2271              TrustCenterLinkKey.rxFrmCntr = 0;
   2272          #if defined ( NV_RESTORE )
   2273              if ( osal_nv_item_init( ZCD_NV_SECURE_TCLINKKEY_TXFRAME, sizeof(uint32), &(TrustCenterLinkKey.txFrmCntr) ) == ZSUCCESS )
   2274              {
   2275                osal_nv_read( ZCD_NV_SECURE_TCLINKKEY_TXFRAME, 0, sizeof(uint32), &(TrustCenterLinkKey.txFrmCntr) );
   2276              }
   2277              if ( osal_nv_item_init( ZCD_NV_SECURE_TCLINKKEY_RXFRAME, sizeof(uint32), &(TrustCenterLinkKey.rxFrmCntr) ) == ZSUCCESS )
   2278              {
   2279                osal_nv_read( ZCD_NV_SECURE_TCLINKKEY_RXFRAME, 0, sizeof(uint32), &(TrustCenterLinkKey.rxFrmCntr) );
   2280              }
   2281          #endif
   2282              APSME_TCLinkKeySetup( 0x0000, &TrustCenterLinkKey );
   2283            }
   2284          
   2285            if ( ZG_SECURE_ENABLED )
   2286            {
   2287              if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2288              {
   2289                // setup joining permissions
   2290                ZDSecMgrPermitJoiningEnabled = TRUE;
   2291                ZDSecMgrPermitJoiningTimed   = FALSE;
   2292              }
   2293            }
   2294          
   2295            // configure security based on security mode and type of device
   2296            ZDSecMgrConfig();
   2297          }
   2298          
   2299          /******************************************************************************
   2300           * @fn          ZDSecMgrConfig
   2301           *
   2302           * @brief       Configure ZigBee Device Security Manager.
   2303           *
   2304           * @param       none
   2305           *
   2306           * @return      none
   2307           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2308          void ZDSecMgrConfig( void )
   \                     ZDSecMgrConfig:
   \   000000   80..         SJMP    ?Subroutine76
   2309          {
   2310            if ( ZG_SECURE_ENABLED )
   2311            {
   2312              SSP_Init();
   2313          
   2314              if ( (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH)
   2315                  || (ZG_CHECK_SECURITY_MODE == ZG_SECURITY_SE_STANDARD) )
   2316              {
   2317                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2318                {
   2319                  // COMMERCIAL MODE - COORDINATOR DEVICE
   2320                  APSME_SecurityCM_CD();
   2321                }
   2322                else if ( ZSTACK_ROUTER_BUILD )
   2323                {
   2324                  // COMMERCIAL MODE - ROUTER DEVICE
   2325                  APSME_SecurityCM_RD();
   2326                }
   2327                else
   2328                {
   2329                  // COMMERCIAL MODE - END DEVICE
   2330                  APSME_SecurityCM_ED();
   2331                }
   2332              }
   2333              else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   2334              {
   2335                if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2336                {
   2337                  // RESIDENTIAL MODE - COORDINATOR DEVICE
   2338                  APSME_SecurityRM_CD();
   2339                }
   2340                else if ( ZSTACK_ROUTER_BUILD )
   2341                {
   2342                  // RESIDENTIAL MODE - ROUTER DEVICE
   2343                  APSME_SecurityRM_RD();
   2344                }
   2345                else
   2346                {
   2347                  // RESIDENTIAL MODE - END DEVICE
   2348                  APSME_SecurityRM_ED();
   2349                }
   2350              }
   2351            }
   2352            else
   2353            {
   2354              // NO SECURITY
   2355              APSME_SecurityNM();
   2356            }
   2357          }
   2358          
   2359          /******************************************************************************
   2360           * @fn          ZDSecMgrPermitJoining
   2361           *
   2362           * @brief       Process request to change joining permissions.
   2363           *
   2364           * @param       duration - [in] timed duration for join in seconds
   2365           *                         - 0x00 not allowed
   2366           *                         - 0xFF allowed without timeout
   2367           *
   2368           * @return      uint8 - success(TRUE:FALSE)
   2369           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2370          uint8 ZDSecMgrPermitJoining( uint8 duration )
   \                     ZDSecMgrPermitJoining:
   2371          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2372            uint8 accept;
   2373          
   2374          
   2375            ZDSecMgrPermitJoiningTimed = FALSE;
   \   000004   E4           CLR     A
   \   000005   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000008   F0           MOVX    @DPTR,A
   2376          
   2377            if ( duration > 0 )
   \   000009   E9           MOV     A,R1
   \   00000A   6012         JZ      ??ZDSecMgrPermitJoining_0
   2378            {
   2379              ZDSecMgrPermitJoiningEnabled = TRUE;
   \   00000C   7401         MOV     A,#0x1
   \   00000E   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000011   F0           MOVX    @DPTR,A
   2380          
   2381              if ( duration != 0xFF )
   \   000012   74FF         MOV     A,#-0x1
   \   000014   69           XRL     A,R1
   \   000015   600C         JZ      ??ZDSecMgrPermitJoining_1
   2382              {
   2383                ZDSecMgrPermitJoiningTimed = TRUE;
   \   000017   7401         MOV     A,#0x1
   \   000019   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   00001C   8004         SJMP    ??ZDSecMgrPermitJoining_2
   2384              }
   2385            }
   2386            else
   2387            {
   2388              ZDSecMgrPermitJoiningEnabled = FALSE;
   \                     ??ZDSecMgrPermitJoining_0:
   \   00001E   E4           CLR     A
   \   00001F   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \                     ??ZDSecMgrPermitJoining_2:
   \   000022   F0           MOVX    @DPTR,A
   2389            }
   2390          
   2391            accept = TRUE;
   2392          
   2393            return accept;
   \                     ??ZDSecMgrPermitJoining_1:
   \   000023   7901         MOV     R1,#0x1
   \   000025   02....       LJMP    ??Subroutine97_0 & 0xFFFF
   2394          }
   2395          
   2396          /******************************************************************************
   2397           * @fn          ZDSecMgrPermitJoiningTimeout
   2398           *
   2399           * @brief       Process permit joining timeout
   2400           *
   2401           * @param       none
   2402           *
   2403           * @return      none
   2404           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2405          void ZDSecMgrPermitJoiningTimeout( void )
   \                     ZDSecMgrPermitJoiningTimeout:
   2406          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2407            if ( ZDSecMgrPermitJoiningTimed == TRUE )
   \   000004   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000007   E0           MOVX    A,@DPTR
   \   000008   6401         XRL     A,#0x1
   \   00000A   7009         JNZ     ??ZDSecMgrPermitJoiningTimeout_0
   2408            {
   2409              ZDSecMgrPermitJoiningEnabled = FALSE;
   \   00000C   E4           CLR     A
   \   00000D   90....       MOV     DPTR,#ZDSecMgrPermitJoiningEnabled
   \   000010   F0           MOVX    @DPTR,A
   2410              ZDSecMgrPermitJoiningTimed   = FALSE;
   \   000011   90....       MOV     DPTR,#ZDSecMgrPermitJoiningTimed
   \   000014   F0           MOVX    @DPTR,A
   2411            }
   2412          }
   \                     ??ZDSecMgrPermitJoiningTimeout_0:
   \   000015   02....       LJMP    ??Subroutine97_0 & 0xFFFF
   2413          
   2414          /******************************************************************************
   2415           * @fn          ZDSecMgrNewDeviceEvent
   2416           *
   2417           * @brief       Process a the new device event, if found reset new device
   2418           *              event/timer.
   2419           *
   2420           * @param       none
   2421           *
   2422           * @return      uint8 - found(TRUE:FALSE)
   2423           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2424          uint8 ZDSecMgrNewDeviceEvent( void )
   \                     ZDSecMgrNewDeviceEvent:
   2425          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2426            uint8                 found;
   2427            ZDSecMgrDevice_t      device;
   2428            AddrMgrEntry_t        addrEntry;
   2429            associated_devices_t* assoc;
   2430            ZStatus_t             status;
   2431          
   2432            // initialize return results
   2433            found = FALSE;
   \   00000A   75..00       MOV     ?V0 + 0,#0x0
   2434          
   2435            // look for device in the security init state
   2436            assoc = AssocMatchDeviceStatus( DEV_SEC_INIT_STATUS );
   \   00000D                ; Setup parameters for call to function AssocMatchDeviceStatus
   \   00000D   7904         MOV     R1,#0x4
   \   00000F   12....       LCALL   ??AssocMatchDeviceStatus?relay
   \   000012   8A..         MOV     ?V0 + 2,R2
   \   000014   8B..         MOV     ?V0 + 3,R3
   \   000016   AE..         MOV     R6,?V0 + 2
   \   000018   AF..         MOV     R7,?V0 + 3
   2437          
   2438            if ( assoc != NULL )
   \   00001A   EE           MOV     A,R6
   \   00001B   7001         JNZ     ??ZDSecMgrNewDeviceEvent_0
   \   00001D   EF           MOV     A,R7
   \                     ??ZDSecMgrNewDeviceEvent_0:
   \   00001E   7003         JNZ     $+5
   \   000020   02....       LJMP    ??ZDSecMgrNewDeviceEvent_1 & 0xFFFF
   2439            {
   2440              // device found
   2441              found = TRUE;
   \   000023   75..01       MOV     ?V0 + 0,#0x1
   2442          
   2443              // check for preconfigured security
   2444              if ( zgPreConfigKeys == TRUE )
   \   000026   90....       MOV     DPTR,#zgPreConfigKeys
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   6401         XRL     A,#0x1
   \   00002C   7003         JNZ     ??ZDSecMgrNewDeviceEvent_2
   2445              {
   2446                // set association status to authenticated
   2447                ZDSecMgrAssocDeviceAuth( assoc );
   \   00002E                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   00002E   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   2448              }
   2449          
   2450              // set up device info
   2451              addrEntry.user  = ADDRMGR_USER_DEFAULT;
   \                     ??ZDSecMgrNewDeviceEvent_2:
   \   000031   740A         MOV     A,#0xa
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   E4           CLR     A
   \   000037   F0           MOVX    @DPTR,A
   2452              addrEntry.index = assoc->addrIdx;
   \   000038   8E82         MOV     DPL,R6
   \   00003A   8F83         MOV     DPH,R7
   \   00003C   12....       LCALL   ??Subroutine109_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_221:
   \   00003F   7415         MOV     A,#0x15
   \   000041   12....       LCALL   ?XSTACK_DISP0_8
   \   000044   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   2453              AddrMgrEntryGet( &addrEntry );
   \                     ??CrossCallReturnLabel_199:
   \   000047   12....       LCALL   ?XSTACK_DISP0_8
   \   00004A   AA82         MOV     R2,DPL
   \   00004C   AB83         MOV     R3,DPH
   \   00004E   12....       LCALL   ??AddrMgrEntryGet?relay
   2454          
   2455              device.nwkAddr    = assoc->shortAddr;
   \   000051   8E82         MOV     DPL,R6
   \   000053   8F83         MOV     DPH,R7
   \   000055   12....       LCALL   ?Subroutine16 & 0xFFFF
   2456              device.extAddr    = addrEntry.extAddr;
   \                     ??CrossCallReturnLabel_181:
   \   000058   740D         MOV     A,#0xd
   \   00005A   12....       LCALL   ?XSTACK_DISP0_8
   \   00005D   A882         MOV     R0,DPL
   \   00005F   A983         MOV     R1,DPH
   \   000061   7402         MOV     A,#0x2
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   2457              device.parentAddr = NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_175:
   \   000069                ; Setup parameters for call to function NLME_GetShortAddr
   \   000069   12....       LCALL   ??NLME_GetShortAddr?relay
   \   00006C   7404         MOV     A,#0x4
   \   00006E   12....       LCALL   ?XSTACK_DISP0_8
   \   000071   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   2458              device.secure     = FALSE;
   \                     ??CrossCallReturnLabel_190:
   \   000074   7406         MOV     A,#0x6
   \   000076   12....       LCALL   ?XSTACK_DISP0_8
   \   000079   E4           CLR     A
   \   00007A   F0           MOVX    @DPTR,A
   2459              device.devStatus  = assoc->devStatus;
   \   00007B   EE           MOV     A,R6
   \   00007C   2405         ADD     A,#0x5
   \   00007E   FE           MOV     R6,A
   \   00007F   EF           MOV     A,R7
   \   000080   3400         ADDC    A,#0x0
   \   000082   FF           MOV     R7,A
   \   000083   8E82         MOV     DPL,R6
   \   000085   8F83         MOV     DPH,R7
   \   000087   E0           MOVX    A,@DPTR
   \   000088   C0E0         PUSH    A
   \   00008A   7407         MOV     A,#0x7
   \   00008C   12....       LCALL   ?XSTACK_DISP0_8
   \   00008F   D0E0         POP     A
   \   000091   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   2460          
   2461              // process new device
   2462              status = ZDSecMgrDeviceNew( &device );
   \                     ??CrossCallReturnLabel_160:
   \   000094   12....       LCALL   ??ZDSecMgrDeviceNew?relay
   \   000097   E9           MOV     A,R1
   \   000098   FA           MOV     R2,A
   2463          
   2464              if ( status == ZSuccess )
   \   000099   700A         JNZ     ??ZDSecMgrNewDeviceEvent_3
   2465              {
   2466                assoc->devStatus &= ~DEV_SEC_INIT_STATUS;
   \   00009B   8E82         MOV     DPL,R6
   \   00009D   8F83         MOV     DPH,R7
   \   00009F   E0           MOVX    A,@DPTR
   \   0000A0   C2E2         CLR     0xE0 /* A   */.2
   \   0000A2   F0           MOVX    @DPTR,A
   \   0000A3   8011         SJMP    ??ZDSecMgrNewDeviceEvent_1
   2467              }
   2468              else if ( status == ZNwkUnknownDevice )
   \                     ??ZDSecMgrNewDeviceEvent_3:
   \   0000A5   74C8         MOV     A,#-0x38
   \   0000A7   6A           XRL     A,R2
   \   0000A8   700C         JNZ     ??ZDSecMgrNewDeviceEvent_1
   2469              {
   2470                AssocRemove( addrEntry.extAddr );
   \   0000AA                ; Setup parameters for call to function AssocRemove
   \   0000AA   740D         MOV     A,#0xd
   \   0000AC   12....       LCALL   ?XSTACK_DISP0_8
   \   0000AF   AA82         MOV     R2,DPL
   \   0000B1   AB83         MOV     R3,DPH
   \   0000B3   12....       LCALL   ??AssocRemove?relay
   2471              }
   2472            }
   2473          
   2474            return found;
   \                     ??ZDSecMgrNewDeviceEvent_1:
   \   0000B6   A9..         MOV     R1,?V0 + 0
   \   0000B8   7417         MOV     A,#0x17
   \   0000BA   02....       LJMP    ??Subroutine106_0 & 0xFFFF
   2475          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine16:
   \   000000   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_224:
   \   000003                REQUIRE ??Subroutine99_0
   \   000003                ; // Fall through to label ??Subroutine99_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine99_0:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006                REQUIRE ??Subroutine100_0
   \   000006                ; // Fall through to label ??Subroutine100_0
   2476          
   2477          /******************************************************************************
   2478           * @fn          ZDSecMgrEvent
   2479           *
   2480           * @brief       Handle ZDO Security Manager event/timer(ZDO_SECMGR_EVENT).
   2481           *
   2482           * @param       none
   2483           *
   2484           * @return      none
   2485           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2486          void ZDSecMgrEvent( void )
   \                     ZDSecMgrEvent:
   2487          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 23
   \   000005   74E9         MOV     A,#-0x17
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2488            uint8            action;
   2489            uint8            restart;
   2490            uint16           index;
   2491            AddrMgrEntry_t   entry;
   2492            ZDSecMgrDevice_t device;
   2493          
   2494          
   2495            // verify data is available
   2496            if ( ZDSecMgrCtrlData != NULL )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7002         JNZ     ??ZDSecMgrEvent_0
   \   000010   A3           INC     DPTR
   \   000011   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrEvent_0:
   \   000012   7003         JNZ     $+5
   \   000014   02....       LJMP    ??ZDSecMgrEvent_1 & 0xFFFF
   2497            {
   2498              action  = FALSE;
   \   000017   75..00       MOV     ?V0 + 0,#0x0
   2499              restart = FALSE;
   \   00001A   75..00       MOV     ?V0 + 1,#0x0
   2500          
   2501              // update all the counters
   2502              for ( index = 0; index < ZDSECMGR_ENTRY_MAX; index++ )
   \   00001D   7E00         MOV     R6,#0x0
   \   00001F   7F00         MOV     R7,#0x0
   2503              {
   2504                if ( ZDSecMgrCtrlData[index].state !=  ZDSECMGR_CTRL_NONE )
   \                     ??ZDSecMgrEvent_2:
   \   000021   EE           MOV     A,R6
   \   000022   F8           MOV     R0,A
   \   000023   EF           MOV     A,R7
   \   000024   F9           MOV     R1,A
   \   000025   E8           MOV     A,R0
   \   000026   75F007       MOV     B,#0x7
   \   000029   A4           MUL     AB
   \   00002A   F8           MOV     R0,A
   \   00002B   AAF0         MOV     R2,B
   \   00002D   75F007       MOV     B,#0x7
   \   000030   E9           MOV     A,R1
   \   000031   A4           MUL     AB
   \   000032   2A           ADD     A,R2
   \   000033   F9           MOV     R1,A
   \   000034   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000037   E0           MOVX    A,@DPTR
   \   000038   28           ADD     A,R0
   \   000039   FA           MOV     R2,A
   \   00003A   A3           INC     DPTR
   \   00003B   E0           MOVX    A,@DPTR
   \   00003C   39           ADDC    A,R1
   \   00003D   FB           MOV     R3,A
   \   00003E   8A82         MOV     DPL,R2
   \   000040   8B83         MOV     DPH,R3
   \   000042   A3           INC     DPTR
   \   000043   A3           INC     DPTR
   \   000044   A3           INC     DPTR
   \   000045   A3           INC     DPTR
   \   000046   A3           INC     DPTR
   \   000047   E0           MOVX    A,@DPTR
   \   000048   7003         JNZ     $+5
   \   00004A   02....       LJMP    ??ZDSecMgrEvent_3 & 0xFFFF
   2505                {
   2506                  if ( ZDSecMgrCtrlData[index].cntr != 0 )
   \   00004D   EA           MOV     A,R2
   \   00004E   2406         ADD     A,#0x6
   \   000050   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_150:
   \   000053   6002         JZ      ??ZDSecMgrEvent_4
   2507                  {
   2508                    ZDSecMgrCtrlData[index].cntr--;
   \   000055   14           DEC     A
   \   000056   F0           MOVX    @DPTR,A
   2509                  }
   2510          
   2511                  if ( ( action == FALSE ) && ( ZDSecMgrCtrlData[index].cntr == 0 ) )
   \                     ??ZDSecMgrEvent_4:
   \   000057   E5..         MOV     A,?V0 + 0
   \   000059   6003         JZ      $+5
   \   00005B   02....       LJMP    ??ZDSecMgrEvent_5 & 0xFFFF
   \   00005E   90....       MOV     DPTR,#ZDSecMgrCtrlData
   \   000061   E0           MOVX    A,@DPTR
   \   000062   28           ADD     A,R0
   \   000063   F8           MOV     R0,A
   \   000064   A3           INC     DPTR
   \   000065   E0           MOVX    A,@DPTR
   \   000066   39           ADDC    A,R1
   \   000067   F9           MOV     R1,A
   \   000068   8882         MOV     DPL,R0
   \   00006A   8983         MOV     DPH,R1
   \   00006C   A3           INC     DPTR
   \   00006D   A3           INC     DPTR
   \   00006E   A3           INC     DPTR
   \   00006F   A3           INC     DPTR
   \   000070   A3           INC     DPTR
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   706D         JNZ     ??ZDSecMgrEvent_5
   2512                  {
   2513                    action = TRUE;
   \   000075   75..01       MOV     ?V0 + 0,#0x1
   2514          
   2515                    // update from control data
   2516                    device.parentAddr = ZDSecMgrCtrlData[index].parentAddr;
   \   000078   8882         MOV     DPL,R0
   \   00007A   8983         MOV     DPH,R1
   \   00007C   A3           INC     DPTR
   \   00007D   A3           INC     DPTR
   \   00007E   12....       LCALL   ??Subroutine94_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_139:
   \   000081   7404         MOV     A,#0x4
   \   000083   12....       LCALL   ?XSTACK_DISP0_8
   \   000086   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   2517                    device.secure     = ZDSecMgrCtrlData[index].secure;
   \                     ??CrossCallReturnLabel_191:
   \   000089   8882         MOV     DPL,R0
   \   00008B   8983         MOV     DPH,R1
   \   00008D   A3           INC     DPTR
   \   00008E   A3           INC     DPTR
   \   00008F   A3           INC     DPTR
   \   000090   A3           INC     DPTR
   \   000091   E0           MOVX    A,@DPTR
   \   000092   C0E0         PUSH    A
   \   000094   7406         MOV     A,#0x6
   \   000096   12....       LCALL   ?XSTACK_DISP0_8
   \   000099   D0E0         POP     A
   \   00009B   F0           MOVX    @DPTR,A
   2518                    device.ctrl       = &ZDSecMgrCtrlData[index];
   \   00009C   7408         MOV     A,#0x8
   \   00009E   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A1   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   2519          
   2520                    // set the user and address index
   2521                    entry.user  = ADDRMGR_USER_SECURITY;
   \                     ??CrossCallReturnLabel_200:
   \   0000A4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A7   7402         MOV     A,#0x2
   \   0000A9   F0           MOVX    @DPTR,A
   2522                    entry.index = ZDSecMgrCtrlData[index].entry->ami;
   \   0000AA   8882         MOV     DPL,R0
   \   0000AC   8983         MOV     DPH,R1
   \   0000AE   12....       LCALL   ?Subroutine25 & 0xFFFF
   \                     ??CrossCallReturnLabel_92:
   \   0000B1   F9           MOV     R1,A
   \   0000B2   7415         MOV     A,#0x15
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   12....       LCALL   ??Subroutine105_0 & 0xFFFF
   2523          
   2524                    // get the address data
   2525                    AddrMgrEntryGet( &entry );
   \                     ??CrossCallReturnLabel_201:
   \   0000BA   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BD   AA82         MOV     R2,DPL
   \   0000BF   AB83         MOV     R3,DPH
   \   0000C1   12....       LCALL   ??AddrMgrEntryGet?relay
   2526          
   2527                    // set device address data
   2528                    device.nwkAddr = entry.nwkAddr;
   \   0000C4   740B         MOV     A,#0xb
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   12....       LCALL   ?Subroutine16 & 0xFFFF
   2529                    device.extAddr = entry.extAddr;
   \                     ??CrossCallReturnLabel_182:
   \   0000CC   740D         MOV     A,#0xd
   \   0000CE   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D1   A882         MOV     R0,DPL
   \   0000D3   A983         MOV     R1,DPH
   \   0000D5   7402         MOV     A,#0x2
   \   0000D7   12....       LCALL   ?XSTACK_DISP0_8
   \   0000DA   12....       LCALL   ?Subroutine0 & 0xFFFF
   2530          
   2531                    // update from entry data
   2532                    ZDSecMgrDeviceCtrlHandler( &device );
   2533                  }
   \                     ??CrossCallReturnLabel_0:
   \   0000DD   12....       LCALL   ??ZDSecMgrDeviceCtrlHandler?relay
   \   0000E0   8003         SJMP    ??ZDSecMgrEvent_3
   2534                  else
   2535                  {
   2536                    restart = TRUE;
   \                     ??ZDSecMgrEvent_5:
   \   0000E2   75..01       MOV     ?V0 + 1,#0x1
   2537                  }
   2538                }
   2539              }
   \                     ??ZDSecMgrEvent_3:
   \   0000E5   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_57:
   \   0000E8   5003         JNC     $+5
   \   0000EA   02....       LJMP    ??ZDSecMgrEvent_2 & 0xFFFF
   2540          
   2541              // check for timer restart
   2542              if ( restart == TRUE )
   \   0000ED   7401         MOV     A,#0x1
   \   0000EF   65..         XRL     A,?V0 + 1
   \   0000F1   7010         JNZ     ??ZDSecMgrEvent_1
   2543              {
   2544                osal_start_timerEx(ZDAppTaskID, ZDO_SECMGR_EVENT, 100 );
   \   0000F3                ; Setup parameters for call to function osal_start_timerEx
   \   0000F3   7C64         MOV     R4,#0x64
   \   0000F5   7D00         MOV     R5,#0x0
   \   0000F7   7A00         MOV     R2,#0x0
   \   0000F9   7B01         MOV     R3,#0x1
   \   0000FB   90....       MOV     DPTR,#ZDAppTaskID
   \   0000FE   E0           MOVX    A,@DPTR
   \   0000FF   F9           MOV     R1,A
   \   000100   12....       LCALL   ??osal_start_timerEx?relay
   2545              }
   2546            }
   2547          }
   \                     ??ZDSecMgrEvent_1:
   \   000103   7417         MOV     A,#0x17
   \   000105   80..         SJMP    ??Subroutine103_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E8           MOV     A,R0
   \   000001   F0           MOVX    @DPTR,A
   \   000002   A3           INC     DPTR
   \   000003   E9           MOV     A,R1
   \   000004   12....       LCALL   ?Subroutine58 & 0xFFFF
   \                     ??CrossCallReturnLabel_164:
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine40:
   \   000000   EE           MOV     A,R6
   \   000001   2401         ADD     A,#0x1
   \   000003   0E           INC     R6
   \   000004   EF           MOV     A,R7
   \   000005   3400         ADDC    A,#0x0
   \   000007   FF           MOV     R7,A
   \   000008   C3           CLR     C
   \   000009   EE           MOV     A,R6
   \   00000A   9403         SUBB    A,#0x3
   \   00000C   EF           MOV     A,R7
   \   00000D   9400         SUBB    A,#0x0
   \   00000F   22           RET
   2548          
   2549          /******************************************************************************
   2550           * @fn          ZDSecMgrEstablishKeyCfm
   2551           *
   2552           * @brief       Process the ZDO_EstablishKeyCfm_t message.
   2553           *
   2554           * @param       cfm - [in] ZDO_EstablishKeyCfm_t confirmation
   2555           *
   2556           * @return      none
   2557           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2558          void ZDSecMgrEstablishKeyCfm( ZDO_EstablishKeyCfm_t* cfm )
   \                     ZDSecMgrEstablishKeyCfm:
   2559          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   2560            // send the NWK key
   2561            if ( ( ZG_BUILD_COORDINATOR_TYPE ) && ( ZG_DEVICE_COORDINATOR_TYPE ) )
   2562            {
   2563              // update control for specified EXT address
   2564              ZDSecMgrDeviceCtrlUpdate( cfm->partExtAddr, ZDSECMGR_CTRL_SKKE_DONE );
   2565            }
   2566            else
   2567            {
   2568              // this should be done when receiving the NWK key
   2569              // if devState ==
   2570              //if ( devState == DEV_END_DEVICE_UNAUTH )
   2571                  //osal_set_event( ZDAppTaskID, ZDO_DEVICE_AUTH );
   2572          
   2573              // if not in joining state -- this should trigger an event for an
   2574              // end point that requested SKKE
   2575              // if ( devState == DEV_END_DEVICE )
   2576             //       devState == DEV_ROUTER;
   2577          
   2578            }
   2579          }
   \   000000   02....       LJMP    ?BRET
   2580          
   2581          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2582          uint8 ZDSecMgrTCExtAddrCheck( uint8* extAddr )
   \                     ZDSecMgrTCExtAddrCheck:
   2583          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 8
   \   000005   74F8         MOV     A,#-0x8
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2584            uint8  match;
   2585            uint8  lookup[Z_EXTADDR_LEN];
   2586          
   2587            match = FALSE;
   \   00000E   75..00       MOV     ?V0 + 0,#0x0
   2588          
   2589            if ( AddrMgrExtAddrLookup( APSME_TRUSTCENTER_NWKADDR, lookup ) )
   \   000011                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000011   85..82       MOV     DPL,?XSP + 0
   \   000014   85..83       MOV     DPH,?XSP + 1
   \   000017   AC82         MOV     R4,DPL
   \   000019   AD83         MOV     R5,DPH
   \   00001B   7A00         MOV     R2,#0x0
   \   00001D   7B00         MOV     R3,#0x0
   \   00001F   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000022   E9           MOV     A,R1
   \   000023   6014         JZ      ??ZDSecMgrTCExtAddrCheck_0
   2590            {
   2591              match = AddrMgrExtAddrEqual( lookup, extAddr );
   \   000025                ; Setup parameters for call to function AddrMgrExtAddrEqual
   \   000025   EE           MOV     A,R6
   \   000026   FC           MOV     R4,A
   \   000027   EF           MOV     A,R7
   \   000028   FD           MOV     R5,A
   \   000029   85..82       MOV     DPL,?XSP + 0
   \   00002C   85..83       MOV     DPH,?XSP + 1
   \   00002F   AA82         MOV     R2,DPL
   \   000031   AB83         MOV     R3,DPH
   \   000033   12....       LCALL   ??AddrMgrExtAddrEqual?relay
   \   000036   E9           MOV     A,R1
   \   000037   F5..         MOV     ?V0 + 0,A
   2592            }
   2593          
   2594            return match;
   \                     ??ZDSecMgrTCExtAddrCheck_0:
   \   000039   A9..         MOV     R1,?V0 + 0
   \   00003B   7408         MOV     A,#0x8
   \   00003D   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2595          }
   2596          
   2597          void ZDSecMgrTCDataLoad( uint8* extAddr );

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2598          void ZDSecMgrTCDataLoad( uint8* extAddr )
   \                     ZDSecMgrTCDataLoad:
   2599          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2600            uint16 ami;
   2601            uint8* key;
   2602          
   2603            if ( !ZDSecMgrTCDataLoaded )
   \   00000A   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   7043         JNZ     ??ZDSecMgrTCDataLoad_0
   2604            {
   2605              if ( ZDSecMgrAddrStore( APSME_TRUSTCENTER_NWKADDR, extAddr, &ami ) == ZSuccess )
   \   000010                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   000010   85..82       MOV     DPL,?XSP + 0
   \   000013   85..83       MOV     DPH,?XSP + 1
   \   000016   8582..       MOV     ?V0 + 0,DPL
   \   000019   8583..       MOV     ?V0 + 1,DPH
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000021   EA           MOV     A,R2
   \   000022   FC           MOV     R4,A
   \   000023   EB           MOV     A,R3
   \   000024   FD           MOV     R5,A
   \   000025   7A00         MOV     R2,#0x0
   \   000027   7B00         MOV     R3,#0x0
   \   000029   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002C   7402         MOV     A,#0x2
   \   00002E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000031   E9           MOV     A,R1
   \   000032   7019         JNZ     ??CrossCallReturnLabel_43
   2606              {
   2607                // if preconfigured load key
   2608                if ( zgPreConfigKeys == TRUE )
   \   000034   90....       MOV     DPTR,#zgPreConfigKeys
   \   000037   E0           MOVX    A,@DPTR
   \   000038   6401         XRL     A,#0x1
   \   00003A   7011         JNZ     ??CrossCallReturnLabel_43
   2609                {
   2610                  if ( ZDSecMgrMasterKeyLookup( ami, &key ) != ZSuccess )
   \   00003C                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine19 & 0xFFFF
   \                     ??CrossCallReturnLabel_23:
   \   000044   6007         JZ      ??CrossCallReturnLabel_43
   2611                  {
   2612                    ZDSecMgrMasterKeyStore( ami, ZDSecMgrTCMasterKey );
   \   000046                ; Setup parameters for call to function ZDSecMgrMasterKeyStore
   \   000046   7C..         MOV     R4,#(ZDSecMgrTCMasterKey & 0xff)
   \   000048   7D..         MOV     R5,#((ZDSecMgrTCMasterKey >> 8) & 0xff)
   \   00004A   12....       LCALL   ?Subroutine33 & 0xFFFF
   2613                  }
   2614                }
   2615              }
   2616          
   2617              ZDSecMgrTCDataLoaded = TRUE;
   \                     ??CrossCallReturnLabel_43:
   \   00004D   7401         MOV     A,#0x1
   \   00004F   90....       MOV     DPTR,#ZDSecMgrTCDataLoaded
   \   000052   F0           MOVX    @DPTR,A
   2618            }
   2619          }
   \                     ??ZDSecMgrTCDataLoad_0:
   \   000053   7404         MOV     A,#0x4
   \   000055   02....       LJMP    ??Subroutine103_0 & 0xFFFF
   2620          
   2621          /******************************************************************************
   2622           * @fn          ZDSecMgrEstablishKeyInd
   2623           *
   2624           * @brief       Process the ZDO_EstablishKeyInd_t message.
   2625           *
   2626           * @param       ind - [in] ZDO_EstablishKeyInd_t indication
   2627           *
   2628           * @return      none
   2629           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2630          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   \                     ZDSecMgrEstablishKeyInd:
   2631          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 17
   \   000005   74EF         MOV     A,#-0x11
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2632            ZDSecMgrDevice_t        device;
   2633            APSME_EstablishKeyRsp_t rsp;
   2634          
   2635          
   2636            // load Trust Center data if needed
   2637            ZDSecMgrTCDataLoad( ind->initExtAddr );
   \   00000E   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_70:
   \   000011                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000011   AA..         MOV     R2,?V0 + 0
   \   000013   FB           MOV     R3,A
   \   000014   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2638          
   2639            if ( ZDSecMgrTCExtAddrCheck( ind->initExtAddr ) )
   \   000017   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_64:
   \   00001A                ; Setup parameters for call to function ZDSecMgrTCExtAddrCheck
   \   00001A   AA..         MOV     R2,?V0 + 0
   \   00001C   AB..         MOV     R3,?V0 + 1
   \   00001E   12....       LCALL   ??ZDSecMgrTCExtAddrCheck?relay
   \   000021   E9           MOV     A,R1
   \   000022   6016         JZ      ??ZDSecMgrEstablishKeyInd_0
   2640            {
   2641              //IF (ind->srcAddr == APSME_TRUSTCENTER_NWKADDR)
   2642              //OR
   2643              //!ZDSecMgrTCAuthenticated
   2644              //devtag.0604.critical
   2645                  //how is the parentAddr used here
   2646          
   2647              // initial SKKE from Trust Center via parent
   2648              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   \   000024   7407         MOV     A,#0x7
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   E4           CLR     A
   \   00002A   F0           MOVX    @DPTR,A
   \   00002B   A3           INC     DPTR
   \   00002C   12....       LCALL   ?Subroutine9 & 0xFFFF
   2649              device.parentAddr = ind->srcAddr;
   2650            }
   \                     ??CrossCallReturnLabel_9:
   \   00002F   740B         MOV     A,#0xb
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   E8           MOV     A,R0
   \   000035   F0           MOVX    @DPTR,A
   \   000036   A3           INC     DPTR
   \   000037   E9           MOV     A,R1
   \   000038   801C         SJMP    ??ZDSecMgrEstablishKeyInd_1
   2651            else
   2652            {
   2653              // Trust Center direct or E2E SKKE
   2654              device.nwkAddr    = ind->srcAddr;
   \                     ??ZDSecMgrEstablishKeyInd_0:
   \   00003A   85..82       MOV     DPL,?V0 + 2
   \   00003D   85..83       MOV     DPH,?V0 + 3
   \   000040   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_215:
   \   000043   7407         MOV     A,#0x7
   \   000045   12....       LCALL   ?XSTACK_DISP0_8
   \   000048   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   2655              device.parentAddr = INVALID_NODE_ADDR;
   \                     ??CrossCallReturnLabel_176:
   \   00004B   740B         MOV     A,#0xb
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   74FE         MOV     A,#-0x2
   \   000052   F0           MOVX    @DPTR,A
   \   000053   A3           INC     DPTR
   \   000054   74FF         MOV     A,#-0x1
   \                     ??ZDSecMgrEstablishKeyInd_1:
   \   000056   F0           MOVX    @DPTR,A
   2656            }
   2657          
   2658            device.extAddr = ind->initExtAddr;
   \   000057   7409         MOV     A,#0x9
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   E5..         MOV     A,?V0 + 0
   \   00005E   F0           MOVX    @DPTR,A
   \   00005F   A3           INC     DPTR
   \   000060   E5..         MOV     A,?V0 + 1
   \   000062   F0           MOVX    @DPTR,A
   2659            //devtag.pro.security.0724.todo - verify usage
   2660            device.secure  = ind->nwkSecure;
   \   000063   EE           MOV     A,R6
   \   000064   240E         ADD     A,#0xe
   \   000066   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_59:
   \   000069   C0E0         PUSH    A
   \   00006B   740D         MOV     A,#0xd
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   D0E0         POP     A
   \   000072   F0           MOVX    @DPTR,A
   2661          
   2662            // validate device for SKKE
   2663            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   \   000073                ; Setup parameters for call to function ZDSecMgrDeviceValidateSKKE
   \   000073   7407         MOV     A,#0x7
   \   000075   12....       LCALL   ?XSTACK_DISP0_8
   \   000078   AA82         MOV     R2,DPL
   \   00007A   AB83         MOV     R3,DPH
   \   00007C   12....       LCALL   ??ZDSecMgrDeviceValidateSKKE?relay
   \   00007F   E9           MOV     A,R1
   \   000080   7009         JNZ     ??ZDSecMgrEstablishKeyInd_2
   2664            {
   2665              rsp.accept = TRUE;
   \   000082   7404         MOV     A,#0x4
   \   000084   12....       LCALL   ?XSTACK_DISP0_8
   \   000087   7401         MOV     A,#0x1
   \   000089   8006         SJMP    ??ZDSecMgrEstablishKeyInd_3
   2666            }
   2667            else
   2668            {
   2669              rsp.accept = FALSE;
   \                     ??ZDSecMgrEstablishKeyInd_2:
   \   00008B   7404         MOV     A,#0x4
   \   00008D   12....       LCALL   ?XSTACK_DISP0_8
   \   000090   E4           CLR     A
   2670            }
   \                     ??ZDSecMgrEstablishKeyInd_3:
   \   000091   12....       LCALL   ?Subroutine9 & 0xFFFF
   2671          
   2672            rsp.dstAddr     = ind->srcAddr;
   \                     ??CrossCallReturnLabel_10:
   \   000094   12....       LCALL   ??Subroutine99_0 & 0xFFFF
   2673            rsp.initExtAddr = &ind->initExtAddr[0];
   \                     ??CrossCallReturnLabel_180:
   \   000097   EE           MOV     A,R6
   \   000098   2404         ADD     A,#0x4
   \   00009A   F8           MOV     R0,A
   \   00009B   EF           MOV     A,R7
   \   00009C   3400         ADDC    A,#0x0
   \   00009E   F9           MOV     R1,A
   \   00009F   7402         MOV     A,#0x2
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   2674            //devtag.0604.todo - remove obsolete
   2675            rsp.apsSecure   = ind->apsSecure;
   \                     ??CrossCallReturnLabel_177:
   \   0000A7   EE           MOV     A,R6
   \   0000A8   240D         ADD     A,#0xd
   \   0000AA   F582         MOV     DPL,A
   \   0000AC   EF           MOV     A,R7
   \   0000AD   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_147:
   \   0000B0   C0E0         PUSH    A
   \   0000B2   7405         MOV     A,#0x5
   \   0000B4   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B7   D0E0         POP     A
   \   0000B9   F0           MOVX    @DPTR,A
   2676            rsp.nwkSecure   = ind->nwkSecure;
   \   0000BA   85..82       MOV     DPL,?V0 + 0
   \   0000BD   85..83       MOV     DPH,?V0 + 1
   \   0000C0   E0           MOVX    A,@DPTR
   \   0000C1   C0E0         PUSH    A
   \   0000C3   7406         MOV     A,#0x6
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   D0E0         POP     A
   \   0000CA   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   2677          
   2678            APSME_EstablishKeyRsp( &rsp );
   \                     ??CrossCallReturnLabel_161:
   \   0000CD   12....       LCALL   ??APSME_EstablishKeyRsp?relay
   2679          }
   \   0000D0   7411         MOV     A,#0x11
   \   0000D2   80..         SJMP    ??Subroutine106_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   85..82       MOV     DPL,?V0 + 2
   \   000004   85..83       MOV     DPH,?V0 + 3
   \   000007   12....       LCALL   ??Subroutine111_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_223:
   \   00000A   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine43:
   \   000000   F5..         MOV     ?V0 + 0,A
   \   000002   EF           MOV     A,R7
   \   000003   3400         ADDC    A,#0x0
   \   000005   F5..         MOV     ?V0 + 1,A
   \   000007                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000007   85..82       MOV     DPL,?V0 + 0
   \   00000A   F583         MOV     DPH,A
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine45:
   \   000000   EE           MOV     A,R6
   \   000001   2402         ADD     A,#0x2
   \   000003   F5..         MOV     ?V0 + 2,A
   \   000005   EF           MOV     A,R7
   \   000006   3400         ADDC    A,#0x0
   \   000008   F5..         MOV     ?V0 + 3,A
   \   00000A   22           RET
   2680          //devtag.pro.security
   2681          #if 0
   2682          void ZDSecMgrEstablishKeyInd( ZDO_EstablishKeyInd_t* ind )
   2683          {
   2684            ZDSecMgrDevice_t        device;
   2685            APSME_EstablishKeyRsp_t rsp;
   2686          
   2687          
   2688            device.extAddr = ind->initExtAddr;
   2689            device.secure  = ind->secure;
   2690          
   2691            if ( ind->secure == FALSE )
   2692            {
   2693              // SKKE from Trust Center is not secured between child and parent
   2694              device.nwkAddr    = APSME_TRUSTCENTER_NWKADDR;
   2695              device.parentAddr = ind->srcAddr;
   2696            }
   2697            else
   2698            {
   2699              // SKKE from initiator should be secured
   2700              device.nwkAddr    = ind->srcAddr;
   2701              device.parentAddr = INVALID_NODE_ADDR;
   2702            }
   2703          
   2704            rsp.dstAddr     = ind->srcAddr;
   2705            rsp.initExtAddr = &ind->initExtAddr[0];
   2706            rsp.secure      = ind->secure;
   2707          
   2708            // validate device for SKKE
   2709            if ( ZDSecMgrDeviceValidateSKKE( &device ) == ZSuccess )
   2710            {
   2711              rsp.accept = TRUE;
   2712            }
   2713            else
   2714            {
   2715              rsp.accept = FALSE;
   2716            }
   2717          
   2718            APSME_EstablishKeyRsp( &rsp );
   2719          }
   2720          #endif
   2721          
   2722          /******************************************************************************
   2723           * @fn          ZDSecMgrTransportKeyInd
   2724           *
   2725           * @brief       Process the ZDO_TransportKeyInd_t message.
   2726           *
   2727           * @param       ind - [in] ZDO_TransportKeyInd_t indication
   2728           *
   2729           * @return      none
   2730           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2731          void ZDSecMgrTransportKeyInd( ZDO_TransportKeyInd_t* ind )
   \                     ZDSecMgrTransportKeyInd:
   2732          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
   \   000007   EB           MOV     A,R3
   \   000008   FF           MOV     R7,A
   2733            uint8 index;
   2734          
   2735            // load Trust Center data if needed
   2736            ZDSecMgrTCDataLoad( ind->srcExtAddr );
   \   000009                ; Setup parameters for call to function ZDSecMgrTCDataLoad
   \   000009   EE           MOV     A,R6
   \   00000A   2416         ADD     A,#0x16
   \   00000C   FA           MOV     R2,A
   \   00000D   EF           MOV     A,R7
   \   00000E   3400         ADDC    A,#0x0
   \   000010   FB           MOV     R3,A
   \   000011   12....       LCALL   ??ZDSecMgrTCDataLoad?relay
   2737          
   2738            if ( ind->keyType == KEY_TYPE_TC_MASTER )
   \   000014   EE           MOV     A,R6
   \   000015   2404         ADD     A,#0x4
   \   000017   F582         MOV     DPL,A
   \   000019   EF           MOV     A,R7
   \   00001A   12....       LCALL   ??Subroutine95_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_148:
   \   00001D   606A         JZ      ??ZDSecMgrTransportKeyInd_0
   2739            {
   2740              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2741              //ZDSecMgrTCMasterKey( ind );
   2742              {
   2743                if ( zgPreConfigKeys != TRUE )
   2744                {
   2745                  // devtag.pro.security.todo - check if Trust Center address is configured and correct
   2746                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2747                }
   2748                else
   2749                {
   2750                  // error condition - reject key
   2751                }
   2752              }
   2753            }
   2754            else if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   2755                      ( ind->keyType == 6                 ) ||
   2756                      ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   00001F   6401         XRL     A,#0x1
   \   000021   600A         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000023   E0           MOVX    A,@DPTR
   \   000024   6406         XRL     A,#0x6
   \   000026   6005         JZ      ??ZDSecMgrTransportKeyInd_1
   \   000028   E0           MOVX    A,@DPTR
   \   000029   6405         XRL     A,#0x5
   \   00002B   705C         JNZ     ??ZDSecMgrTransportKeyInd_0
   2757            {
   2758              // check for dummy NWK key (all zeros)
   2759              for ( index = 0;
   \                     ??ZDSecMgrTransportKeyInd_1:
   \   00002D   7A00         MOV     R2,#0x0
   \                     ??ZDSecMgrTransportKeyInd_2:
   \   00002F   8A..         MOV     ?V0 + 0,R2
   \   000031   EE           MOV     A,R6
   \   000032   25..         ADD     A,?V0 + 0
   \   000034   F582         MOV     DPL,A
   \   000036   EF           MOV     A,R7
   \   000037   3400         ADDC    A,#0x0
   \   000039   F583         MOV     DPH,A
   \   00003B   A3           INC     DPTR
   \   00003C   A3           INC     DPTR
   \   00003D   A3           INC     DPTR
   \   00003E   A3           INC     DPTR
   \   00003F   A3           INC     DPTR
   \   000040   A3           INC     DPTR
   \   000041   E0           MOVX    A,@DPTR
   \   000042   7007         JNZ     ??ZDSecMgrTransportKeyInd_3
   2760                    ( (index < SEC_KEY_LEN) && (ind->key[index] == 0) );
   2761                    index++ );
   \   000044   0A           INC     R2
   \   000045   EA           MOV     A,R2
   \   000046   C3           CLR     C
   \   000047   9410         SUBB    A,#0x10
   \   000049   40E4         JC      ??ZDSecMgrTransportKeyInd_2
   2762          
   2763              if ( index == SEC_KEY_LEN )
   \                     ??ZDSecMgrTransportKeyInd_3:
   \   00004B   7410         MOV     A,#0x10
   \   00004D   6A           XRL     A,R2
   \   00004E   7013         JNZ     ??ZDSecMgrTransportKeyInd_4
   2764              {
   2765                // load preconfigured key - once!!
   2766                if ( !_NIB.nwkKeyLoaded )
   \   000050   90....       MOV     DPTR,#(_NIB + 61)
   \   000053   E0           MOVX    A,@DPTR
   \   000054   7030         JNZ     ??ZDSecMgrTransportKeyInd_5
   2767                {
   2768                  SSP_UpdateNwkKey( (byte*)zgPreConfigKey, 0 );
   \   000056                ; Setup parameters for call to function SSP_UpdateNwkKey
   \   000056   7900         MOV     R1,#0x0
   \   000058   7A..         MOV     R2,#(zgPreConfigKey & 0xff)
   \   00005A   7B..         MOV     R3,#((zgPreConfigKey >> 8) & 0xff)
   \   00005C   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2769                  SSP_SwitchNwkKey( 0 );
   \   00005F                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00005F   7900         MOV     R1,#0x0
   \   000061   8020         SJMP    ??ZDSecMgrTransportKeyInd_6
   2770                }
   2771              }
   2772              else
   2773              {
   2774                SSP_UpdateNwkKey( ind->key, ind->keySeqNum );
   \                     ??ZDSecMgrTransportKeyInd_4:
   \   000063   EE           MOV     A,R6
   \   000064   2405         ADD     A,#0x5
   \   000066   12....       LCALL   ?Subroutine43 & 0xFFFF
   \                     ??CrossCallReturnLabel_60:
   \   000069   F9           MOV     R1,A
   \   00006A   EE           MOV     A,R6
   \   00006B   2406         ADD     A,#0x6
   \   00006D   FA           MOV     R2,A
   \   00006E   EF           MOV     A,R7
   \   00006F   3400         ADDC    A,#0x0
   \   000071   FB           MOV     R3,A
   \   000072   12....       LCALL   ??SSP_UpdateNwkKey?relay
   2775                if ( !_NIB.nwkKeyLoaded )
   \   000075   90....       MOV     DPTR,#(_NIB + 61)
   \   000078   E0           MOVX    A,@DPTR
   \   000079   700B         JNZ     ??ZDSecMgrTransportKeyInd_5
   2776                {
   2777                  SSP_SwitchNwkKey( ind->keySeqNum );
   \   00007B                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   00007B   85..82       MOV     DPL,?V0 + 0
   \   00007E   85..83       MOV     DPH,?V0 + 1
   \   000081   E0           MOVX    A,@DPTR
   \   000082   F9           MOV     R1,A
   \                     ??ZDSecMgrTransportKeyInd_6:
   \   000083   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2778                }
   2779              }
   2780          
   2781              // handle next step in authentication process
   2782              ZDSecMgrAuthNwkKey();
   \                     ??ZDSecMgrTransportKeyInd_5:
   \   000086                ; Setup parameters for call to function ZDSecMgrAuthNwkKey
   \   000086   12....       LCALL   ??ZDSecMgrAuthNwkKey?relay
   2783            }
   2784            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2785            {
   2786              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2787              {
   2788                //ZDSecMgrTCLinkKey( ind );
   2789              }
   2790            }
   2791            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   2792            {
   2793              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2794              {
   2795                uint16           ami;
   2796                AddrMgrEntry_t   entry;
   2797                ZDSecMgrEntry_t* entryZD;
   2798          
   2799                ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami );
   2800          
   2801                if ( ind->initiator == TRUE )
   2802                {
   2803                  // get the ami data
   2804                  entry.user  = ADDRMGR_USER_SECURITY;
   2805                  entry.index = ami;
   2806                  AddrMgrEntryGet( &entry );
   2807          
   2808                  if ( entry.nwkAddr != INVALID_NODE_ADDR )
   2809                  {
   2810                    APSME_EstablishKeyReq_t req;
   2811                    ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2812          
   2813                    ZDSecMgrEntryLookupAMI( ami, &entryZD );
   2814          
   2815                    if ( entryZD == NULL )
   2816                    {
   2817                      // get new entry
   2818                      if ( ZDSecMgrEntryNew( &entryZD ) == ZSuccess )
   2819                      {
   2820                        // finish setting up entry
   2821                        entryZD->ami = ami;
   2822                      }
   2823                    }
   2824          
   2825                    req.respExtAddr = ind->srcExtAddr;
   2826                    req.method      = APSME_SKKE_METHOD;
   2827                    req.dstAddr     = entry.nwkAddr;
   2828                    //devtag.0604.todo - remove obsolete
   2829                    req.apsSecure   = FALSE;
   2830                    req.nwkSecure   = TRUE;
   2831                    APSME_EstablishKeyReq( &req );
   2832                  }
   2833                }
   2834                else
   2835                {
   2836                  if ( ami == INVALID_NODE_ADDR )
   2837                  {
   2838                    // store new EXT address
   2839                    ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2840                  }
   2841          
   2842                  ZDSecMgrMasterKeyLoad( ind->srcExtAddr, ind->key );
   2843                }
   2844          
   2845                //if ( entry.nwkAddr == INVALID_NODE_ADDR )
   2846                //{
   2847                //  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2848                //}
   2849              }
   2850            }
   2851            else if ( ind->keyType == KEY_TYPE_APP_LINK )
   2852            {
   2853              if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   2854              {
   2855                uint16           ami;
   2856                ZDSecMgrEntry_t* entry;
   2857          
   2858                // get the address index
   2859                if ( ZDSecMgrExtAddrLookup( ind->srcExtAddr, &ami ) != ZSuccess )
   2860                {
   2861                  // store new EXT address
   2862                  ZDSecMgrAddrStore( INVALID_NODE_ADDR, ind->srcExtAddr, &ami );
   2863                  ZDP_NwkAddrReq( ind->srcExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   2864                }
   2865          
   2866                ZDSecMgrEntryLookupAMI( ami, &entry );
   2867          
   2868                if ( entry == NULL )
   2869                {
   2870                  // get new entry
   2871                  if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   2872                  {
   2873                    // finish setting up entry
   2874                    entry->ami = ami;
   2875                  }
   2876                }
   2877          
   2878                ZDSecMgrLinkKeySet( ind->srcExtAddr, ind->key );
   2879              }
   2880            }
   2881          }
   \                     ??ZDSecMgrTransportKeyInd_0:
   \   000089   02....       LJMP    ??Subroutine104_0 & 0xFFFF
   2882          
   2883          /******************************************************************************
   2884           * @fn          ZDSecMgrUpdateDeviceInd
   2885           *
   2886           * @brief       Process the ZDO_UpdateDeviceInd_t message.
   2887           *
   2888           * @param       ind - [in] ZDO_UpdateDeviceInd_t indication
   2889           *
   2890           * @return      none
   2891           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine77:
   \   000000   740A         MOV     A,#0xa
   \   000002                REQUIRE ??Subroutine87_0
   \   000002                ; // Fall through to label ??Subroutine87_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2892          void ZDSecMgrUpdateDeviceInd( ZDO_UpdateDeviceInd_t* ind )
   \                     ZDSecMgrUpdateDeviceInd:
   2893          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   2894            ZDSecMgrDevice_t device;
   2895          
   2896          
   2897            device.nwkAddr    = ind->devAddr;
   \   000009   EA           MOV     A,R2
   \   00000A   240C         ADD     A,#0xc
   \   00000C   F582         MOV     DPL,A
   \   00000E   EB           MOV     A,R3
   \   00000F   3400         ADDC    A,#0x0
   \   000011   F583         MOV     DPH,A
   \   000013   12....       LCALL   ?Subroutine16 & 0xFFFF
   2898            device.extAddr    = ind->devExtAddr;
   \                     ??CrossCallReturnLabel_183:
   \   000016   EA           MOV     A,R2
   \   000017   2404         ADD     A,#0x4
   \   000019   F8           MOV     R0,A
   \   00001A   EB           MOV     A,R3
   \   00001B   3400         ADDC    A,#0x0
   \   00001D   F9           MOV     R1,A
   \   00001E   7402         MOV     A,#0x2
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   12....       LCALL   ?Subroutine5 & 0xFFFF
   2899            device.parentAddr = ind->srcAddr;
   \                     ??CrossCallReturnLabel_6:
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   12....       LCALL   ?Subroutine0 & 0xFFFF
   2900          
   2901            //if ( ( ind->status == APSME_UD_SECURED_JOIN   ) ||
   2902            //     ( ind->status == APSME_UD_UNSECURED_JOIN )   )
   2903            //{
   2904            //  if ( ind->status == APSME_UD_SECURED_JOIN )
   2905            //  {
   2906            //    device.secure = TRUE;
   2907            //  }
   2908            //  else
   2909            //  {
   2910            //    device.secure = FALSE;
   2911            //  }
   2912          
   2913              // try to join this device
   2914              ZDSecMgrDeviceJoin( &device );
   \                     ??CrossCallReturnLabel_1:
   \   00002C   12....       LCALL   ??ZDSecMgrDeviceJoin?relay
   2915            //}
   2916          }
   \   00002F   02....       LJMP    ?Subroutine77 & 0xFFFF
   2917          
   2918          /******************************************************************************
   2919           * @fn          ZDSecMgrRemoveDeviceInd
   2920           *
   2921           * @brief       Process the ZDO_RemoveDeviceInd_t message.
   2922           *
   2923           * @param       ind - [in] ZDO_RemoveDeviceInd_t indication
   2924           *
   2925           * @return      none
   2926           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2927          void ZDSecMgrRemoveDeviceInd( ZDO_RemoveDeviceInd_t* ind )
   \                     ZDSecMgrRemoveDeviceInd:
   2928          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 10
   \   000005   74F6         MOV     A,#-0xa
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   2929            ZDSecMgrDevice_t device;
   2930          
   2931          
   2932            // only accept from Trust Center
   2933            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   00000A   8A82         MOV     DPL,R2
   \   00000C   8B83         MOV     DPH,R3
   \   00000E   A3           INC     DPTR
   \   00000F   A3           INC     DPTR
   \   000010   E0           MOVX    A,@DPTR
   \   000011   7002         JNZ     ??ZDSecMgrRemoveDeviceInd_0
   \   000013   A3           INC     DPTR
   \   000014   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrRemoveDeviceInd_0:
   \   000015   7038         JNZ     ??ZDSecMgrRemoveDeviceInd_1
   2934            {
   2935              // look up NWK address
   2936              if ( APSME_LookupNwkAddr( ind->childExtAddr, &device.nwkAddr ) == TRUE )
   \   000017   EA           MOV     A,R2
   \   000018   2404         ADD     A,#0x4
   \   00001A   FE           MOV     R6,A
   \   00001B   EB           MOV     A,R3
   \   00001C   3400         ADDC    A,#0x0
   \   00001E   FF           MOV     R7,A
   \   00001F                ; Setup parameters for call to function APSME_LookupNwkAddr
   \   00001F   85..82       MOV     DPL,?XSP + 0
   \   000022   85..83       MOV     DPH,?XSP + 1
   \   000025   AC82         MOV     R4,DPL
   \   000027   AD83         MOV     R5,DPH
   \   000029   EE           MOV     A,R6
   \   00002A   FA           MOV     R2,A
   \   00002B   EF           MOV     A,R7
   \   00002C   FB           MOV     R3,A
   \   00002D   12....       LCALL   ??APSME_LookupNwkAddr?relay
   \   000030   E9           MOV     A,R1
   \   000031   6401         XRL     A,#0x1
   \   000033   701A         JNZ     ??ZDSecMgrRemoveDeviceInd_1
   2937              {
   2938                device.parentAddr = NLME_GetShortAddr();
   \   000035                ; Setup parameters for call to function NLME_GetShortAddr
   \   000035   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000038   7404         MOV     A,#0x4
   \   00003A   12....       LCALL   ?XSTACK_DISP0_8
   \   00003D   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   2939                device.extAddr    = ind->childExtAddr;
   \                     ??CrossCallReturnLabel_192:
   \   000040   7402         MOV     A,#0x2
   \   000042   12....       LCALL   ?XSTACK_DISP0_8
   \   000045   EE           MOV     A,R6
   \   000046   F0           MOVX    @DPTR,A
   \   000047   A3           INC     DPTR
   \   000048   EF           MOV     A,R7
   \   000049   12....       LCALL   ??Subroutine98_0 & 0xFFFF
   2940          
   2941                // remove device
   2942                ZDSecMgrDeviceRemove( &device );
   2943              }
   2944            }
   \                     ??CrossCallReturnLabel_162:
   \   00004C   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   2945          }
   \                     ??ZDSecMgrRemoveDeviceInd_1:
   \   00004F   740A         MOV     A,#0xa
   \   000051   02....       LJMP    ??Subroutine92_0 & 0xFFFF
   2946          
   2947          /******************************************************************************
   2948           * @fn          ZDSecMgrRequestKeyInd
   2949           *
   2950           * @brief       Process the ZDO_RequestKeyInd_t message.
   2951           *
   2952           * @param       ind - [in] ZDO_RequestKeyInd_t indication
   2953           *
   2954           * @return      none
   2955           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2956          void ZDSecMgrRequestKeyInd( ZDO_RequestKeyInd_t* ind )
   \                     ZDSecMgrRequestKeyInd:
   2957          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2958            if ( ind->keyType == KEY_TYPE_NWK )
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   FC           MOV     R4,A
   \   00000E   7401         MOV     A,#0x1
   \   000010   6C           XRL     A,R4
   \   000011   6008         JZ      ??ZDSecMgrRequestKeyInd_0
   2959            {
   2960            }
   2961            else if ( ind->keyType == KEY_TYPE_APP_MASTER )
   \   000013   7402         MOV     A,#0x2
   \   000015   6C           XRL     A,R4
   \   000016   7003         JNZ     ??ZDSecMgrRequestKeyInd_0
   2962            {
   2963              ZDSecMgrAppKeyReq( ind );
   \   000018                ; Setup parameters for call to function ZDSecMgrAppKeyReq
   \   000018   12....       LCALL   ??ZDSecMgrAppKeyReq?relay
   2964            }
   2965            else if ( ind->keyType == KEY_TYPE_TC_LINK )
   2966            {
   2967            }
   2968            //else ignore
   2969          }
   \                     ??ZDSecMgrRequestKeyInd_0:
   \   00001B   02....       LJMP    ??Subroutine97_0 & 0xFFFF
   2970          
   2971          /******************************************************************************
   2972           * @fn          ZDSecMgrSwitchKeyInd
   2973           *
   2974           * @brief       Process the ZDO_SwitchKeyInd_t message.
   2975           *
   2976           * @param       ind - [in] ZDO_SwitchKeyInd_t indication
   2977           *
   2978           * @return      none
   2979           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2980          void ZDSecMgrSwitchKeyInd( ZDO_SwitchKeyInd_t* ind )
   \                     ZDSecMgrSwitchKeyInd:
   2981          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   2982            SSP_SwitchNwkKey( ind->keySeqNum );
   \   000004                ; Setup parameters for call to function SSP_SwitchNwkKey
   \   000004   8A82         MOV     DPL,R2
   \   000006   8B83         MOV     DPH,R3
   \   000008   A3           INC     DPTR
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   E0           MOVX    A,@DPTR
   \   00000D   F9           MOV     R1,A
   \   00000E   12....       LCALL   ??SSP_SwitchNwkKey?relay
   2983          
   2984            // Save if nv
   2985            ZDApp_NVUpdate();
   \   000011                ; Setup parameters for call to function ZDApp_NVUpdate
   \   000011   12....       LCALL   ??ZDApp_NVUpdate?relay
   2986          }
   \   000014   02....       LJMP    ??Subroutine97_0 & 0xFFFF
   2987          
   2988          /******************************************************************************
   2989           * @fn          ZDSecMgrAuthenticateInd
   2990           *
   2991           * @brief       Process the ZDO_AuthenticateInd_t message.
   2992           *
   2993           * @param       ind - [in] ZDO_AuthenticateInd_t indication
   2994           *
   2995           * @return      none
   2996           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   2997          void ZDSecMgrAuthenticateInd( ZDO_AuthenticateInd_t* ind )
   \                     ZDSecMgrAuthenticateInd:
   2998          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 20
   \   000005   74EC         MOV     A,#-0x14
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   2999            APSME_AuthenticateReq_t req;
   3000            AddrMgrEntry_t          entry;
   3001          
   3002          
   3003            // update the address manager
   3004            //---------------------------------------------------------------------------
   3005            // note:
   3006            // required for EA processing, but ultimately EA logic could also use the
   3007            // neighbor table to look up addresses -- also(IF using EA) the neighbor
   3008            // table is supposed to have authentication states for neighbors
   3009            //---------------------------------------------------------------------------
   3010            entry.user    = ADDRMGR_USER_SECURITY;
   \   00000E   7407         MOV     A,#0x7
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   7402         MOV     A,#0x2
   \   000015   F0           MOVX    @DPTR,A
   3011            entry.nwkAddr = ind->aps.initNwkAddr;
   \   000016   12....       LCALL   ?Subroutine45 & 0xFFFF
   \                     ??CrossCallReturnLabel_65:
   \   000019   85..82       MOV     DPL,?V0 + 2
   \   00001C   F583         MOV     DPH,A
   \   00001E   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_216:
   \   000021   7408         MOV     A,#0x8
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   3012            AddrMgrExtAddrSet( entry.extAddr, ind->aps.initExtAddr );
   \                     ??CrossCallReturnLabel_178:
   \   000029   12....       LCALL   ?Subroutine47 & 0xFFFF
   \                     ??CrossCallReturnLabel_71:
   \   00002C                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   00002C   AC..         MOV     R4,?V0 + 0
   \   00002E   FD           MOV     R5,A
   \   00002F   740A         MOV     A,#0xa
   \   000031   12....       LCALL   ?XSTACK_DISP0_8
   \   000034   AA82         MOV     R2,DPL
   \   000036   AB83         MOV     R3,DPH
   \   000038   12....       LCALL   ??AddrMgrExtAddrSet?relay
   3013          
   3014            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \   00003B                ; Setup parameters for call to function AddrMgrEntryUpdate
   \   00003B   7407         MOV     A,#0x7
   \   00003D   12....       LCALL   ?XSTACK_DISP0_8
   \   000040   AA82         MOV     R2,DPL
   \   000042   AB83         MOV     R3,DPH
   \   000044   12....       LCALL   ??AddrMgrEntryUpdate?relay
   \   000047   E9           MOV     A,R1
   \   000048   6401         XRL     A,#0x1
   \   00004A   7031         JNZ     ??ZDSecMgrAuthenticateInd_0
   3015            {
   3016              // set request fields
   3017              req.nwkAddr   = ind->aps.initNwkAddr;
   \   00004C   85..82       MOV     DPL,?V0 + 2
   \   00004F   85..83       MOV     DPH,?V0 + 3
   \   000052   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_217:
   \   000055   12....       LCALL   ?Subroutine15 & 0xFFFF
   3018              req.extAddr   = ind->aps.initExtAddr;
   \                     ??CrossCallReturnLabel_130:
   \   000058   12....       LCALL   ?XSTACK_DISP0_8
   \   00005B   E5..         MOV     A,?V0 + 0
   \   00005D   F0           MOVX    @DPTR,A
   \   00005E   A3           INC     DPTR
   \   00005F   E5..         MOV     A,?V0 + 1
   \   000061   F0           MOVX    @DPTR,A
   3019              req.action    = APSME_EA_ACCEPT;
   \   000062   7406         MOV     A,#0x6
   \   000064   12....       LCALL   ?XSTACK_DISP0_8
   \   000067   7401         MOV     A,#0x1
   \   000069   F0           MOVX    @DPTR,A
   3020              req.challenge = ind->aps.challenge;
   \   00006A   EE           MOV     A,R6
   \   00006B   240C         ADD     A,#0xc
   \   00006D   F8           MOV     R0,A
   \   00006E   EF           MOV     A,R7
   \   00006F   3400         ADDC    A,#0x0
   \   000071   F9           MOV     R1,A
   \   000072   7404         MOV     A,#0x4
   \   000074   12....       LCALL   ?XSTACK_DISP0_8
   \   000077   12....       LCALL   ?Subroutine0 & 0xFFFF
   3021          
   3022              // start EA processing
   3023              APSME_AuthenticateReq( &req );
   3024            }
   \                     ??CrossCallReturnLabel_2:
   \   00007A   12....       LCALL   ??APSME_AuthenticateReq?relay
   3025          }
   \                     ??ZDSecMgrAuthenticateInd_0:
   \   00007D   7414         MOV     A,#0x14
   \   00007F   02....       LJMP    ??Subroutine106_0 & 0xFFFF
   3026          
   3027          /******************************************************************************
   3028           * @fn          ZDSecMgrAuthenticateCfm
   3029           *
   3030           * @brief       Process the ZDO_AuthenticateCfm_t message.
   3031           *
   3032           * @param       cfm - [in] ZDO_AuthenticateCfm_t confirmation
   3033           *
   3034           * @return      none
   3035           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3036          void ZDSecMgrAuthenticateCfm( ZDO_AuthenticateCfm_t* cfm )
   \                     ZDSecMgrAuthenticateCfm:
   3037          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
   3038            if ( cfm->aps.status == ZSuccess )
   \   000004   EA           MOV     A,R2
   \   000005   240B         ADD     A,#0xb
   \   000007   12....       LCALL   ?Subroutine41 & 0xFFFF
   \                     ??CrossCallReturnLabel_151:
   \   00000A   701F         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3039            {
   3040              if ( ( cfm->aps.initiator == TRUE ) && ( devState == DEV_END_DEVICE_UNAUTH ) )
   \   00000C   8A82         MOV     DPL,R2
   \   00000E   8B83         MOV     DPH,R3
   \   000010   A3           INC     DPTR
   \   000011   A3           INC     DPTR
   \   000012   E0           MOVX    A,@DPTR
   \   000013   6401         XRL     A,#0x1
   \   000015   7014         JNZ     ??ZDSecMgrAuthenticateCfm_0
   \   000017   90....       MOV     DPTR,#devState
   \   00001A   E0           MOVX    A,@DPTR
   \   00001B   6405         XRL     A,#0x5
   \   00001D   700C         JNZ     ??ZDSecMgrAuthenticateCfm_0
   3041              {
   3042                // inform ZDO that device has been authenticated
   3043                osal_set_event ( ZDAppTaskID, ZDO_DEVICE_AUTH );
   \   00001F                ; Setup parameters for call to function osal_set_event
   \   00001F   7A80         MOV     R2,#-0x80
   \   000021   7B00         MOV     R3,#0x0
   \   000023   90....       MOV     DPTR,#ZDAppTaskID
   \   000026   E0           MOVX    A,@DPTR
   \   000027   F9           MOV     R1,A
   \   000028   12....       LCALL   ??osal_set_event?relay
   3044              }
   3045            }
   3046          }
   \                     ??ZDSecMgrAuthenticateCfm_0:
   \   00002B   02....       LJMP    ??Subroutine97_0 & 0xFFFF
   3047          
   3048          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3049          /******************************************************************************
   3050           * @fn          ZDSecMgrUpdateNwkKey
   3051           *
   3052           * @brief       Load a new NWK key and trigger a network wide update.
   3053           *
   3054           * @param       key       - [in] new NWK key
   3055           * @param       keySeqNum - [in] new NWK key sequence number
   3056           *
   3057           * @return      ZStatus_t
   3058           */
   3059          ZStatus_t ZDSecMgrUpdateNwkKey( uint8* key, uint8 keySeqNum, uint16 dstAddr )
   3060          {
   3061            ZStatus_t               status;
   3062            APSME_TransportKeyReq_t req;
   3063          
   3064            // initialize common elements of local variables
   3065            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3066              req.keyType   = KEY_TYPE_NWK_HIGH;
   3067            else
   3068              req.keyType   = KEY_TYPE_NWK;
   3069          
   3070            req.dstAddr   = dstAddr;
   3071            req.keySeqNum = keySeqNum;
   3072            req.key       = key;
   3073            req.extAddr   = NULL;
   3074            req.nwkSecure = TRUE;
   3075            req.apsSecure = TRUE;
   3076            req.tunnel    = NULL;
   3077          
   3078            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3079            {
   3080              ZDSecMgrEntry_t*        entry;
   3081              uint16                  index;
   3082              AddrMgrEntry_t          addrEntry;
   3083          
   3084              addrEntry.user = ADDRMGR_USER_SECURITY;
   3085          
   3086              status = ZFailure;
   3087          
   3088              // verify data is available
   3089              if ( ZDSecMgrEntries != NULL )
   3090              {
   3091                // find available entry
   3092                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3093                {
   3094                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3095                  {
   3096                    // return successful result
   3097                    entry = &ZDSecMgrEntries[index];
   3098          
   3099                    // get NWK address
   3100                    addrEntry.index = entry->ami;
   3101                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3102                    {
   3103                      req.dstAddr = addrEntry.nwkAddr;
   3104                      req.extAddr = addrEntry.extAddr;
   3105                      status = APSME_TransportKeyReq( &req );
   3106                    }
   3107                  }
   3108                }
   3109              }
   3110            }
   3111            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3112            {
   3113              status = APSME_TransportKeyReq( &req );
   3114            }
   3115          
   3116            SSP_UpdateNwkKey( key, keySeqNum );
   3117          
   3118            // Save if nv
   3119            ZDApp_NVUpdate();
   3120          
   3121            return status;
   3122          }
   3123          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3124          
   3125          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3126          /******************************************************************************
   3127           * @fn          ZDSecMgrSwitchNwkKey
   3128           *
   3129           * @brief       Causes the NWK key to switch via a network wide command.
   3130           *
   3131           * @param       keySeqNum - [in] new NWK key sequence number
   3132           *
   3133           * @return      ZStatus_t
   3134           */
   3135          ZStatus_t ZDSecMgrSwitchNwkKey( uint8 keySeqNum, uint16 dstAddr )
   3136          {
   3137            ZStatus_t            status;
   3138            APSME_SwitchKeyReq_t req;
   3139          
   3140            // initialize common elements of local variables
   3141            req.dstAddr = dstAddr;
   3142            req.keySeqNum = keySeqNum;
   3143          
   3144            if ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_PRO_HIGH )
   3145            {
   3146              ZDSecMgrEntry_t*     entry;
   3147              uint16               index;
   3148              AddrMgrEntry_t       addrEntry;
   3149          
   3150              addrEntry.user = ADDRMGR_USER_SECURITY;
   3151          
   3152              status = ZFailure;
   3153          
   3154              // verify data is available
   3155              if ( ZDSecMgrEntries != NULL )
   3156              {
   3157                // find available entry
   3158                for ( index = 0; index < ZDSECMGR_ENTRY_MAX ; index++ )
   3159                {
   3160                  if ( ZDSecMgrEntries[index].ami != INVALID_NODE_ADDR )
   3161                  {
   3162                    // return successful result
   3163                    entry = &ZDSecMgrEntries[index];
   3164          
   3165                    // get NWK address
   3166                    addrEntry.index = entry->ami;
   3167          
   3168                    if ( AddrMgrEntryGet( &addrEntry ) == TRUE )
   3169                    {
   3170                      req.dstAddr = addrEntry.nwkAddr;
   3171                      status = APSME_SwitchKeyReq( &req );
   3172                    }
   3173                  }
   3174                }
   3175              }
   3176            }
   3177            else // ( ZG_CHECK_SECURITY_MODE == ZG_SECURITY_RESIDENTIAL )
   3178            {
   3179              status = APSME_SwitchKeyReq( &req );
   3180            }
   3181          
   3182            SSP_SwitchNwkKey( keySeqNum );
   3183          
   3184            // Save if nv
   3185            ZDApp_NVUpdate();
   3186          
   3187            return status;
   3188          }
   3189          #endif // ( ZG_BUILD_COORDINATOR_TYPE )
   3190          
   3191          #if ( ZG_BUILD_JOINING_TYPE )
   3192          /******************************************************************************
   3193           * @fn          ZDSecMgrRequestAppKey
   3194           *
   3195           * @brief       Request an application key with partner.
   3196           *
   3197           * @param       partNwkAddr - [in] partner network address
   3198           *
   3199           * @return      ZStatus_t
   3200           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3201          ZStatus_t ZDSecMgrRequestAppKey( uint16 partNwkAddr )
   \                     ZDSecMgrRequestAppKey:
   3202          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 12
   \   000004   74F4         MOV     A,#-0xc
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   3203            ZStatus_t             status;
   3204            APSME_RequestKeyReq_t req;
   3205            uint8                 partExtAddr[Z_EXTADDR_LEN];
   3206          
   3207          
   3208            if ( AddrMgrExtAddrLookup( partNwkAddr, partExtAddr ) )
   \   000009                ; Setup parameters for call to function AddrMgrExtAddrLookup
   \   000009   7404         MOV     A,#0x4
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   AC82         MOV     R4,DPL
   \   000010   AD83         MOV     R5,DPH
   \   000012   12....       LCALL   ??AddrMgrExtAddrLookup?relay
   \   000015   E9           MOV     A,R1
   \   000016   6026         JZ      ??ZDSecMgrRequestAppKey_0
   3209            {
   3210              req.dstAddr = 0;
   \   000018   E4           CLR     A
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   F0           MOVX    @DPTR,A
   3211              req.keyType = KEY_TYPE_APP_MASTER;
   \   000020   7401         MOV     A,#0x1
   \   000022   12....       LCALL   ?XSTACK_DISP0_8
   \   000025   7402         MOV     A,#0x2
   \   000027   F0           MOVX    @DPTR,A
   3212              req.partExtAddr = partExtAddr;
   \   000028   7404         MOV     A,#0x4
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   A882         MOV     R0,DPL
   \   00002F   A983         MOV     R1,DPH
   \   000031   7402         MOV     A,#0x2
   \   000033   12....       LCALL   ?XSTACK_DISP0_8
   \   000036   12....       LCALL   ?Subroutine0 & 0xFFFF
   3213              status = APSME_RequestKeyReq( &req );
   3214            }
   \                     ??CrossCallReturnLabel_3:
   \   000039   12....       LCALL   ??APSME_RequestKeyReq?relay
   \   00003C   8002         SJMP    ??ZDSecMgrRequestAppKey_1
   3215            else
   3216            {
   3217              status = ZFailure;
   \                     ??ZDSecMgrRequestAppKey_0:
   \   00003E   7901         MOV     R1,#0x1
   3218            }
   3219          
   3220            return status;
   \                     ??ZDSecMgrRequestAppKey_1:
   \   000040   740C         MOV     A,#0xc
   \   000042   02....       LJMP    ??Subroutine87_0 & 0xFFFF
   3221          }
   3222          #endif // ( ZG_BUILD_JOINING_TYPE )
   3223          
   3224          #if ( ZG_BUILD_JOINING_TYPE )
   3225          /******************************************************************************
   3226           * @fn          ZDSecMgrSetupPartner
   3227           *
   3228           * @brief       Setup for application key partner.
   3229           *
   3230           * @param       partNwkAddr - [in] partner network address
   3231           *
   3232           * @return      ZStatus_t
   3233           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3234          ZStatus_t ZDSecMgrSetupPartner( uint16 partNwkAddr, uint8* partExtAddr )
   \                     ZDSecMgrSetupPartner:
   3235          {
   \   000000   74F5         MOV     A,#-0xb
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 11
   \   000005                ; Auto size: 13
   \   000005   74F3         MOV     A,#-0xd
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
   \   00000E   8C..         MOV     ?V0 + 0,R4
   \   000010   8D..         MOV     ?V0 + 1,R5
   3236            AddrMgrEntry_t entry;
   3237            ZStatus_t      status;
   3238          
   3239            status = ZFailure;
   \   000012   75..01       MOV     ?V0 + 2,#0x1
   3240          
   3241            // update the address manager
   3242            entry.user    = ADDRMGR_USER_SECURITY;
   \   000015   7402         MOV     A,#0x2
   \   000017   85..82       MOV     DPL,?XSP + 0
   \   00001A   85..83       MOV     DPH,?XSP + 1
   \   00001D   F0           MOVX    @DPTR,A
   3243            entry.nwkAddr = partNwkAddr;
   \   00001E   7401         MOV     A,#0x1
   \   000020   12....       LCALL   ?XSTACK_DISP0_8
   \   000023   EE           MOV     A,R6
   \   000024   F0           MOVX    @DPTR,A
   \   000025   A3           INC     DPTR
   \   000026   EF           MOV     A,R7
   \   000027   F0           MOVX    @DPTR,A
   3244            AddrMgrExtAddrSet( entry.extAddr, partExtAddr );
   \   000028                ; Setup parameters for call to function AddrMgrExtAddrSet
   \   000028   7403         MOV     A,#0x3
   \   00002A   12....       LCALL   ?XSTACK_DISP0_8
   \   00002D   12....       LCALL   ?Subroutine44 & 0xFFFF
   3245          
   3246            if ( AddrMgrEntryUpdate( &entry ) == TRUE )
   \                     ??CrossCallReturnLabel_63:
   \   000030   7036         JNZ     ??ZDSecMgrSetupPartner_0
   3247            {
   3248              status = ZSuccess;
   \   000032   75..00       MOV     ?V0 + 2,#0x0
   3249          
   3250              // check for address discovery
   3251              if ( partNwkAddr == INVALID_NODE_ADDR )
   \   000035   74FE         MOV     A,#-0x2
   \   000037   6E           XRL     A,R6
   \   000038   7003         JNZ     ??ZDSecMgrSetupPartner_1
   \   00003A   74FF         MOV     A,#-0x1
   \   00003C   6F           XRL     A,R7
   \                     ??ZDSecMgrSetupPartner_1:
   \   00003D   700F         JNZ     ??ZDSecMgrSetupPartner_2
   3252              {
   3253                status = ZDP_NwkAddrReq( partExtAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   00003F                ; Setup parameters for call to function ZDP_NwkAddrReq
   \   00003F   7D00         MOV     R5,#0x0
   \   000041   7C00         MOV     R4,#0x0
   \   000043   7900         MOV     R1,#0x0
   \   000045   AA..         MOV     R2,?V0 + 0
   \   000047   AB..         MOV     R3,?V0 + 1
   \   000049   12....       LCALL   ??ZDP_NwkAddrReq?relay
   \   00004C   8017         SJMP    ??ZDSecMgrSetupPartner_3
   3254              }
   3255              else if ( !AddrMgrExtAddrValid( partExtAddr ) )
   \                     ??ZDSecMgrSetupPartner_2:
   \   00004E                ; Setup parameters for call to function AddrMgrExtAddrValid
   \   00004E   AA..         MOV     R2,?V0 + 0
   \   000050   AB..         MOV     R3,?V0 + 1
   \   000052   12....       LCALL   ??AddrMgrExtAddrValid?relay
   \   000055   E9           MOV     A,R1
   \   000056   7010         JNZ     ??ZDSecMgrSetupPartner_0
   3256              {
   3257                status = ZDP_IEEEAddrReq( partNwkAddr, ZDP_ADDR_REQTYPE_SINGLE, 0, 0 );
   \   000058                ; Setup parameters for call to function ZDP_IEEEAddrReq
   \   000058   7D00         MOV     R5,#0x0
   \   00005A   7C00         MOV     R4,#0x0
   \   00005C   7900         MOV     R1,#0x0
   \   00005E   EE           MOV     A,R6
   \   00005F   FA           MOV     R2,A
   \   000060   EF           MOV     A,R7
   \   000061   FB           MOV     R3,A
   \   000062   12....       LCALL   ??ZDP_IEEEAddrReq?relay
   \                     ??ZDSecMgrSetupPartner_3:
   \   000065   E9           MOV     A,R1
   \   000066   F5..         MOV     ?V0 + 2,A
   3258              }
   3259            }
   3260          
   3261            return status;
   \                     ??ZDSecMgrSetupPartner_0:
   \   000068   A9..         MOV     R1,?V0 + 2
   \   00006A   740D         MOV     A,#0xd
   \   00006C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00006F   7F03         MOV     R7,#0x3
   \   000071   02....       LJMP    ?BANKED_LEAVE_XDATA
   3262          }
   3263          #endif // ( ZG_BUILD_JOINING_TYPE )
   3264          
   3265          #if ( ZG_BUILD_COORDINATOR_TYPE )
   3266          /******************************************************************************
   3267           * @fn          ZDSecMgrAppKeyTypeSet
   3268           *
   3269           * @brief       Set application key type.
   3270           *
   3271           * @param       keyType - [in] application key type (KEY_TYPE_APP_MASTER@2 or
   3272           *                                                   KEY_TYPE_APP_LINK@3
   3273           *
   3274           * @return      ZStatus_t
   3275           */
   3276          ZStatus_t ZDSecMgrAppKeyTypeSet( uint8 keyType )
   3277          {
   3278            if ( keyType == KEY_TYPE_APP_LINK )
   3279            {
   3280              ZDSecMgrAppKeyType = KEY_TYPE_APP_LINK;
   3281            }
   3282            else
   3283            {
   3284              ZDSecMgrAppKeyType = KEY_TYPE_APP_MASTER;
   3285            }
   3286          
   3287            return ZSuccess;
   3288          }
   3289          #endif
   3290          
   3291          /******************************************************************************
   3292           * ZigBee Device Security Manager - Stub Implementations
   3293           */
   3294          /******************************************************************************
   3295           * @fn          ZDSecMgrMasterKeyGet (stubs APSME_MasterKeyGet)
   3296           *
   3297           * @brief       Get MASTER key for specified EXT address.
   3298           *
   3299           * @param       extAddr - [in] EXT address
   3300           * @param       key     - [out] MASTER key
   3301           *
   3302           * @return      ZStatus_t
   3303           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3304          ZStatus_t ZDSecMgrMasterKeyGet( uint8* extAddr, uint8** key )
   \                     APSME_MasterKeyGet:
   3305          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3306            ZStatus_t status;
   3307            uint16    ami;
   3308          
   3309          
   3310            // lookup entry for specified EXT address
   3311            status = ZDSecMgrExtAddrLookup( extAddr, &ami );
   \   00000E                ; Setup parameters for call to function ZDSecMgrExtAddrLookup
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrExtAddrLookup?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   3312            //status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   3313          
   3314            if ( status == ZSuccess )
   \   00001E   700F         JNZ     ??APSME_MasterKeyGet_0
   3315            {
   3316              ZDSecMgrMasterKeyLookup( ami, key );
   \   000020                ; Setup parameters for call to function ZDSecMgrMasterKeyLookup
   \   000020   EE           MOV     A,R6
   \   000021   FC           MOV     R4,A
   \   000022   EF           MOV     A,R7
   \   000023   FD           MOV     R5,A
   \   000024   85..82       MOV     DPL,?XSP + 0
   \   000027   85..83       MOV     DPH,?XSP + 1
   \   00002A   12....       LCALL   ?Subroutine34 & 0xFFFF
   3317            }
   \                     ??CrossCallReturnLabel_45:
   \   00002D   8008         SJMP    ??APSME_MasterKeyGet_1
   3318            else
   3319            {
   3320              *key = NULL;
   \                     ??APSME_MasterKeyGet_0:
   \   00002F   8E82         MOV     DPL,R6
   \   000031   8F83         MOV     DPH,R7
   \   000033   E4           CLR     A
   \   000034   F0           MOVX    @DPTR,A
   \   000035   A3           INC     DPTR
   \   000036   F0           MOVX    @DPTR,A
   3321            }
   3322          
   3323            return status;
   \                     ??APSME_MasterKeyGet_1:
   \   000037   02....       LJMP    ?Subroutine73 & 0xFFFF
   3324          }
   3325          
   3326          /******************************************************************************
   3327           * @fn          ZDSecMgrLinkKeySet (stubs APSME_LinkKeySet)
   3328           *
   3329           * @brief       Set <APSME_LinkKeyData_t> for specified NWK address.
   3330           *
   3331           * @param       extAddr - [in] EXT address
   3332           * @param       data    - [in] APSME_LinkKeyData_t
   3333           *
   3334           * @return      ZStatus_t
   3335           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3336          ZStatus_t ZDSecMgrLinkKeySet( uint8* extAddr, uint8* key )
   \                     APSME_LinkKeySet:
   3337          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3338            ZStatus_t        status;
   3339            ZDSecMgrEntry_t* entry;
   3340          
   3341          
   3342            // lookup entry index for specified EXT address
   3343            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   \   00001C   F5..         MOV     ?V0 + 0,A
   3344          
   3345            if ( status == ZSuccess )
   \   00001E   704E         JNZ     ??APSME_LinkKeySet_0
   3346            {
   3347              // setup the link key data reference
   3348              osal_memcpy( entry->lkd.key, key, SEC_KEY_LEN );
   \   000020                ; Setup parameters for call to function osal_memcpy
   \   000020   8E..         MOV     ?V0 + 4,R6
   \   000022   8F..         MOV     ?V0 + 5,R7
   \   000024   75..00       MOV     ?V0 + 6,#0x0
   \   000027   78..         MOV     R0,#?V0 + 4
   \   000029   12....       LCALL   ?PUSH_XSTACK_I_THREE
   \   00002C   7C10         MOV     R4,#0x10
   \   00002E   7D00         MOV     R5,#0x0
   \   000030   7403         MOV     A,#0x3
   \   000032   12....       LCALL   ?XSTACK_DISP0_8
   \   000035   12....       LCALL   ?Subroutine37 & 0xFFFF
   \                     ??CrossCallReturnLabel_48:
   \   000038   12....       LCALL   ??osal_memcpy?relay
   \   00003B   7403         MOV     A,#0x3
   \   00003D   12....       LCALL   ?DEALLOC_XSTACK8
   3349          
   3350              entry->lkd.apsmelkd.rxFrmCntr = 0;
   \   000040   90....       MOV     DPTR,#__Constant_0
   \   000043   78..         MOV     R0,#?V0 + 4
   \   000045   12....       LCALL   ?L_MOV_X
   \   000048   85..82       MOV     DPL,?XSP + 0
   \   00004B   85..83       MOV     DPH,?XSP + 1
   \   00004E   E0           MOVX    A,@DPTR
   \   00004F   2418         ADD     A,#0x18
   \   000051   12....       LCALL   ?Subroutine30 & 0xFFFF
   \                     ??CrossCallReturnLabel_38:
   \   000054   12....       LCALL   ?L_MOV_TO_X
   3351              entry->lkd.apsmelkd.txFrmCntr = 0;
   \   000057   90....       MOV     DPTR,#__Constant_0
   \   00005A   78..         MOV     R0,#?V0 + 4
   \   00005C   12....       LCALL   ?L_MOV_X
   \   00005F   85..82       MOV     DPL,?XSP + 0
   \   000062   85..83       MOV     DPH,?XSP + 1
   \   000065   E0           MOVX    A,@DPTR
   \   000066   2414         ADD     A,#0x14
   \   000068   12....       LCALL   ?Subroutine30 & 0xFFFF
   3352            }
   \                     ??CrossCallReturnLabel_39:
   \   00006B   12....       LCALL   ?L_MOV_TO_X
   3353          
   3354            return status;
   \                     ??APSME_LinkKeySet_0:
   \   00006E   A9..         MOV     R1,?V0 + 0
   \   000070   7402         MOV     A,#0x2
   \   000072   12....       LCALL   ?DEALLOC_XSTACK8
   \   000075   7F08         MOV     R7,#0x8
   \   000077   02....       LJMP    ?BANKED_LEAVE_XDATA
   3355          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine30:
   \   000000   12....       LCALL   ?Subroutine57 & 0xFFFF
   \                     ??CrossCallReturnLabel_102:
   \   000003   78..         MOV     R0,#?V0 + 4
   \   000005   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine37:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   2402         ADD     A,#0x2
   \   000003   FA           MOV     R2,A
   \   000004   A3           INC     DPTR
   \   000005   E0           MOVX    A,@DPTR
   \   000006   3400         ADDC    A,#0x0
   \   000008   FB           MOV     R3,A
   \   000009   22           RET
   3356          
   3357          /******************************************************************************
   3358           * @fn          ZDSecMgrAuthenticationSet
   3359           *
   3360           * @brief       Mark the specific device as authenticated or not
   3361           *
   3362           * @param       extAddr - [in] EXT address
   3363           * @param       option  - [in] authenticated or not
   3364           *
   3365           * @return      ZStatus_t
   3366           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3367          ZStatus_t ZDSecMgrAuthenticationSet( uint8* extAddr, ZDSecMgr_Authentication_Option option )
   \                     ZDSecMgrAuthenticationSet:
   3368          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   E9           MOV     A,R1
   \   00000B   FE           MOV     R6,A
   3369            ZStatus_t        status;
   3370            ZDSecMgrEntry_t* entry;
   3371          
   3372          
   3373            // lookup entry index for specified EXT address
   3374            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000C                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000C   85..82       MOV     DPL,?XSP + 0
   \   00000F   85..83       MOV     DPH,?XSP + 1
   \   000012   AC82         MOV     R4,DPL
   \   000014   AD83         MOV     R5,DPH
   \   000016   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   000019   E9           MOV     A,R1
   3375          
   3376            if ( status == ZSuccess )
   \   00001A   7015         JNZ     ??ZDSecMgrAuthenticationSet_0
   3377            {
   3378              entry->authenticateOption = option;
   \   00001C   85..82       MOV     DPL,?XSP + 0
   \   00001F   85..83       MOV     DPH,?XSP + 1
   \   000022   E0           MOVX    A,@DPTR
   \   000023   241C         ADD     A,#0x1c
   \   000025   FA           MOV     R2,A
   \   000026   A3           INC     DPTR
   \   000027   E0           MOVX    A,@DPTR
   \   000028   3400         ADDC    A,#0x0
   \   00002A   FB           MOV     R3,A
   \   00002B   8A82         MOV     DPL,R2
   \   00002D   8B83         MOV     DPH,R3
   \   00002F   EE           MOV     A,R6
   \   000030   F0           MOVX    @DPTR,A
   3379            }
   3380          
   3381            return status;
   \                     ??ZDSecMgrAuthenticationSet_0:
   \   000031   02....       LJMP    ??Subroutine91_0 & 0xFFFF
   3382          }
   3383          
   3384          /******************************************************************************
   3385           * @fn          ZDSecMgrAuthenticationCheck
   3386           *
   3387           * @brief       Check if the specific device has been authenticated or not
   3388           *              For non-trust center device, always return true
   3389           *
   3390           * @param       shortAddr - [in] short address
   3391           *
   3392           * @return      TRUE @ authenticated with CBKE
   3393           *              FALSE @ not authenticated
   3394           */
   3395          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3396          uint8 ZDSecMgrAuthenticationCheck( uint16 shortAddr )
   \                     ZDSecMgrAuthenticationCheck:
   3397          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
   3398          #if defined (SE_PROFILE)
   3399          
   3400            ZDSecMgrEntry_t* entry;
   3401            uint8 extAddr[Z_EXTADDR_LEN];
   3402          
   3403            // If the local device is not the trust center, always return TRUE
   3404            if ( NLME_GetShortAddr() != TCshortAddr )
   3405            {
   3406              return TRUE;
   3407            }
   3408            // Otherwise, check the authentication option
   3409            else if ( AddrMgrExtAddrLookup( shortAddr, extAddr ) )
   3410            {
   3411              // lookup entry index for specified EXT address
   3412              if ( ZDSecMgrEntryLookupExt( extAddr, &entry ) == ZSuccess )
   3413              {
   3414                if ( entry->authenticateOption != ZDSecMgr_Not_Authenticated )
   3415                {
   3416                  return TRUE;
   3417                }
   3418                else
   3419                {
   3420                  return FALSE;
   3421                }
   3422              }
   3423            }
   3424            return FALSE;
   3425          
   3426          #else
   3427            (void)shortAddr;  // Intentionally unreferenced parameter
   3428            
   3429            // For non AMI/SE Profile, perform no check and always return true.
   3430            return TRUE;
   \   000000   7901         MOV     R1,#0x1
   \   000002   02....       LJMP    ?BRET
   3431          
   3432          #endif // SE_PROFILE
   3433          }
   3434          
   3435          
   3436          /******************************************************************************
   3437           * @fn          ZDSecMgrLinkKeyDataGet (stubs APSME_LinkKeyDataGet)
   3438           *
   3439           * @brief       Get <APSME_LinkKeyData_t> for specified NWK address.
   3440           *
   3441           * @param       extAddr - [in] EXT address
   3442           * @param       data    - [out] APSME_LinkKeyData_t
   3443           *
   3444           * @return      ZStatus_t
   3445           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3446          ZStatus_t ZDSecMgrLinkKeyDataGet(uint8* extAddr, APSME_LinkKeyData_t** data)
   \                     APSME_LinkKeyDataGet:
   3447          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   3448            ZStatus_t        status;
   3449            ZDSecMgrEntry_t* entry;
   3450          
   3451          
   3452            // lookup entry index for specified NWK address
   3453            status = ZDSecMgrEntryLookupExt( extAddr, &entry );
   \   00000E                ; Setup parameters for call to function ZDSecMgrEntryLookupExt
   \   00000E   85..82       MOV     DPL,?XSP + 0
   \   000011   85..83       MOV     DPH,?XSP + 1
   \   000014   AC82         MOV     R4,DPL
   \   000016   AD83         MOV     R5,DPH
   \   000018   12....       LCALL   ??ZDSecMgrEntryLookupExt?relay
   \   00001B   E9           MOV     A,R1
   3454          
   3455            if ( status == ZSuccess )
   \   00001C   702C         JNZ     ??APSME_LinkKeyDataGet_0
   3456            {
   3457              // setup the link key data reference
   3458              (*data) = &entry->lkd.apsmelkd;
   \   00001E   85..82       MOV     DPL,?XSP + 0
   \   000021   85..83       MOV     DPH,?XSP + 1
   \   000024   E0           MOVX    A,@DPTR
   \   000025   2412         ADD     A,#0x12
   \   000027   FA           MOV     R2,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   3400         ADDC    A,#0x0
   \   00002C   FB           MOV     R3,A
   \   00002D   8E82         MOV     DPL,R6
   \   00002F   8F83         MOV     DPH,R7
   \   000031   12....       LCALL   ??Subroutine101_0 & 0xFFFF
   3459              (*data)->key = entry->lkd.key;
   \                     ??CrossCallReturnLabel_193:
   \   000034   85..82       MOV     DPL,?XSP + 0
   \   000037   85..83       MOV     DPH,?XSP + 1
   \   00003A   12....       LCALL   ?Subroutine37 & 0xFFFF
   3460            }
   \                     ??CrossCallReturnLabel_49:
   \   00003D   8E82         MOV     DPL,R6
   \   00003F   8F83         MOV     DPH,R7
   \   000041   12....       LCALL   ?Subroutine26 & 0xFFFF
   \                     ??CrossCallReturnLabel_34:
   \   000044   EA           MOV     A,R2
   \   000045   F0           MOVX    @DPTR,A
   \   000046   A3           INC     DPTR
   \   000047   EB           MOV     A,R3
   \   000048   8007         SJMP    ??APSME_LinkKeyDataGet_1
   3461            else
   3462            {
   3463              *data = NULL;
   \                     ??APSME_LinkKeyDataGet_0:
   \   00004A   8E82         MOV     DPL,R6
   \   00004C   8F83         MOV     DPH,R7
   \   00004E   E4           CLR     A
   \   00004F   F0           MOVX    @DPTR,A
   \   000050   A3           INC     DPTR
   \                     ??APSME_LinkKeyDataGet_1:
   \   000051   F0           MOVX    @DPTR,A
   3464            }
   3465          
   3466            return status;
   \   000052   02....       LJMP    ??Subroutine91_0 & 0xFFFF
   3467          }
   3468          
   3469          /******************************************************************************
   3470           * @fn          ZDSecMgrKeyFwdToChild (stubs APSME_KeyFwdToChild)
   3471           *
   3472           * @brief       Verify and process key transportation to child.
   3473           *
   3474           * @param       ind - [in] APSME_TransportKeyInd_t
   3475           *
   3476           * @return      uint8 - success(TRUE:FALSE)
   3477           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3478          uint8 ZDSecMgrKeyFwdToChild( APSME_TransportKeyInd_t* ind )
   \                     APSME_KeyFwdToChild:
   3479          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
   3480            uint8 success;
   3481          
   3482            success = FALSE;
   \   000005   7E00         MOV     R6,#0x0
   3483          
   3484            // verify from Trust Center
   3485            if ( ind->srcAddr == APSME_TRUSTCENTER_NWKADDR )
   \   000007   8A82         MOV     DPL,R2
   \   000009   8B83         MOV     DPH,R3
   \   00000B   E0           MOVX    A,@DPTR
   \   00000C   7002         JNZ     ??APSME_KeyFwdToChild_0
   \   00000E   A3           INC     DPTR
   \   00000F   E0           MOVX    A,@DPTR
   \                     ??APSME_KeyFwdToChild_0:
   \   000010   7027         JNZ     ??APSME_KeyFwdToChild_1
   3486            {
   3487              success = TRUE;
   \   000012   0E           INC     R6
   3488          
   3489              // check for initial NWK key
   3490              if ( ( ind->keyType == KEY_TYPE_NWK      ) ||
   3491                   ( ind->keyType == 6                 ) ||
   3492                   ( ind->keyType == KEY_TYPE_NWK_HIGH )    )
   \   000013   8A82         MOV     DPL,R2
   \   000015   8B83         MOV     DPH,R3
   \   000017   A3           INC     DPTR
   \   000018   A3           INC     DPTR
   \   000019   E0           MOVX    A,@DPTR
   \   00001A   FC           MOV     R4,A
   \   00001B   EE           MOV     A,R6
   \   00001C   6C           XRL     A,R4
   \   00001D   600A         JZ      ??APSME_KeyFwdToChild_2
   \   00001F   7406         MOV     A,#0x6
   \   000021   6C           XRL     A,R4
   \   000022   6005         JZ      ??APSME_KeyFwdToChild_2
   \   000024   7405         MOV     A,#0x5
   \   000026   6C           XRL     A,R4
   \   000027   7010         JNZ     ??APSME_KeyFwdToChild_1
   3493              {
   3494                // set association status to authenticated
   3495                ZDSecMgrAssocDeviceAuth( AssocGetWithExt( ind->dstExtAddr ) );
   \                     ??APSME_KeyFwdToChild_2:
   \   000029                ; Setup parameters for call to function ZDSecMgrAssocDeviceAuth
   \   000029                ; Setup parameters for call to function AssocGetWithExt
   \   000029   8A82         MOV     DPL,R2
   \   00002B   8B83         MOV     DPH,R3
   \   00002D   A3           INC     DPTR
   \   00002E   A3           INC     DPTR
   \   00002F   A3           INC     DPTR
   \   000030   A3           INC     DPTR
   \   000031   A3           INC     DPTR
   \   000032   A3           INC     DPTR
   \   000033   12....       LCALL   ?Subroutine35 & 0xFFFF
   3496              }
   3497            }
   \                     ??CrossCallReturnLabel_47:
   \   000036   12....       LCALL   ??ZDSecMgrAssocDeviceAuth?relay
   3498          
   3499            return success;
   \                     ??APSME_KeyFwdToChild_1:
   \   000039   EE           MOV     A,R6
   \   00003A   F9           MOV     R1,A
   \   00003B   02....       LJMP    ??Subroutine93_0 & 0xFFFF
   3500          }
   3501          
   3502          /******************************************************************************
   3503           * @fn          ZDSecMgrAddLinkKey
   3504           *
   3505           * @brief       Add the application link key to ZDSecMgr. Also mark the device
   3506           *              as authenticated in the authenticateOption. Note that this function
   3507           *              is hardwared to CBKE right now.
   3508           *
   3509           * @param       shortAddr - short address of the partner device
   3510           * @param       extAddr - extended address of the partner device
   3511           * @param       key - link key
   3512           *
   3513           * @return      none
   3514           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3515          void ZDSecMgrAddLinkKey( uint16 shortAddr, uint8 *extAddr, uint8 *key)
   \                     ZDSecMgrAddLinkKey:
   3516          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
   \   00000E   7410         MOV     A,#0x10
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 0,A
   \   000016   A3           INC     DPTR
   \   000017   E0           MOVX    A,@DPTR
   \   000018   F5..         MOV     ?V0 + 1,A
   3517            uint16           ami;
   3518            ZDSecMgrEntry_t* entry;
   3519          
   3520            ZDSecMgrAddrStore( shortAddr, extAddr, &ami );
   \   00001A                ; Setup parameters for call to function ZDSecMgrAddrStore
   \   00001A   7402         MOV     A,#0x2
   \   00001C   12....       LCALL   ?XSTACK_DISP0_8
   \   00001F   8582..       MOV     ?V0 + 2,DPL
   \   000022   8583..       MOV     ?V0 + 3,DPH
   \   000025   78..         MOV     R0,#?V0 + 2
   \   000027   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00002A   12....       LCALL   ??ZDSecMgrAddrStore?relay
   \   00002D   7402         MOV     A,#0x2
   \   00002F   12....       LCALL   ?DEALLOC_XSTACK8
   3521          
   3522            ZDSecMgrEntryLookupAMI( ami, &entry );
   \   000032                ; Setup parameters for call to function ZDSecMgrEntryLookupAMI
   \   000032   85..82       MOV     DPL,?XSP + 0
   \   000035   85..83       MOV     DPH,?XSP + 1
   \   000038   AC82         MOV     R4,DPL
   \   00003A   AD83         MOV     R5,DPH
   \   00003C   7402         MOV     A,#0x2
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine31 & 0xFFFF
   3523          
   3524            // If no existing entry, create one
   3525            if ( entry == NULL )
   \                     ??CrossCallReturnLabel_41:
   \   000044   85..82       MOV     DPL,?XSP + 0
   \   000047   85..83       MOV     DPH,?XSP + 1
   \   00004A   E0           MOVX    A,@DPTR
   \   00004B   7002         JNZ     ??ZDSecMgrAddLinkKey_0
   \   00004D   A3           INC     DPTR
   \   00004E   E0           MOVX    A,@DPTR
   \                     ??ZDSecMgrAddLinkKey_0:
   \   00004F   7023         JNZ     ??CrossCallReturnLabel_179
   3526            {
   3527              if ( ZDSecMgrEntryNew( &entry ) == ZSuccess )
   \   000051                ; Setup parameters for call to function ZDSecMgrEntryNew
   \   000051   85..82       MOV     DPL,?XSP + 0
   \   000054   85..83       MOV     DPH,?XSP + 1
   \   000057   AA82         MOV     R2,DPL
   \   000059   AB83         MOV     R3,DPH
   \   00005B   12....       LCALL   ??ZDSecMgrEntryNew?relay
   \   00005E   E9           MOV     A,R1
   \   00005F   7013         JNZ     ??CrossCallReturnLabel_179
   3528              {
   3529                entry->ami = ami;
   \   000061   7402         MOV     A,#0x2
   \   000063   12....       LCALL   ?XSTACK_DISP0_8
   \   000066   12....       LCALL   ?Subroutine28 & 0xFFFF
   3530              }
   3531            }
   \                     ??CrossCallReturnLabel_86:
   \   000069   E0           MOVX    A,@DPTR
   \   00006A   FA           MOV     R2,A
   \   00006B   A3           INC     DPTR
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F583         MOV     DPH,A
   \   00006F   8A82         MOV     DPL,R2
   \   000071   12....       LCALL   ??Subroutine100_0 & 0xFFFF
   3532            // Write the link key
   3533            APSME_LinkKeySet( extAddr, key );
   \                     ??CrossCallReturnLabel_179:
   \   000074                ; Setup parameters for call to function APSME_LinkKeySet
   \   000074   AC..         MOV     R4,?V0 + 0
   \   000076   AD..         MOV     R5,?V0 + 1
   \   000078   EE           MOV     A,R6
   \   000079   FA           MOV     R2,A
   \   00007A   EF           MOV     A,R7
   \   00007B   FB           MOV     R3,A
   \   00007C   12....       LCALL   ??APSME_LinkKeySet?relay
   3534          
   3535          #if defined (SE_PROFILE)
   3536            // Mark the device as authenticated.
   3537            ZDSecMgrAuthenticationSet( extAddr, ZDSecMgr_Authenticated_CBCK );
   3538          #endif
   3539          
   3540            // Write the new established link key to NV.
   3541            ZDSecMgrWriteNV();
   \   00007F                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   00007F   12....       LCALL   ??ZDSecMgrWriteNV?relay
   3542          }
   \   000082   7404         MOV     A,#0x4
   \   000084   02....       LJMP    ??Subroutine106_0 & 0xFFFF
   3543          
   3544          /******************************************************************************
   3545           * @fn          ZDSecMgrInitNV
   3546           *
   3547           * @brief       Initialize the SecMgr entry data in NV.
   3548           *
   3549           * @param       none
   3550           *
   3551           * @return      uint8 - <osal_nv_item_init> return codes
   3552           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3553          uint8 ZDSecMgrInitNV( void )
   \                     ZDSecMgrInitNV:
   3554          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   3555            uint8  status;
   3556            uint16 size;
   3557          
   3558            size = (uint16)( sizeof(ZDSecMgrEntry_t) * ZDSECMGR_ENTRY_MAX );
   3559          
   3560            status = osal_nv_item_init( ZCD_NV_APS_LINK_KEY_TABLE, size, NULL );
   \   000005                ; Setup parameters for call to function osal_nv_item_init
   \   000005   75..00       MOV     ?V0 + 0,#0x0
   \   000008   75..00       MOV     ?V0 + 1,#0x0
   \   00000B   78..         MOV     R0,#?V0 + 0
   \   00000D   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000010   7C57         MOV     R4,#0x57
   \   000012   7D00         MOV     R5,#0x0
   \   000014   7A4C         MOV     R2,#0x4c
   \   000016   7B00         MOV     R3,#0x0
   \   000018   12....       LCALL   ??osal_nv_item_init?relay
   \   00001B   7402         MOV     A,#0x2
   \   00001D   12....       LCALL   ?DEALLOC_XSTACK8
   \   000020   E9           MOV     A,R1
   \   000021   FE           MOV     R6,A
   3561          
   3562            // The item does not already exist
   3563            if ( status != ZSUCCESS )
   \   000022   6003         JZ      ??ZDSecMgrInitNV_0
   3564            {
   3565              ZDSecMgrSetDefaultNV();
   \   000024                ; Setup parameters for call to function ZDSecMgrSetDefaultNV
   \   000024   12....       LCALL   ??ZDSecMgrSetDefaultNV?relay
   3566            }
   3567          
   3568            return status;
   \                     ??ZDSecMgrInitNV_0:
   \   000027   EE           MOV     A,R6
   \   000028   F9           MOV     R1,A
   \   000029   02....       LJMP    ??Subroutine104_0 & 0xFFFF
   3569          }
   3570          
   3571          
   3572          /******************************************************************************
   3573           * @fn          ZDSecMgrSetDefaultNV
   3574           *
   3575           * @brief       Set default SecMgr entry data in NV.
   3576           *
   3577           * @param       none
   3578           *
   3579           * @return      none
   3580           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine74:
   \   000000   8582..       MOV     ?V0 + 0,DPL
   \   000003   8583..       MOV     ?V0 + 1,DPH
   \   000006   78..         MOV     R0,#?V0 + 0
   \   000008   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00000B   75..02       MOV     ?V0 + 0,#0x2
   \   00000E   75..00       MOV     ?V0 + 1,#0x0
   \   000011   78..         MOV     R0,#?V0 + 0
   \   000013   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000016   7C00         MOV     R4,#0x0
   \   000018   7D00         MOV     R5,#0x0
   \   00001A   7A4C         MOV     R2,#0x4c
   \   00001C   7B00         MOV     R3,#0x0
   \   00001E   12....       LCALL   ??osal_nv_write?relay
   \   000021   7404         MOV     A,#0x4
   \   000023   12....       LCALL   ?DEALLOC_XSTACK8
   \   000026                REQUIRE ??Subroutine102_0
   \   000026                ; // Fall through to label ??Subroutine102_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3581          void ZDSecMgrSetDefaultNV( void )
   \                     ZDSecMgrSetDefaultNV:
   3582          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3583            nvDeviceListHdr_t hdr;
   3584          
   3585            // Initialize the header
   3586            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   12....       LCALL   ?Subroutine59 & 0xFFFF
   3587          
   3588            // Save off the header
   3589            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \                     ??CrossCallReturnLabel_84:
   \   000016   02....       LJMP    ?Subroutine74 & 0xFFFF
   3590          }
   3591          
   3592          
   3593          
   3594          /*********************************************************************
   3595           * @fn      ZDSecMgrWriteNV()
   3596           *
   3597           * @brief   Save off the link key list to NV
   3598           *
   3599           * @param   none
   3600           *
   3601           * @return  none
   3602           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3603          void ZDSecMgrWriteNV( void )
   \                     ZDSecMgrWriteNV:
   3604          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3605            uint16 i;
   3606            nvDeviceListHdr_t hdr;
   3607          
   3608            hdr.numRecs = 0;
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   E4           CLR     A
   \   000011   F0           MOVX    @DPTR,A
   \   000012   A3           INC     DPTR
   \   000013   F0           MOVX    @DPTR,A
   3609          
   3610            for ( i = 0; i < ZDSECMGR_ENTRY_MAX; i++ )
   \   000014   FE           MOV     R6,A
   \   000015   FF           MOV     R7,A
   3611            {
   3612              if ( ZDSecMgrEntries[i].ami != INVALID_NODE_ADDR )
   \                     ??ZDSecMgrWriteNV_0:
   \   000016   EE           MOV     A,R6
   \   000017   F8           MOV     R0,A
   \   000018   EF           MOV     A,R7
   \   000019   F9           MOV     R1,A
   \   00001A   E8           MOV     A,R0
   \   00001B   75F01D       MOV     B,#0x1d
   \   00001E   A4           MUL     AB
   \   00001F   F8           MOV     R0,A
   \   000020   AAF0         MOV     R2,B
   \   000022   75F01D       MOV     B,#0x1d
   \   000025   E9           MOV     A,R1
   \   000026   A4           MUL     AB
   \   000027   2A           ADD     A,R2
   \   000028   F9           MOV     R1,A
   \   000029   90....       MOV     DPTR,#ZDSecMgrEntries
   \   00002C   E0           MOVX    A,@DPTR
   \   00002D   28           ADD     A,R0
   \   00002E   F5..         MOV     ?V0 + 0,A
   \   000030   A3           INC     DPTR
   \   000031   E0           MOVX    A,@DPTR
   \   000032   39           ADDC    A,R1
   \   000033   F5..         MOV     ?V0 + 1,A
   \   000035   85..82       MOV     DPL,?V0 + 0
   \   000038   F583         MOV     DPH,A
   \   00003A   E0           MOVX    A,@DPTR
   \   00003B   64FE         XRL     A,#0xfe
   \   00003D   7004         JNZ     ??ZDSecMgrWriteNV_1
   \   00003F   A3           INC     DPTR
   \   000040   E0           MOVX    A,@DPTR
   \   000041   64FF         XRL     A,#0xff
   \                     ??ZDSecMgrWriteNV_1:
   \   000043   6049         JZ      ??ZDSecMgrWriteNV_2
   3613              {
   3614                // Save off the record
   3615                osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE,
   3616                        (uint16)((sizeof(nvDeviceListHdr_t)) + (hdr.numRecs * sizeof(ZDSecMgrEntry_t))),
   3617                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[i] );
   \   000045                ; Setup parameters for call to function osal_nv_write
   \   000045   78..         MOV     R0,#?V0 + 0
   \   000047   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004A   75..1D       MOV     ?V0 + 0,#0x1d
   \   00004D   75..00       MOV     ?V0 + 1,#0x0
   \   000050   78..         MOV     R0,#?V0 + 0
   \   000052   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000055   7404         MOV     A,#0x4
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_218:
   \   00005D   E8           MOV     A,R0
   \   00005E   75F01D       MOV     B,#0x1d
   \   000061   A4           MUL     AB
   \   000062   F8           MOV     R0,A
   \   000063   AAF0         MOV     R2,B
   \   000065   75F01D       MOV     B,#0x1d
   \   000068   E9           MOV     A,R1
   \   000069   A4           MUL     AB
   \   00006A   2A           ADD     A,R2
   \   00006B   F9           MOV     R1,A
   \   00006C   7402         MOV     A,#0x2
   \   00006E   28           ADD     A,R0
   \   00006F   FC           MOV     R4,A
   \   000070   E4           CLR     A
   \   000071   39           ADDC    A,R1
   \   000072   FD           MOV     R5,A
   \   000073   7A4C         MOV     R2,#0x4c
   \   000075   7B00         MOV     R3,#0x0
   \   000077   12....       LCALL   ??osal_nv_write?relay
   \   00007A   7404         MOV     A,#0x4
   \   00007C   12....       LCALL   ?DEALLOC_XSTACK8
   3618                hdr.numRecs++;
   \   00007F   85..82       MOV     DPL,?XSP + 0
   \   000082   85..83       MOV     DPH,?XSP + 1
   \   000085   E0           MOVX    A,@DPTR
   \   000086   2401         ADD     A,#0x1
   \   000088   F0           MOVX    @DPTR,A
   \   000089   A3           INC     DPTR
   \   00008A   E0           MOVX    A,@DPTR
   \   00008B   3400         ADDC    A,#0x0
   \   00008D   F0           MOVX    @DPTR,A
   3619              }
   3620            }
   \                     ??ZDSecMgrWriteNV_2:
   \   00008E   12....       LCALL   ?Subroutine40 & 0xFFFF
   \                     ??CrossCallReturnLabel_58:
   \   000091   4083         JC      ??ZDSecMgrWriteNV_0
   3621          
   3622            // Save off the header
   3623            osal_nv_write( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof( nvDeviceListHdr_t ), &hdr );
   \   000093                ; Setup parameters for call to function osal_nv_write
   \   000093   85..82       MOV     DPL,?XSP + 0
   \   000096   85..83       MOV     DPH,?XSP + 1
   \   000099   02....       LJMP    ?Subroutine74 & 0xFFFF
   3624          }
   3625          
   3626          /******************************************************************************
   3627           * @fn          ZDSecMgrRestoreFromNV
   3628           *
   3629           * @brief       Restore the SecMgr entry data from NV.
   3630           *
   3631           * @param       none
   3632           *
   3633           * @return      ZStatus_t ZSuccess or ZFailure
   3634           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3635          ZStatus_t ZDSecMgrRestoreFromNV( void )
   \                     ZDSecMgrRestoreFromNV:
   3636          {
   \   000000   74F3         MOV     A,#-0xd
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 13
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   3637            uint8 x = 0;
   \   00000A   75..00       MOV     ?V0 + 4,#0x0
   3638            nvDeviceListHdr_t hdr;
   3639          
   3640            // Initialize the device list
   3641            if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE, 0, sizeof(nvDeviceListHdr_t), &hdr ) == ZSUCCESS )
   \   00000D                ; Setup parameters for call to function osal_nv_read
   \   00000D   85..82       MOV     DPL,?XSP + 0
   \   000010   85..83       MOV     DPH,?XSP + 1
   \   000013   8582..       MOV     ?V0 + 0,DPL
   \   000016   8583..       MOV     ?V0 + 1,DPH
   \   000019   78..         MOV     R0,#?V0 + 0
   \   00001B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00001E   75..02       MOV     ?V0 + 0,#0x2
   \   000021   75..00       MOV     ?V0 + 1,#0x0
   \   000024   78..         MOV     R0,#?V0 + 0
   \   000026   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000029   7C00         MOV     R4,#0x0
   \   00002B   7D00         MOV     R5,#0x0
   \   00002D   7A4C         MOV     R2,#0x4c
   \   00002F   7B00         MOV     R3,#0x0
   \   000031   12....       LCALL   ??osal_nv_read?relay
   \   000034   7404         MOV     A,#0x4
   \   000036   12....       LCALL   ?DEALLOC_XSTACK8
   \   000039   E9           MOV     A,R1
   \   00003A   6072         JZ      ??ZDSecMgrRestoreFromNV_0
   3642            {
   3643              // Read in the device list
   3644              for ( ; x < hdr.numRecs; x++ )
   3645              {
   3646                if ( osal_nv_read( ZCD_NV_APS_LINK_KEY_TABLE,
   3647                          (uint16)(sizeof(nvDeviceListHdr_t) + (x * sizeof(ZDSecMgrEntry_t))),
   3648                                sizeof(ZDSecMgrEntry_t), &ZDSecMgrEntries[x] ) == ZSUCCESS )
   3649                {
   3650                  ZDSecMgrEntries[x].lkd.apsmelkd.txFrmCntr += ( MAX_APS_FRAMECOUNTER_CHANGES + 1 );
   3651                }
   3652              }
   3653          
   3654              // Write the updated entry back to NV.
   3655              ZDSecMgrWriteNV();
   3656          
   3657              return ZSuccess;
   3658            }
   3659            return ZFailure;
   \   00003C   7901         MOV     R1,#0x1
   \                     ??ZDSecMgrRestoreFromNV_1:
   \   00003E   7402         MOV     A,#0x2
   \   000040   12....       LCALL   ?DEALLOC_XSTACK8
   \   000043   7F05         MOV     R7,#0x5
   \   000045   02....       LJMP    ?BANKED_LEAVE_XDATA
   \                     ??ZDSecMgrRestoreFromNV_2:
   \   000048   EA           MOV     A,R2
   \   000049   75F01D       MOV     B,#0x1d
   \   00004C   A4           MUL     AB
   \   00004D   FE           MOV     R6,A
   \   00004E   ACF0         MOV     R4,B
   \   000050   EC           MOV     A,R4
   \   000051   FF           MOV     R7,A
   \   000052                ; Setup parameters for call to function osal_nv_read
   \   000052   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000055   E0           MOVX    A,@DPTR
   \   000056   2E           ADD     A,R6
   \   000057   F5..         MOV     ?V0 + 0,A
   \   000059   A3           INC     DPTR
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   3F           ADDC    A,R7
   \   00005C   F5..         MOV     ?V0 + 1,A
   \   00005E   78..         MOV     R0,#?V0 + 0
   \   000060   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000063   75..1D       MOV     ?V0 + 0,#0x1d
   \   000066   75..00       MOV     ?V0 + 1,#0x0
   \   000069   78..         MOV     R0,#?V0 + 0
   \   00006B   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006E   EA           MOV     A,R2
   \   00006F   75F01D       MOV     B,#0x1d
   \   000072   A4           MUL     AB
   \   000073   FA           MOV     R2,A
   \   000074   EC           MOV     A,R4
   \   000075   FB           MOV     R3,A
   \   000076   7402         MOV     A,#0x2
   \   000078   2A           ADD     A,R2
   \   000079   FC           MOV     R4,A
   \   00007A   E4           CLR     A
   \   00007B   3B           ADDC    A,R3
   \   00007C   FD           MOV     R5,A
   \   00007D   7A4C         MOV     R2,#0x4c
   \   00007F   7B00         MOV     R3,#0x0
   \   000081   12....       LCALL   ??osal_nv_read?relay
   \   000084   7404         MOV     A,#0x4
   \   000086   12....       LCALL   ?DEALLOC_XSTACK8
   \   000089   E9           MOV     A,R1
   \   00008A   7020         JNZ     ??ZDSecMgrRestoreFromNV_3
   \   00008C   90....       MOV     DPTR,#__Constant_b
   \   00008F   78..         MOV     R0,#?V0 + 0
   \   000091   12....       LCALL   ?L_MOV_X
   \   000094   90....       MOV     DPTR,#ZDSecMgrEntries
   \   000097   E0           MOVX    A,@DPTR
   \   000098   2E           ADD     A,R6
   \   000099   F8           MOV     R0,A
   \   00009A   A3           INC     DPTR
   \   00009B   E0           MOVX    A,@DPTR
   \   00009C   3F           ADDC    A,R7
   \   00009D   F9           MOV     R1,A
   \   00009E   7414         MOV     A,#0x14
   \   0000A0   28           ADD     A,R0
   \   0000A1   F582         MOV     DPL,A
   \   0000A3   E4           CLR     A
   \   0000A4   39           ADDC    A,R1
   \   0000A5   F583         MOV     DPH,A
   \   0000A7   78..         MOV     R0,#?V0 + 0
   \   0000A9   12....       LCALL   ?L_ADD_TO_X
   \                     ??ZDSecMgrRestoreFromNV_3:
   \   0000AC   05..         INC     ?V0 + 4
   \                     ??ZDSecMgrRestoreFromNV_0:
   \   0000AE   85..82       MOV     DPL,?V0 + 4
   \   0000B1   AA82         MOV     R2,DPL
   \   0000B3   85..82       MOV     DPL,?XSP + 0
   \   0000B6   85..83       MOV     DPH,?XSP + 1
   \   0000B9   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_219:
   \   0000BC   C3           CLR     C
   \   0000BD   EA           MOV     A,R2
   \   0000BE   98           SUBB    A,R0
   \   0000BF   E4           CLR     A
   \   0000C0   99           SUBB    A,R1
   \   0000C1   4085         JC      ??ZDSecMgrRestoreFromNV_2
   \   0000C3                ; Setup parameters for call to function ZDSecMgrWriteNV
   \   0000C3   12....       LCALL   ??ZDSecMgrWriteNV?relay
   \   0000C6   7900         MOV     R1,#0x0
   \   0000C8   02....       LJMP    ??ZDSecMgrRestoreFromNV_1 & 0xFFFF
   3660          }
   3661          
   3662          /******************************************************************************
   3663           * @fn          ZDSecMgrAPSRemove
   3664           *
   3665           * @brief       Remove device from network.
   3666           *
   3667           * @param       nwkAddr - device's NWK address
   3668           * @param       extAddr - device's Extended address
   3669           * @param       parentAddr - parent's NWK address
   3670           *
   3671           * @return      ZStatus_t
   3672           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   3673          ZStatus_t ZDSecMgrAPSRemove( uint16 nwkAddr, uint8 *extAddr, uint16 parentAddr )
   \                     ZDSecMgrAPSRemove:
   3674          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 10
   \   000004   74F6         MOV     A,#-0xa
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
   \   000009   740A         MOV     A,#0xa
   \   00000B   12....       LCALL   ?XSTACK_DISP0_8
   \   00000E   12....       LCALL   ??Subroutine110_0 & 0xFFFF
   3675            ZDSecMgrDevice_t device;
   3676          
   3677            if ( ( nwkAddr == INVALID_NODE_ADDR ) ||
   3678                 ( extAddr == NULL )              ||
   3679                 ( parentAddr == INVALID_NODE_ADDR ) )
   \                     ??CrossCallReturnLabel_220:
   \   000011   74FE         MOV     A,#-0x2
   \   000013   6A           XRL     A,R2
   \   000014   7003         JNZ     ??ZDSecMgrAPSRemove_0
   \   000016   74FF         MOV     A,#-0x1
   \   000018   6B           XRL     A,R3
   \                     ??ZDSecMgrAPSRemove_0:
   \   000019   6010         JZ      ??ZDSecMgrAPSRemove_1
   \   00001B   EC           MOV     A,R4
   \   00001C   7001         JNZ     ??ZDSecMgrAPSRemove_2
   \   00001E   ED           MOV     A,R5
   \                     ??ZDSecMgrAPSRemove_2:
   \   00001F   600A         JZ      ??ZDSecMgrAPSRemove_1
   \   000021   74FE         MOV     A,#-0x2
   \   000023   68           XRL     A,R0
   \   000024   7003         JNZ     ??ZDSecMgrAPSRemove_3
   \   000026   74FF         MOV     A,#-0x1
   \   000028   69           XRL     A,R1
   \                     ??ZDSecMgrAPSRemove_3:
   \   000029   7004         JNZ     ??ZDSecMgrAPSRemove_4
   3680            {
   3681              return ( ZFailure );
   \                     ??ZDSecMgrAPSRemove_1:
   \   00002B   7901         MOV     R1,#0x1
   \   00002D   801A         SJMP    ??ZDSecMgrAPSRemove_5
   3682            }
   3683          
   3684            device.nwkAddr = nwkAddr;
   \                     ??ZDSecMgrAPSRemove_4:
   \   00002F   12....       LCALL   ?Subroutine7 & 0xFFFF
   3685            device.extAddr = extAddr;
   \                     ??CrossCallReturnLabel_195:
   \   000032   7402         MOV     A,#0x2
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   EC           MOV     A,R4
   \   000038   F0           MOVX    @DPTR,A
   \   000039   A3           INC     DPTR
   \   00003A   ED           MOV     A,R5
   \   00003B   F0           MOVX    @DPTR,A
   3686            device.parentAddr = parentAddr;
   \   00003C   7404         MOV     A,#0x4
   \   00003E   12....       LCALL   ?XSTACK_DISP0_8
   \   000041   12....       LCALL   ?Subroutine0 & 0xFFFF
   3687          
   3688            // remove device
   3689            ZDSecMgrDeviceRemove( &device );
   \                     ??CrossCallReturnLabel_4:
   \   000044   12....       LCALL   ??ZDSecMgrDeviceRemove?relay
   3690          
   3691            return ( ZSuccess );
   \   000047   7900         MOV     R1,#0x0
   \                     ??ZDSecMgrAPSRemove_5:
   \   000049   02....       LJMP    ?Subroutine77 & 0xFFFF
   3692          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine20:
   \   000000   12....       LCALL   ?Subroutine50 & 0xFFFF
   \                     ??CrossCallReturnLabel_127:
   \   000003   E4           CLR     A
   \   000004   F0           MOVX    @DPTR,A
   \   000005   22           RET

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrTCMasterKey>`:
   \   000000   00000000     DB 0, 0, 0, 0, 0, 0, 0, 0, 137, 103, 69, 35, 1, 239, 205, 171
   \            00000000
   \            89674523
   \            01EFCDAB

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for ZDSecMgrAppKeyType>`:
   \   000000   03           DB 3

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_b:
   \   000000   0B000000     DD 11

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrExtAddrLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrExtAddrLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyStore?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyStore

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupAMI?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupAMI

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryLookupExt?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryLookupExt

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryFree?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryFree

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEntryNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEntryNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlRelease?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlRelease

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlLookup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlLookup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlTerm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlTerm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrCtrlReset?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrCtrlReset

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrMasterKeyLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrMasterKeyLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAppKeyReq?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAppKeyReq

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendMasterKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendMasterKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSendNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSendNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddrMgrUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddrMgrUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceEntryAdd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceEntryAdd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlHandler?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlHandler

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlSetup?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlSetup

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceCtrlUpdate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceCtrlUpdate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_SKA_TimerExpired?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_SKA_TimerExpired

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceRemove

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateSKKE?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateSKKE

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateRM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateRM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidateCM?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidateCM

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceValidate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceValidate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoin?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoin

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinDirect?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinDirect

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceJoinFwd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceJoinFwd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrDeviceNew?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrDeviceNew

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAssocDeviceAuth?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAssocDeviceAuth

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthInitiate?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthInitiate

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthNwkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthNwkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrConfig?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrConfig

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoining?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoining

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrPermitJoiningTimeout?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrPermitJoiningTimeout

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrNewDeviceEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrNewDeviceEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCExtAddrCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCExtAddrCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTCDataLoad?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTCDataLoad

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrEstablishKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrEstablishKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrTransportKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrTransportKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrUpdateDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrUpdateDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRemoveDeviceInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRemoveDeviceInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSwitchKeyInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSwitchKeyInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateInd?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateInd

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticateCfm?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticateCfm

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRequestAppKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRequestAppKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetupPartner?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetupPartner

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_MasterKeyGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_MasterKeyGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeySet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeySet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationSet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationSet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAuthenticationCheck?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAuthenticationCheck

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_LinkKeyDataGet?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_LinkKeyDataGet

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??APSME_KeyFwdToChild?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    APSME_KeyFwdToChild

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAddLinkKey?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAddLinkKey

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrInitNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrInitNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrSetDefaultNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrSetDefaultNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrWriteNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrWriteNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrRestoreFromNV?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrRestoreFromNV

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??ZDSecMgrAPSRemove?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    ZDSecMgrAPSRemove
   3693          
   3694          /******************************************************************************
   3695          ******************************************************************************/
   3696          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     APSME_KeyFwdToChild                0      0      9
       -> AssocGetWithExt               0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     APSME_LinkKeyDataGet               0      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     APSME_LinkKeySet                   0      0     37
       -> ZDSecMgrEntryLookupExt        0      0     36
       -> osal_memcpy                   0      0     42
     APSME_MasterKeyGet                 0      0     11
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrMasterKeyLookup       0      0     22
     APSME_SKA_TimerExpired             0      0      0
     ZDSecMgrAPSRemove                  2      0     12
       -> ZDSecMgrDeviceRemove          4      0     20
     ZDSecMgrAddLinkKey                 0      0     20
       -> ZDSecMgrAddrStore             0      0     36
       -> ZDSecMgrEntryLookupAMI        0      0     32
       -> ZDSecMgrEntryNew              0      0     32
       -> APSME_LinkKeySet              0      0     32
       -> ZDSecMgrWriteNV               0      0     32
     ZDSecMgrAddrMgrUpdate              1      0     36
       -> AddrMgrEntryGet               0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAddrStore                  1      0     40
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrAppKeyGet                  1      0     17
       -> SSP_GetTrueRand               0      0     18
     ZDSecMgrAppKeyReq                  1      0     49
       -> APSME_LookupNwkAddr           0      0     98
       -> APSME_LookupExtAddr           0      0     98
       -> SSP_GetTrueRand               0      0     98
       -> APSME_TransportKeyReq         0      0     98
       -> APSME_TransportKeyReq         0      0     98
     ZDSecMgrAssocDeviceAuth            2      0     35
     ZDSecMgrAuthInitiate               1      0     16
       -> APSME_LookupNwkAddr           0      0     32
       -> APSME_AuthenticateReq         0      0     32
     ZDSecMgrAuthNwkKey                 2      0     10
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateCfm            2      0      0
       -> osal_set_event                4      0      0
     ZDSecMgrAuthenticateInd            1      0     32
       -> AddrMgrExtAddrSet             0      0     64
       -> AddrMgrEntryUpdate            0      0     64
       -> APSME_AuthenticateReq         0      0     64
     ZDSecMgrAuthenticationCheck        0      0      0
     ZDSecMgrAuthenticationSet          1      0     11
       -> ZDSecMgrEntryLookupExt        0      0     22
     ZDSecMgrConfig                     2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrCtrlAdd                    0      0     26
       -> ZDSecMgrCtrlSet               0      0     28
     ZDSecMgrCtrlInit                   3      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrCtrlLookup                 0      0     23
     ZDSecMgrCtrlRelease                3      0      0
     ZDSecMgrCtrlReset                  0      0     14
       -> ZDSecMgrCtrlLookup            0      0     24
       -> ZDSecMgrCtrlSet               0      0     28
       -> ZDSecMgrCtrlAdd               0      0     24
     ZDSecMgrCtrlSet                    1      0     23
     ZDSecMgrCtrlTerm                   3      0      2
       -> ZDSecMgrCtrlLookup            4      0      4
     ZDSecMgrDeviceCtrlHandler          1      0     42
       -> ZDSecMgrSendMasterKey         0      0     18
       -> ZDSecMgrEstablishKey          0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
       -> osal_start_timerEx            0      0     18
     ZDSecMgrDeviceCtrlSetup            3      0      0
       -> ZDSecMgrDeviceCtrlHandler     4      0      0
     ZDSecMgrDeviceCtrlUpdate           1      0     13
       -> ZDSecMgrEntryLookupExt        0      0     26
       -> ZDSecMgrCtrlLookup            0      0     26
     ZDSecMgrDeviceEntryAdd             0      0     28
       -> ZDSecMgrEntryLookup           0      0     28
       -> ZDSecMgrEntryLookupAMI        0      0     28
       -> ZDSecMgrAddrMgrUpdate         0      0     28
       -> ZDSecMgrEntryLookupAMI        0      0     28
       -> ZDSecMgrEntryNew              0      0     28
       -> ZDSecMgrAddrMgrUpdate         0      0     28
     ZDSecMgrDeviceEntryRemove          2      0      0
     ZDSecMgrDeviceJoin                 0      0     19
       -> ZDSecMgrDeviceValidate        0      0     18
       -> ZDSecMgrSendNwkKey            0      0     18
       -> ZDSecMgrDeviceRemove          0      0     18
     ZDSecMgrDeviceJoinDirect           0      0      9
       -> ZDSecMgrDeviceJoin            0      0     18
       -> AssocGetWithShort             0      0     18
       -> ZDSecMgrAssocDeviceAuth       0      0     18
     ZDSecMgrDeviceJoinFwd              3      0      8
       -> APSME_UpdateDeviceReq         4      0     16
     ZDSecMgrDeviceNew                  2      0     35
       -> ZDSecMgrDeviceJoinFwd         4      0      0
     ZDSecMgrDeviceRemove               1      0     38
       -> NLME_GetShortAddr             0      0     38
       -> AssocGetWithExt               0      0     38
       -> NLME_LeaveReq                 0      0     38
       -> APSME_RemoveDeviceReq         0      0     38
     ZDSecMgrDeviceValidate             3      0      9
       -> ZDSecMgrDeviceValidateRM      4      0      0
     ZDSecMgrDeviceValidateCM           0      0     16
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLoad         0      0     28
       -> ZDSecMgrDeviceEntryAdd        0      0     28
     ZDSecMgrDeviceValidateRM           2      0      0
     ZDSecMgrDeviceValidateSKKE         0      0     42
       -> ZDSecMgrExtAddrLookup         0      0     26
       -> ZDSecMgrMasterKeyLookup       0      0     26
       -> ZDSecMgrDeviceEntryAdd        0      0     26
     ZDSecMgrEntryFree                  2      0      0
     ZDSecMgrEntryInit                  2      0      0
       -> osal_mem_alloc                4      0      0
       -> ZDSecMgrRestoreFromNV         4      0      0
     ZDSecMgrEntryLookup                1      0     37
       -> AddrMgrEntryLookupNwk         0      0     46
     ZDSecMgrEntryLookupAMI             0      0     26
     ZDSecMgrEntryLookupExt             0      0     29
       -> ZDSecMgrExtAddrLookup         0      0     22
       -> ZDSecMgrEntryLookupAMI        0      0     22
     ZDSecMgrEntryNew                   1      0     26
     ZDSecMgrEstablishKey               1      0     26
       -> NLME_GetShortAddr             0      0     34
       -> APSME_EstablishKeyReq         0      0     34
     ZDSecMgrEstablishKeyCfm            0      0      0
     ZDSecMgrEstablishKeyInd            1      0     29
       -> ZDSecMgrTCDataLoad            0      0     58
       -> ZDSecMgrTCExtAddrCheck        0      0     58
       -> ZDSecMgrDeviceValidateSKKE
                                        0      0     58
       -> APSME_EstablishKeyRsp         0      0     58
     ZDSecMgrEvent                      1      0     33
       -> AddrMgrEntryGet               0      0     66
       -> ZDSecMgrDeviceCtrlHandler     0      0     66
       -> osal_start_timerEx            0      0     66
     ZDSecMgrExtAddrLookup              1      0     41
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryLookupExt         0      0     44
     ZDSecMgrExtAddrStore               1      0     24
       -> AddrMgrExtAddrSet             0      0     44
       -> AddrMgrEntryUpdate            0      0     44
     ZDSecMgrInit                       2      0      0
       -> APSME_SecurityNM              4      0      0
     ZDSecMgrInitNV                     0      0     12
       -> osal_nv_item_init             0      0     24
       -> ZDSecMgrSetDefaultNV          0      0     20
     ZDSecMgrMasterKeyInit              2      0      0
       -> osal_mem_alloc                4      0      0
     ZDSecMgrMasterKeyLoad              0      0     36
       -> ZDSecMgrExtAddrLookup         0      0     38
       -> ZDSecMgrMasterKeyLookup       0      0     38
       -> osal_memcpy                   0      0     44
       -> ZDSecMgrMasterKeyStore        0      0     38
     ZDSecMgrMasterKeyLookup            0      0     33
     ZDSecMgrMasterKeyStore             0      0     36
       -> osal_memcpy                   0      0     34
       -> osal_memset                   0      0     28
     ZDSecMgrNewDeviceEvent             1      0     35
       -> AssocMatchDeviceStatus        0      0     70
       -> ZDSecMgrAssocDeviceAuth       0      0     70
       -> AddrMgrEntryGet               0      0     70
       -> NLME_GetShortAddr             0      0     70
       -> ZDSecMgrDeviceNew             0      0     70
       -> AssocRemove                   0      0     70
     ZDSecMgrPermitJoining              2      0      0
     ZDSecMgrPermitJoiningTimeout       2      0      0
     ZDSecMgrRemoveDeviceInd            0      0     19
       -> APSME_LookupNwkAddr           0      0     38
       -> NLME_GetShortAddr             0      0     38
       -> ZDSecMgrDeviceRemove          0      0     38
     ZDSecMgrRequestAppKey              3      0     12
       -> AddrMgrExtAddrLookup          4      0     24
       -> APSME_RequestKeyReq           4      0     24
     ZDSecMgrRequestKeyInd              2      0      0
       -> ZDSecMgrAppKeyReq             4      0      0
     ZDSecMgrRestoreFromNV              0      0     19
       -> osal_nv_read                  0      0     38
       -> osal_nv_read                  0      0     38
       -> ZDSecMgrWriteNV               0      0     30
     ZDSecMgrSendMasterKey              1      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     46
       -> NLME_GetShortAddr             0      0     46
       -> APSME_TransportKeyReq         0      0     46
     ZDSecMgrSendNwkKey                 1      0     34
       -> NLME_GetShortAddr             0      0     50
       -> NLME_GetShortAddr             0      0     50
       -> APSME_TransportKeyReq         0      0     50
     ZDSecMgrSetDefaultNV               0      0     26
       -> osal_nv_write                 0      0     32
     ZDSecMgrSetupPartner               1      0     24
       -> AddrMgrExtAddrSet             0      0     48
       -> AddrMgrEntryUpdate            0      0     48
       -> ZDP_NwkAddrReq                0      0     48
       -> AddrMgrExtAddrValid           0      0     48
       -> ZDP_IEEEAddrReq               0      0     48
     ZDSecMgrSwitchKeyInd               2      0      0
       -> SSP_SwitchNwkKey              4      0      0
       -> ZDApp_NVUpdate                4      0      0
     ZDSecMgrTCDataLoad                 0      0     45
       -> ZDSecMgrAddrStore             0      0     32
       -> ZDSecMgrMasterKeyLookup       0      0     28
       -> ZDSecMgrMasterKeyStore        0      0     28
     ZDSecMgrTCExtAddrCheck             0      0     46
       -> AddrMgrExtAddrLookup          0      0     34
       -> AddrMgrExtAddrEqual           0      0     34
     ZDSecMgrTransportKeyInd            0      0     10
       -> ZDSecMgrTCDataLoad            0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> SSP_UpdateNwkKey              0      0     20
       -> SSP_SwitchNwkKey              0      0     20
       -> ZDSecMgrAuthNwkKey            0      0     20
     ZDSecMgrUpdateDeviceInd            2      0     10
       -> ZDSecMgrDeviceJoin            4      0     20
     ZDSecMgrWriteNV                    0      0     32
       -> osal_nv_write                 0      0     32
       -> osal_nv_write                 0      0     32


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     ZDSecMgrTCExtAddr                         8
     ZDSecMgrTCMasterKey                      16
     ZDSecMgrTCAuthenticated                   1
     ZDSecMgrTCDataLoaded                      1
     ZDSecMgrMasterKeyData                     2
     ZDSecMgrEntries                           2
     ZDSecMgrCtrlData                          2
     ZDSecMgrPermitJoiningEnabled              1
     ZDSecMgrPermitJoiningTimed                1
     TrustCenterLinkKey                       10
     ZDSecMgrMasterKeyInit                    61
     ?Subroutine2                              9
     ??Subroutine83_0                          5
     ?Subroutine62                            16
     ?Subroutine52                            11
     ??Subroutine97_0                          7
     ??Subroutine101_0                         6
     ZDSecMgrAddrStore                        55
     ?Subroutine44                            10
     ?Subroutine18                            17
     ?Subroutine13                             6
     ?Subroutine12                             6
     ?Subroutine48                            13
     ?Subroutine78                             5
     ?Subroutine63                             7
     ?Subroutine67                            11
     ??Subroutine92_0                          3
     ??Subroutine93_0                          5
     ?Subroutine65                             6
     ZDSecMgrExtAddrStore                     54
     ZDSecMgrExtAddrLookup                    61
     ZDSecMgrMasterKeyLookup                  81
     ?Subroutine80                             5
     ?Subroutine60                             8
     ??Subroutine84_0                          8
     ?Subroutine3                              5
     ??Subroutine85_0                         11
     ?Subroutine38                             4
     ??Subroutine104_0                         5
     ZDSecMgrMasterKeyStore                  143
     ?Subroutine24                             5
     ?Subroutine51                             7
     ?Subroutine71                             5
     ZDSecMgrEntryInit                        64
     ZDSecMgrEntryLookup                     116
     ?Subroutine81                             5
     ?Subroutine6                              5
     ??Subroutine86_0                          8
     ?Subroutine1                              4
     ??Subroutine98_0                          4
     ??Subroutine103_0                         3
     ?Subroutine58                             4
     ZDSecMgrEntryLookupAMI                   80
     ZDSecMgrEntryLookupExt                   48
     ?Subroutine73                             2
     ??Subroutine91_0                          2
     ?Subroutine55                             6
     ?Subroutine31                             7
     ZDSecMgrEntryFree                         3
     ?Subroutine66                            14
     ??Subroutine96_0                          1
     ZDSecMgrEntryNew                        111
     ?Subroutine39                            16
     ZDSecMgrCtrlInit                         70
     ZDSecMgrCtrlRelease                      17
     ZDSecMgrCtrlLookup                      110
     ??Subroutine100_0                         4
     ZDSecMgrCtrlSet                          86
     ?Subroutine10                             4
     ?Subroutine69                             6
     ?Subroutine32                             5
     ?Subroutine72                             5
     ?Subroutine61                             4
     ??Subroutine110_0                         4
     ??Subroutine111_0                         6
     ZDSecMgrCtrlAdd                         108
     ??Subroutine107_0                         5
     ZDSecMgrCtrlTerm                         41
     ??Subroutine87_0                          6
     ?Subroutine46                            11
     ZDSecMgrCtrlReset                        84
     ??Subroutine102_0                         2
     ZDSecMgrMasterKeyLoad                    98
     ??Subroutine94_0                          4
     ?Subroutine19                            15
     ?Subroutine33                            13
     ?Subroutine54                             9
     ZDSecMgrAppKeyType                        1
     ZDSecMgrAppKeyGet                        43
     ZDSecMgrAppKeyReq                       237
     ?Subroutine27                             6
     ?Subroutine17                             5
     ?Subroutine70                             5
     ?Subroutine68                             7
     ?Subroutine36                             4
     ?Subroutine42                            10
     ??Subroutine105_0                         6
     ZDSecMgrEstablishKey                     97
     ?Subroutine14                             6
     ??Subroutine88_0                          6
     ?Subroutine29                             7
     ??Subroutine108_0                         2
     ??Subroutine109_0                         2
     ZDSecMgrSendMasterKey                   128
     ?Subroutine8                             11
     ?Subroutine25                             6
     ?Subroutine4                              6
     ?Subroutine49                             2
     ?Subroutine34                             4
     ?Subroutine56                             4
     ?Subroutine64                             9
     ZDSecMgrSendNwkKey                      200
     ??Subroutine90_0                          6
     ?Subroutine7                              6
     ??Subroutine106_0                         3
     ?Subroutine47                            11
     ?Subroutine28                             6
     ZDSecMgrDeviceEntryRemove                 3
     ZDSecMgrAddrMgrUpdate                    66
     ZDSecMgrDeviceEntryAdd                  174
     ?Subroutine22                            13
     ?Subroutine11                             8
     ?Subroutine59                             1
     ?Subroutine53                            10
     ?Subroutine75                             2
     ?Subroutine26                             4
     ZDSecMgrDeviceCtrlHandler               118
     ?Subroutine21                             4
     ??Subroutine89_0                          4
     ?Subroutine50                             6
     ZDSecMgrDeviceCtrlSetup                  59
     ZDSecMgrDeviceCtrlUpdate                106
     ?Subroutine79                             5
     ?Subroutine57                             9
     APSME_SKA_TimerExpired                    3
     ZDSecMgrDeviceRemove                    181
     ?Subroutine15                             6
     ?Subroutine35                             7
     ZDSecMgrDeviceValidateSKKE               55
     ?Subroutine23                            13
     ZDSecMgrDeviceValidateRM                 17
     ZDSecMgrDeviceValidateCM                 87
     ZDSecMgrDeviceValidate                   48
     ZDSecMgrDeviceJoin                       36
     ?Subroutine82                             5
     ZDSecMgrDeviceJoinDirect                 28
     ZDSecMgrDeviceJoinFwd                   153
     ?Subroutine41                             3
     ??Subroutine95_0                          6
     ?Subroutine5                             13
     ZDSecMgrDeviceNew                         9
     ZDSecMgrAssocDeviceAuth                  25
     ZDSecMgrAuthInitiate                     66
     ZDSecMgrAuthNwkKey                       26
     ZDSecMgrInit                              0
     ?Subroutine76                             9
     ZDSecMgrConfig                            2
     ZDSecMgrPermitJoining                    40
     ZDSecMgrPermitJoiningTimeout             24
     ZDSecMgrNewDeviceEvent                  189
     ?Subroutine16                             3
     ??Subroutine99_0                          6
     ZDSecMgrEvent                           263
     ?Subroutine0                              8
     ?Subroutine40                            16
     ZDSecMgrEstablishKeyCfm                   3
     ZDSecMgrTCExtAddrCheck                   64
     ZDSecMgrTCDataLoad                       88
     ZDSecMgrEstablishKeyInd                 212
     ?Subroutine9                             11
     ?Subroutine43                            14
     ?Subroutine45                            11
     ZDSecMgrTransportKeyInd                 140
     ?Subroutine77                             2
     ZDSecMgrUpdateDeviceInd                  50
     ZDSecMgrRemoveDeviceInd                  84
     ZDSecMgrRequestKeyInd                    30
     ZDSecMgrSwitchKeyInd                     23
     ZDSecMgrAuthenticateInd                 130
     ZDSecMgrAuthenticateCfm                  46
     ZDSecMgrRequestAppKey                    69
     ZDSecMgrSetupPartner                    116
     APSME_MasterKeyGet                       58
     APSME_LinkKeySet                        122
     ?Subroutine30                             6
     ?Subroutine37                            10
     ZDSecMgrAuthenticationSet                52
     ZDSecMgrAuthenticationCheck               5
     APSME_LinkKeyDataGet                     85
     APSME_KeyFwdToChild                      62
     ZDSecMgrAddLinkKey                      135
     ZDSecMgrInitNV                           44
     ?Subroutine74                            38
     ZDSecMgrSetDefaultNV                     25
     ZDSecMgrWriteNV                         156
     ZDSecMgrRestoreFromNV                   203
     ZDSecMgrAPSRemove                        76
     ?Subroutine20                             6
     ?<Initializer for ZDSecMgrTCMasterKey>   16
     ?<Initializer for ZDSecMgrAppKeyType>     1
     __Constant_0                              4
     __Constant_b                              4
     ??ZDSecMgrMasterKeyInit?relay             6
     ??ZDSecMgrAddrStore?relay                 6
     ??ZDSecMgrExtAddrStore?relay              6
     ??ZDSecMgrExtAddrLookup?relay             6
     ??ZDSecMgrMasterKeyLookup?relay           6
     ??ZDSecMgrMasterKeyStore?relay            6
     ??ZDSecMgrEntryInit?relay                 6
     ??ZDSecMgrEntryLookup?relay               6
     ??ZDSecMgrEntryLookupAMI?relay            6
     ??ZDSecMgrEntryLookupExt?relay            6
     ??ZDSecMgrEntryFree?relay                 6
     ??ZDSecMgrEntryNew?relay                  6
     ??ZDSecMgrCtrlInit?relay                  6
     ??ZDSecMgrCtrlRelease?relay               6
     ??ZDSecMgrCtrlLookup?relay                6
     ??ZDSecMgrCtrlSet?relay                   6
     ??ZDSecMgrCtrlAdd?relay                   6
     ??ZDSecMgrCtrlTerm?relay                  6
     ??ZDSecMgrCtrlReset?relay                 6
     ??ZDSecMgrMasterKeyLoad?relay             6
     ??ZDSecMgrAppKeyGet?relay                 6
     ??ZDSecMgrAppKeyReq?relay                 6
     ??ZDSecMgrEstablishKey?relay              6
     ??ZDSecMgrSendMasterKey?relay             6
     ??ZDSecMgrSendNwkKey?relay                6
     ??ZDSecMgrDeviceEntryRemove?relay         6
     ??ZDSecMgrAddrMgrUpdate?relay             6
     ??ZDSecMgrDeviceEntryAdd?relay            6
     ??ZDSecMgrDeviceCtrlHandler?relay         6
     ??ZDSecMgrDeviceCtrlSetup?relay           6
     ??ZDSecMgrDeviceCtrlUpdate?relay          6
     ??APSME_SKA_TimerExpired?relay            6
     ??ZDSecMgrDeviceRemove?relay              6
     ??ZDSecMgrDeviceValidateSKKE?relay        6
     ??ZDSecMgrDeviceValidateRM?relay          6
     ??ZDSecMgrDeviceValidateCM?relay          6
     ??ZDSecMgrDeviceValidate?relay            6
     ??ZDSecMgrDeviceJoin?relay                6
     ??ZDSecMgrDeviceJoinDirect?relay          6
     ??ZDSecMgrDeviceJoinFwd?relay             6
     ??ZDSecMgrDeviceNew?relay                 6
     ??ZDSecMgrAssocDeviceAuth?relay           6
     ??ZDSecMgrAuthInitiate?relay              6
     ??ZDSecMgrAuthNwkKey?relay                6
     ??ZDSecMgrInit?relay                      6
     ??ZDSecMgrConfig?relay                    6
     ??ZDSecMgrPermitJoining?relay             6
     ??ZDSecMgrPermitJoiningTimeout?relay      6
     ??ZDSecMgrNewDeviceEvent?relay            6
     ??ZDSecMgrEvent?relay                     6
     ??ZDSecMgrEstablishKeyCfm?relay           6
     ??ZDSecMgrTCExtAddrCheck?relay            6
     ??ZDSecMgrTCDataLoad?relay                6
     ??ZDSecMgrEstablishKeyInd?relay           6
     ??ZDSecMgrTransportKeyInd?relay           6
     ??ZDSecMgrUpdateDeviceInd?relay           6
     ??ZDSecMgrRemoveDeviceInd?relay           6
     ??ZDSecMgrRequestKeyInd?relay             6
     ??ZDSecMgrSwitchKeyInd?relay              6
     ??ZDSecMgrAuthenticateInd?relay           6
     ??ZDSecMgrAuthenticateCfm?relay           6
     ??ZDSecMgrRequestAppKey?relay             6
     ??ZDSecMgrSetupPartner?relay              6
     ??APSME_MasterKeyGet?relay                6
     ??APSME_LinkKeySet?relay                  6
     ??ZDSecMgrAuthenticationSet?relay         6
     ??ZDSecMgrAuthenticationCheck?relay       6
     ??APSME_LinkKeyDataGet?relay              6
     ??APSME_KeyFwdToChild?relay               6
     ??ZDSecMgrAddLinkKey?relay                6
     ??ZDSecMgrInitNV?relay                    6
     ??ZDSecMgrSetDefaultNV?relay              6
     ??ZDSecMgrWriteNV?relay                   6
     ??ZDSecMgrRestoreFromNV?relay             6
     ??ZDSecMgrAPSRemove?relay                 6

 
 6 841 bytes in segment BANKED_CODE
   450 bytes in segment BANK_RELAYS
    17 bytes in segment XDATA_I
    17 bytes in segment XDATA_ID
     8 bytes in segment XDATA_ROM_C
    28 bytes in segment XDATA_Z
 
 7 308 bytes of CODE  memory
     0 bytes of CONST memory (+ 8 bytes shared)
    45 bytes of XDATA memory

Errors: none
Warnings: none
