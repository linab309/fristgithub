###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                29/Sep/2011  16:35:24 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\LightCtlPrj\Source\LightCtl.c #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0 #
#                          \Projects\zstack\Samples\LightCtlPrj\CC2530DB\..\. #
#                          .\..\Tools\CC2530DB\f8wEndev.cfg" (-DCPU32MHZ      #
#                          -DROOT=__near_func -DBLINK_LEDS) -f "C:\Texas      #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wConfig.cfg" (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00001000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1212                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\LightCtlPrj\Source\LightCtl. #
#                          c" -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D      #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -D HAL_UART=TRUE -D xPOWER_SAVING -lC "C:\Texas    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\EndDeviceEB\List\ #
#                          " -lA "C:\Texas Instruments\ZStack-CC2530-2.2.2-1. #
#                          3.0\Projects\zstack\Samples\LightCtlPrj\CC2530DB\E #
#                          ndDeviceEB\List\" --diag_suppress Pe001,Pa010 -o   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevi #
#                          ceEB\Obj\" -e --require_prototypes --debug         #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\" -I "C:\Texas    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\SOURCE\" -I    #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\LightCtlPrj\CC2530DB\..\..\. #
#                          .\ZMAIN\TI2530DB\" -I "C:\Texas                    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MT\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\TARGET\CC2530EB\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\INCLUDE\" -I "C:\Texas               #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\AF\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\NWK\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SEC\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SAPI\" -I "C:\Texas                 #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SYS\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\ZDO\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\F8W\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SADDR\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SDATA\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I      #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3\8051\INC\" -I "C:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevic #
#                          eEB\List\LightCtl.lst                              #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevic #
#                          eEB\Obj\LightCtl.r51                               #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zstack\Samples\LightCtlPrj\Source\LightCtl.c
      1          /**************************************************************************************************
      2            Filename:       LightCtl.c
      3            Revised:        $Date: 2009-03-18 15:56:27 -0700 (Wed, 18 Mar 2009) $
      4            Revision:       $Revision: 19453 $
      5          
      6            Description:    Generic Application (no Profile).
      7          
      8          
      9            Copyright 2004-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE, 
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com. 
     38          **************************************************************************************************/
     39          
     40          /*********************************************************************
     41            This application isn't intended to do anything useful, it is
     42            intended to be a simple example of an application's structure.
     43          
     44            This application sends "Hello World" to another "Generic"
     45            application every 15 seconds.  The application will also
     46            receive "Hello World" packets.
     47          
     48            The "Hello World" messages are sent/received as MSG type message.
     49          
     50            This applications doesn't have a profile, so it handles everything
     51            directly - itself.
     52          
     53            Key control:
     54              SW1:
     55              SW2:  initiates end device binding
     56              SW3:
     57              SW4:  initiates a match description request
     58          *********************************************************************/
     59          
     60          /*********************************************************************
     61           * INCLUDES
     62           */
     63          #include "OSAL.h"
     64          #include "AF.h"
     65          #include "ZDApp.h"
     66          #include "ZDObject.h"
     67          #include "ZDProfile.h"
     68          
     69          #include "LightCtl.h"
     70          #include "DebugTrace.h"
     71          
     72          #if !defined( WIN32 )
     73            #include "OnBoard.h"
     74          #endif
     75          
     76          /* HAL */
     77          #include "hal_lcd.h"
     78          #include "hal_led.h"
     79          #include "hal_key.h"
     80          #include "hal_uart.h"
     81          
     82          /*********************************************************************
     83           * MACROS
     84           */
     85          
     86          /*********************************************************************
     87           * CONSTANTS
     88           */
     89          
     90          /*********************************************************************
     91           * TYPEDEFS
     92           */
     93          #if !defined( SERIAL_APP_PORT )
     94          #define SERIAL_APP_PORT  0
     95          #endif
     96          
     97          #if !defined( SERIAL_APP_BAUD )
     98          #define SERIAL_APP_BAUD  HAL_UART_BR_38400
     99          //#define SERIAL_APP_BAUD  HAL_UART_BR_115200
    100          #endif
    101          
    102          // When the Rx buf space is less than this threshold, invoke the Rx callback.
    103          #if !defined( SERIAL_APP_THRESH )
    104          #define SERIAL_APP_THRESH  64
    105          #endif
    106          
    107          #if !defined( SERIAL_APP_RX_SZ )
    108          #define SERIAL_APP_RX_SZ  128
    109          #endif
    110          
    111          #if !defined( SERIAL_APP_TX_SZ )
    112          #define SERIAL_APP_TX_SZ  128
    113          #endif
    114          
    115          // Millisecs of idle time after a byte is received before invoking Rx callback.
    116          #if !defined( SERIAL_APP_IDLE )
    117          #define SERIAL_APP_IDLE  6
    118          #endif
    119          
    120          // Loopback Rx bytes to Tx for throughput testing.
    121          #if !defined( SERIAL_APP_LOOPBACK )
    122          #define SERIAL_APP_LOOPBACK  FALSE
    123          #endif
    124          
    125          // This is the max byte count per OTA message.
    126          #if !defined( SERIAL_APP_TX_MAX )
    127          #define SERIAL_APP_TX_MAX  80
    128          #endif
    129          
    130          /*********************************************************************
    131           * GLOBAL VARIABLES
    132           */
    133          
    134          //static uint8 SerialApp_Buf[SERIAL_APP_TX_MAX+1];
    135          //static uint8 SerialApp_Len;
    136          //static uint8 SerialApp_TxSeq;
    137          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    138          static  uint8  rxlen;        //接收数据长度
   \                     rxlen:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    139          static  uint8*  databuf;  //接收数据指针
   \                     databuf:
   \   000000                DS 2
   \   000002                REQUIRE __INIT_XDATA_Z
    140          
    141          
    142          
    143          //static uint8 SerialApp_RxSeq;
    144          //static uint8 SerialApp_RspBuf[SERIAL_APP_RSP_CNT];
    145          
    146          
    147          // This list should be filled with Application specific Cluster IDs.

   \                                 In  segment XDATA_ROM_C, align 1
    148          const cId_t LightCtl_ClusterList[LightCtl_MAX_CLUSTERS] =
   \                     LightCtl_ClusterList:
   \   000000   0100         DW 1
    149          {
    150            LightCtl_CLUSTERID
    151          };
    152          

   \                                 In  segment XDATA_ROM_C, align 1
    153          const SimpleDescriptionFormat_t LightCtl_SimpleDesc =
   \                     LightCtl_SimpleDesc:
   \   000000   0A           DB 10
   \   000001   040F0100     DW 3844, 1
   \   000005   0001         DB 0, 1
   \   000007   ....         DW LightCtl_ClusterList
   \   000009   01           DB 1
   \   00000A   ....         DW LightCtl_ClusterList
    154          {
    155            LightCtl_ENDPOINT,              //  int Endpoint;
    156            LightCtl_PROFID,                //  uint16 AppProfId[2];
    157            LightCtl_DEVICEID,              //  uint16 AppDeviceId[2];
    158            LightCtl_DEVICE_VERSION,        //  int   AppDevVer:4;
    159            LightCtl_FLAGS,                 //  int   AppFlags:4;
    160            LightCtl_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    161            (cId_t *)LightCtl_ClusterList,  //  byte *pAppInClusterList;
    162            LightCtl_MAX_CLUSTERS,          //  byte  AppNumInClusters;
    163            (cId_t *)LightCtl_ClusterList   //  byte *pAppInClusterList;
    164          };
    165          
    166          // This is the Endpoint/Interface description.  It is defined here, but
    167          // filled-in in LightCtl_Init().  Another way to go would be to fill
    168          // in the structure here and make it a "const" (in code space).  The
    169          // way it's defined in this sample app it is define in RAM.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    170          endPointDesc_t LightCtl_epDesc;
   \                     LightCtl_epDesc:
   \   000000                DS 6
   \   000006                REQUIRE __INIT_XDATA_Z
    171          
    172          /*********************************************************************
    173           * EXTERNAL VARIABLES
    174           */
    175          
    176          /*********************************************************************
    177           * EXTERNAL FUNCTIONS
    178           */
    179          
    180          /*********************************************************************
    181           * LOCAL VARIABLES
    182           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    183          byte LightCtl_TaskID;   // Task ID for internal task/event processing
   \                     LightCtl_TaskID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    184                                    // This variable will be received when
    185                                    // LightCtl_Init() is called.

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    186          devStates_t LightCtl_NwkState;
   \                     LightCtl_NwkState:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    187          
    188          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    189          byte LightCtl_TransID;  // This is the unique message ID (counter)
   \                     LightCtl_TransID:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    190          

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    191          afAddrType_t LightCtl_DstAddr;
   \                     LightCtl_DstAddr:
   \   000000                DS 12
   \   00000C                REQUIRE __INIT_XDATA_Z
    192          
    193          /*********************************************************************
    194           * LOCAL FUNCTIONS
    195           */
    196          void LightCtl_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
    197          void LightCtl_HandleKeys( byte shift, byte keys );
    198          void LightCtl_MessageMSGCB( afIncomingMSGPacket_t *pckt );
    199          void LightCtl_SendTheMessage( void );
    200          
    201          /*********************************************************************
    202           * NETWORK LAYER CALLBACKS
    203           */
    204          
    205          /*********************************************************************
    206           * PUBLIC FUNCTIONS
    207           */
    208          static void SerialApp_CallBack(uint8 port, uint8 event);
    209          
    210          uint8 hextoword1(uint8 t );
    211          uint8 hextoword2(uint8 t);
    212          void UartShowNtkInfo(uint16 short_ddr,uint8 *pIeeeAddrBuf);
    213          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    214          uint8 hextoword1(uint8 t )
   \                     hextoword1:
    215          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    216            uint8 abc;
    217            uint8 cba;
    218            uint8 xx1;
    219            abc=t;
    220            cba=0xf0;
    221            abc=(abc&cba)>>4;
   \   000000   E9           MOV     A,R1
   \   000001   C4           SWAP    A
   \   000002   540F         ANL     A,#0xf
   \   000004   FA           MOV     R2,A
    222            if(abc<10)
   \   000005   C3           CLR     C
   \   000006   940A         SUBB    A,#0xa
   \   000008   5004         JNC     ??hextoword1_0
    223            {
    224              xx1=abc+48;
   \   00000A   7430         MOV     A,#0x30
   \   00000C   8002         SJMP    ??hextoword1_1
    225            }
    226            else
    227            {
    228              xx1=abc+55;
   \                     ??hextoword1_0:
   \   00000E   7437         MOV     A,#0x37
    229            }
   \                     ??hextoword1_1:
   \   000010                REQUIRE ?Subroutine9
   \   000010                ; // Fall through to label ?Subroutine9
    230            return xx1;
    231          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   2A           ADD     A,R2
   \   000001   F9           MOV     R1,A
   \   000002   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    232          uint8 hextoword2(uint8 t)
   \                     hextoword2:
    233          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    234            uint8 abc;
    235            uint8 cba;
    236            uint8 xx2;
    237            abc=t;
    238            cba=0x0f;
    239            abc=abc&cba;
   \   000000   740F         MOV     A,#0xf
   \   000002   59           ANL     A,R1
   \   000003   FA           MOV     R2,A
    240            if(abc<10)
   \   000004   C3           CLR     C
   \   000005   940A         SUBB    A,#0xa
   \   000007   5004         JNC     ??hextoword2_0
    241            {
    242              xx2=abc+48;
   \   000009   7430         MOV     A,#0x30
   \   00000B   8002         SJMP    ??hextoword2_1
    243            }
    244            else
    245            {
    246              xx2=abc+55;
   \                     ??hextoword2_0:
   \   00000D   7437         MOV     A,#0x37
    247            }
   \                     ??hextoword2_1:
   \   00000F   80..         SJMP    ?Subroutine9
    248            return xx2;
    249          }
    250          

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    251          void UartShowNtkInfo(uint16 short_ddr,uint8 *pIeeeAddrBuf)
   \                     UartShowNtkInfo:
    252          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 97
   \   000005   749F         MOV     A,#-0x61
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EC           MOV     A,R4
   \   00000B   FE           MOV     R6,A
   \   00000C   ED           MOV     A,R5
   \   00000D   FF           MOV     R7,A
    253            //  显示网络地址变量
    254              uint8 yy1;
    255              uint8 yy2;
    256              uint8 str_1[ ]="my short address is:";
   \   00000E   744C         MOV     A,#0x4c
   \   000010   12....       LCALL   ?XSTACK_DISP0_8
   \   000013   AC82         MOV     R4,DPL
   \   000015   AD83         MOV     R5,DPH
   \   000017   7583..       MOV     DPH,#((`?<Constant "my short address is:">` >> 8) & 0xff)
   \   00001A   7582..       MOV     DPL,#(`?<Constant "my short address is:">` & 0xff)
   \   00001D   7415         MOV     A,#0x15
   \   00001F   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    257            #if defined(ZDO_COORDINATOR)
    258              uint8 str_2[ ]="build the network successfully";
    259            #else 
    260              uint8 str_2[ ]="join the network successfully ";
   \   000022   742D         MOV     A,#0x2d
   \   000024   12....       LCALL   ?XSTACK_DISP0_8
   \   000027   AC82         MOV     R4,DPL
   \   000029   AD83         MOV     R5,DPH
   \   00002B   7583..       MOV     DPH,#((`?<Constant "join the network succ...">` >> 8) & 0xff)
   \   00002E   7582..       MOV     DPL,#(`?<Constant "join the network succ...">` & 0xff)
   \   000031   741F         MOV     A,#0x1f
   \   000033   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    261            #endif
    262              uint8 str_3[ ]={' '};
   \   000036   85..82       MOV     DPL,?XSP + 0
   \   000039   85..83       MOV     DPH,?XSP + 1
   \   00003C   AC82         MOV     R4,DPL
   \   00003E   AD83         MOV     R5,DPH
   \   000040   7583..       MOV     DPH,#((`?<Constant {32}>` >> 8) & 0xff)
   \   000043   7582..       MOV     DPL,#(`?<Constant {32}>` & 0xff)
   \   000046   7401         MOV     A,#0x1
   \   000048   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    263              uint8 str_4[ ]="my ieee address is:";
   \   00004B   7419         MOV     A,#0x19
   \   00004D   12....       LCALL   ?XSTACK_DISP0_8
   \   000050   AC82         MOV     R4,DPL
   \   000052   AD83         MOV     R5,DPH
   \   000054   7583..       MOV     DPH,#((`?<Constant "my ieee address is:">` >> 8) & 0xff)
   \   000057   7582..       MOV     DPL,#(`?<Constant "my ieee address is:">` & 0xff)
   \   00005A   7414         MOV     A,#0x14
   \   00005C   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    264              uint8 shortaddr[7];
    265              uint8 *pointer1;
    266              uint8 *pointer2;
    267              uint8 *pointer3;
    268              uint8 *pointer4;
    269              
    270              //显示本地网络地址
    271              //显示本地网络地址
    272              //short_ddr=NLME_GetShortAddr();
    273              yy1=(uint8)((short_ddr&0xff00)>>8);
   \   00005F   EB           MOV     A,R3
   \   000060   F9           MOV     R1,A
   \   000061   F5..         MOV     ?V0 + 0,A
    274              yy2=(uint8)short_ddr;
   \   000063   EA           MOV     A,R2
   \   000064   F5..         MOV     ?V0 + 1,A
    275              shortaddr[0]=48;
   \   000066   7401         MOV     A,#0x1
   \   000068   12....       LCALL   ?XSTACK_DISP0_8
   \   00006B   7430         MOV     A,#0x30
   \   00006D   F0           MOVX    @DPTR,A
    276              shortaddr[1]=120;
   \   00006E   7402         MOV     A,#0x2
   \   000070   12....       LCALL   ?XSTACK_DISP0_8
   \   000073   7478         MOV     A,#0x78
   \   000075   F0           MOVX    @DPTR,A
    277              shortaddr[2]=hextoword1(yy1);
   \   000076                ; Setup parameters for call to function hextoword1
   \   000076   12....       LCALL   ??hextoword1?relay
   \   000079   7403         MOV     A,#0x3
   \   00007B   12....       LCALL   ?XSTACK_DISP0_8
   \   00007E   E9           MOV     A,R1
   \   00007F   F0           MOVX    @DPTR,A
    278              shortaddr[3]=hextoword2(yy1);
   \   000080                ; Setup parameters for call to function hextoword2
   \   000080   A9..         MOV     R1,?V0 + 0
   \   000082   12....       LCALL   ??hextoword2?relay
   \   000085   7404         MOV     A,#0x4
   \   000087   12....       LCALL   ?XSTACK_DISP0_8
   \   00008A   E9           MOV     A,R1
   \   00008B   F0           MOVX    @DPTR,A
    279              shortaddr[4]=hextoword1(yy2);
   \   00008C                ; Setup parameters for call to function hextoword1
   \   00008C   A9..         MOV     R1,?V0 + 1
   \   00008E   12....       LCALL   ??hextoword1?relay
   \   000091   7405         MOV     A,#0x5
   \   000093   12....       LCALL   ?XSTACK_DISP0_8
   \   000096   E9           MOV     A,R1
   \   000097   F0           MOVX    @DPTR,A
    280              shortaddr[5]=hextoword2(yy2);
   \   000098                ; Setup parameters for call to function hextoword2
   \   000098   A9..         MOV     R1,?V0 + 1
   \   00009A   12....       LCALL   ??hextoword2?relay
   \   00009D   7406         MOV     A,#0x6
   \   00009F   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A2   E9           MOV     A,R1
   \   0000A3   F0           MOVX    @DPTR,A
    281              shortaddr[6]='\n';
   \   0000A4   7407         MOV     A,#0x7
   \   0000A6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A9   740A         MOV     A,#0xa
   \   0000AB   F0           MOVX    @DPTR,A
    282              pointer1=&shortaddr[0];
    283              pointer2=&str_1[0];
    284              pointer3=&str_2[0];
    285              pointer4=&str_3[0];
    286              HalUARTWrite(0,pointer4,1); 
   \   0000AC                ; Setup parameters for call to function HalUARTWrite
   \   0000AC   7C01         MOV     R4,#0x1
   \   0000AE   7D00         MOV     R5,#0x0
   \   0000B0   85..82       MOV     DPL,?XSP + 0
   \   0000B3   85..83       MOV     DPH,?XSP + 1
   \   0000B6   AA82         MOV     R2,DPL
   \   0000B8   AB83         MOV     R3,DPH
   \   0000BA   7900         MOV     R1,#0x0
   \   0000BC   12....       LCALL   ??HalUARTWrite?relay
    287              HalUARTWrite(0,pointer3,29);
   \   0000BF                ; Setup parameters for call to function HalUARTWrite
   \   0000BF   7C1D         MOV     R4,#0x1d
   \   0000C1   7D00         MOV     R5,#0x0
   \   0000C3   742D         MOV     A,#0x2d
   \   0000C5   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C8   12....       LCALL   ?Subroutine0 & 0xFFFF
    288              HalUARTWrite(0,pointer4,1);            
    289              HalUARTWrite(0,pointer2,20);            
   \                     ??CrossCallReturnLabel_0:
   \   0000CB                ; Setup parameters for call to function HalUARTWrite
   \   0000CB   7C14         MOV     R4,#0x14
   \   0000CD   7D00         MOV     R5,#0x0
   \   0000CF   744C         MOV     A,#0x4c
   \   0000D1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000D4   AA82         MOV     R2,DPL
   \   0000D6   AB83         MOV     R3,DPH
   \   0000D8   7900         MOV     R1,#0x0
   \   0000DA   12....       LCALL   ??HalUARTWrite?relay
    290              HalUARTWrite(0,pointer1,7);
   \   0000DD                ; Setup parameters for call to function HalUARTWrite
   \   0000DD   7C07         MOV     R4,#0x7
   \   0000DF   7D00         MOV     R5,#0x0
   \   0000E1   7401         MOV     A,#0x1
   \   0000E3   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E6   12....       LCALL   ?Subroutine0 & 0xFFFF
    291              HalUARTWrite(0,pointer4,1); 
    292            
    293              
    294              uint8 i;
    295              uint8 *xad;
    296              uint8 ieeeAddr_buf[Z_EXTADDR_LEN*2+1];
    297            
    298              // Display the extended address.
    299              //xad = aExtendedAddress + Z_EXTADDR_LEN - 1;
    300              xad = pIeeeAddrBuf;
    301            
    302              for (i = 0; i < Z_EXTADDR_LEN*2; xad--)
   \                     ??CrossCallReturnLabel_1:
   \   0000E9   7A00         MOV     R2,#0x0
    303              {
    304                uint8 ch;
    305                ch = (*xad >> 4) & 0x0F;
   \                     ??UartShowNtkInfo_0:
   \   0000EB   8E82         MOV     DPL,R6
   \   0000ED   8F83         MOV     DPH,R7
   \   0000EF   E0           MOVX    A,@DPTR
   \   0000F0   C4           SWAP    A
   \   0000F1   12....       LCALL   ?Subroutine4 & 0xFFFF
    306                ieeeAddr_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
   \                     ??CrossCallReturnLabel_12:
   \   0000F4   5004         JNC     ??UartShowNtkInfo_1
   \   0000F6   7830         MOV     R0,#0x30
   \   0000F8   8002         SJMP    ??UartShowNtkInfo_2
   \                     ??UartShowNtkInfo_1:
   \   0000FA   7837         MOV     R0,#0x37
   \                     ??UartShowNtkInfo_2:
   \   0000FC   E8           MOV     A,R0
   \   0000FD   2B           ADD     A,R3
   \   0000FE   C0E0         PUSH    A
   \   000100   7408         MOV     A,#0x8
   \   000102   12....       LCALL   ?XSTACK_DISP0_8
   \   000105   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_14:
   \   000108   D0E0         POP     A
   \   00010A   F0           MOVX    @DPTR,A
    307                ch = *xad & 0x0F;
   \   00010B   8E82         MOV     DPL,R6
   \   00010D   8F83         MOV     DPH,R7
   \   00010F   E0           MOVX    A,@DPTR
   \   000110   12....       LCALL   ?Subroutine4 & 0xFFFF
    308                ieeeAddr_buf[i++] = ch + (( ch < 10 ) ? '0' : '7');
    309              }
   \                     ??CrossCallReturnLabel_13:
   \   000113   5004         JNC     ??UartShowNtkInfo_3
   \   000115   7830         MOV     R0,#0x30
   \   000117   8002         SJMP    ??UartShowNtkInfo_4
   \                     ??UartShowNtkInfo_3:
   \   000119   7837         MOV     R0,#0x37
   \                     ??UartShowNtkInfo_4:
   \   00011B   E8           MOV     A,R0
   \   00011C   2B           ADD     A,R3
   \   00011D   C0E0         PUSH    A
   \   00011F   7408         MOV     A,#0x8
   \   000121   12....       LCALL   ?XSTACK_DISP0_8
   \   000124   12....       LCALL   ?Subroutine5 & 0xFFFF
   \                     ??CrossCallReturnLabel_15:
   \   000127   D0E0         POP     A
   \   000129   F0           MOVX    @DPTR,A
   \   00012A   EE           MOV     A,R6
   \   00012B   24FF         ADD     A,#-0x1
   \   00012D   1E           DEC     R6
   \   00012E   EF           MOV     A,R7
   \   00012F   34FF         ADDC    A,#-0x1
   \   000131   FF           MOV     R7,A
   \   000132   EA           MOV     A,R2
   \   000133   C3           CLR     C
   \   000134   9410         SUBB    A,#0x10
   \   000136   40B3         JC      ??UartShowNtkInfo_0
    310              ieeeAddr_buf[Z_EXTADDR_LEN*2] = '\0';
   \   000138   7418         MOV     A,#0x18
   \   00013A   12....       LCALL   ?XSTACK_DISP0_8
   \   00013D   E4           CLR     A
   \   00013E   F0           MOVX    @DPTR,A
    311              HalUARTWrite(0,pointer4,1); 
   \   00013F                ; Setup parameters for call to function HalUARTWrite
   \   00013F   7C01         MOV     R4,#0x1
   \   000141   FD           MOV     R5,A
   \   000142   85..82       MOV     DPL,?XSP + 0
   \   000145   85..83       MOV     DPH,?XSP + 1
   \   000148   AA82         MOV     R2,DPL
   \   00014A   AB83         MOV     R3,DPH
   \   00014C   F9           MOV     R1,A
   \   00014D   12....       LCALL   ??HalUARTWrite?relay
    312              HalUARTWrite(0,str_4,19);
   \   000150                ; Setup parameters for call to function HalUARTWrite
   \   000150   7C13         MOV     R4,#0x13
   \   000152   7D00         MOV     R5,#0x0
   \   000154   7419         MOV     A,#0x19
   \   000156   12....       LCALL   ?XSTACK_DISP0_8
   \   000159   AA82         MOV     R2,DPL
   \   00015B   AB83         MOV     R3,DPH
   \   00015D   7900         MOV     R1,#0x0
   \   00015F   12....       LCALL   ??HalUARTWrite?relay
    313              HalUARTWrite(0,ieeeAddr_buf,Z_EXTADDR_LEN*2);
   \   000162                ; Setup parameters for call to function HalUARTWrite
   \   000162   7C10         MOV     R4,#0x10
   \   000164   7D00         MOV     R5,#0x0
   \   000166   7408         MOV     A,#0x8
   \   000168   12....       LCALL   ?XSTACK_DISP0_8
   \   00016B   12....       LCALL   ?Subroutine0 & 0xFFFF
    314              HalUARTWrite(0,pointer4,1);
    315          }
   \                     ??CrossCallReturnLabel_2:
   \   00016E   7461         MOV     A,#0x61
   \   000170   02....       LJMP    ?Subroutine10 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   E582         MOV     A,DPL
   \   000002   25..         ADD     A,?V0 + 0
   \   000004   F582         MOV     DPL,A
   \   000006   E583         MOV     A,DPH
   \   000008   3400         ADDC    A,#0x0
   \   00000A   F583         MOV     DPH,A
   \   00000C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   540F         ANL     A,#0xf
   \   000002   FB           MOV     R3,A
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   0A           INC     R2
   \   000006   C3           CLR     C
   \   000007   940A         SUBB    A,#0xa
   \   000009   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   AA82         MOV     R2,DPL
   \   000002   AB83         MOV     R3,DPH
   \   000004   7900         MOV     R1,#0x0
   \   000006   12....       LCALL   ??HalUARTWrite?relay
   \   000009                ; Setup parameters for call to function HalUARTWrite
   \   000009                ; Setup parameters for call to function HalUARTWrite
   \   000009                ; Setup parameters for call to function HalUARTWrite
   \   000009   7C01         MOV     R4,#0x1
   \   00000B   7D00         MOV     R5,#0x0
   \   00000D   85..82       MOV     DPL,?XSP + 0
   \   000010   85..83       MOV     DPH,?XSP + 1
   \   000013   AA82         MOV     R2,DPL
   \   000015   AB83         MOV     R3,DPH
   \   000017   7900         MOV     R1,#0x0
   \   000019   12....       LCALL   ??HalUARTWrite?relay
   \   00001C   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine10:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003                REQUIRE ??Subroutine11_0
   \   000003                ; // Fall through to label ??Subroutine11_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine11_0:
   \   000000   7F02         MOV     R7,#0x2
   \   000002   02....       LJMP    ?BANKED_LEAVE_XDATA
    316          
    317          
    318          /*********************************************************************
    319           * @fn      LightCtl_Init
    320           *
    321           * @brief   Initialization function for the Generic App Task.
    322           *          This is called during initialization and should contain
    323           *          any application specific initialization (ie. hardware
    324           *          initialization/setup, table initialization, power up
    325           *          notificaiton ... ).
    326           *
    327           * @param   task_id - the ID assigned by OSAL.  This ID should be
    328           *                    used to send messages and set timers.
    329           *
    330           * @return  none
    331           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    332          void LightCtl_Init( byte task_id )
   \                     LightCtl_Init:
    333          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 29
   \   000004   74E3         MOV     A,#-0x1d
   \   000006   12....       LCALL   ?ALLOC_XSTACK8
    334            LightCtl_TaskID = task_id;
   \   000009   E9           MOV     A,R1
   \   00000A   90....       MOV     DPTR,#LightCtl_TaskID
   \   00000D   F0           MOVX    @DPTR,A
    335            LightCtl_NwkState = DEV_INIT;
   \   00000E   7401         MOV     A,#0x1
   \   000010   90....       MOV     DPTR,#LightCtl_NwkState
   \   000013   F0           MOVX    @DPTR,A
    336            LightCtl_TransID = 0;
   \   000014   E4           CLR     A
   \   000015   90....       MOV     DPTR,#LightCtl_TransID
   \   000018   F0           MOVX    @DPTR,A
    337          
    338            // Device hardware initialization can be added here or in main() (Zmain.c).
    339            // If the hardware is application specific - add it here.
    340            // If the hardware is other parts of the device add it in main().
    341          
    342            LightCtl_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000019   12....       LCALL   ?Subroutine2 & 0xFFFF
    343            LightCtl_DstAddr.endPoint = LightCtl_ENDPOINT;
    344            LightCtl_DstAddr.addr.shortAddr = 0x00;
    345          
    346            // Fill out the endpoint description.
    347            LightCtl_epDesc.endPoint = LightCtl_ENDPOINT;
   \                     ??CrossCallReturnLabel_8:
   \   00001C   740A         MOV     A,#0xa
   \   00001E   90....       MOV     DPTR,#LightCtl_epDesc
   \   000021   F0           MOVX    @DPTR,A
    348            LightCtl_epDesc.task_id = &LightCtl_TaskID;
   \   000022   90....       MOV     DPTR,#(LightCtl_epDesc + 1)
   \   000025   74..         MOV     A,#(LightCtl_TaskID & 0xff)
   \   000027   F0           MOVX    @DPTR,A
   \   000028   A3           INC     DPTR
   \   000029   74..         MOV     A,#((LightCtl_TaskID >> 8) & 0xff)
   \   00002B   F0           MOVX    @DPTR,A
    349            LightCtl_epDesc.simpleDesc
    350                      = (SimpleDescriptionFormat_t *)&LightCtl_SimpleDesc;
   \   00002C   90....       MOV     DPTR,#(LightCtl_epDesc + 3)
   \   00002F   74..         MOV     A,#(LightCtl_SimpleDesc & 0xff)
   \   000031   F0           MOVX    @DPTR,A
   \   000032   A3           INC     DPTR
   \   000033   74..         MOV     A,#((LightCtl_SimpleDesc >> 8) & 0xff)
   \   000035   F0           MOVX    @DPTR,A
    351            LightCtl_epDesc.latencyReq = noLatencyReqs;
   \   000036   E4           CLR     A
   \   000037   90....       MOV     DPTR,#(LightCtl_epDesc + 5)
   \   00003A   F0           MOVX    @DPTR,A
    352          
    353            // Register the endpoint description with the AF
    354            afRegister( &LightCtl_epDesc );
   \   00003B                ; Setup parameters for call to function afRegister
   \   00003B   7A..         MOV     R2,#(LightCtl_epDesc & 0xff)
   \   00003D   7B..         MOV     R3,#((LightCtl_epDesc >> 8) & 0xff)
   \   00003F   12....       LCALL   ??afRegister?relay
    355          
    356            // Register for all key events - This app will handle all key events
    357            RegisterForKeys( LightCtl_TaskID );
   \   000042                ; Setup parameters for call to function RegisterForKeys
   \   000042   90....       MOV     DPTR,#LightCtl_TaskID
   \   000045   E0           MOVX    A,@DPTR
   \   000046   F9           MOV     R1,A
   \   000047   12....       LCALL   ??RegisterForKeys?relay
    358            
    359            //--------------------------------config uart------------------------------------------
    360            halUARTCfg_t uartConfig;
    361          
    362            uartConfig.configured           = TRUE;              // 2x30 don't care - see uart driver.
   \   00004A   7401         MOV     A,#0x1
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   F0           MOVX    @DPTR,A
    363            uartConfig.baudRate             = SERIAL_APP_BAUD;
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   7402         MOV     A,#0x2
   \   000058   F0           MOVX    @DPTR,A
    364            uartConfig.flowControl          = TRUE;
   \   000059   12....       LCALL   ?XSTACK_DISP0_8
   \   00005C   7401         MOV     A,#0x1
   \   00005E   F0           MOVX    @DPTR,A
    365            uartConfig.flowControlThreshold = SERIAL_APP_THRESH; // 2x30 don't care - see uart driver.
   \   00005F   7403         MOV     A,#0x3
   \   000061   12....       LCALL   ?XSTACK_DISP0_8
   \   000064   7440         MOV     A,#0x40
   \   000066   F0           MOVX    @DPTR,A
   \   000067   A3           INC     DPTR
   \   000068   E4           CLR     A
   \   000069   F0           MOVX    @DPTR,A
    366            uartConfig.rx.maxBufSize        = SERIAL_APP_RX_SZ;  // 2x30 don't care - see uart driver.
   \   00006A   740A         MOV     A,#0xa
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   7480         MOV     A,#-0x80
   \   000071   F0           MOVX    @DPTR,A
   \   000072   A3           INC     DPTR
   \   000073   E4           CLR     A
   \   000074   F0           MOVX    @DPTR,A
    367            uartConfig.tx.maxBufSize        = SERIAL_APP_TX_SZ;  // 2x30 don't care - see uart driver.
   \   000075   7412         MOV     A,#0x12
   \   000077   12....       LCALL   ?XSTACK_DISP0_8
   \   00007A   7480         MOV     A,#-0x80
   \   00007C   F0           MOVX    @DPTR,A
   \   00007D   A3           INC     DPTR
   \   00007E   E4           CLR     A
   \   00007F   F0           MOVX    @DPTR,A
    368            uartConfig.idleTimeout          = SERIAL_APP_IDLE;   // 2x30 don't care - see uart driver.
   \   000080   7405         MOV     A,#0x5
   \   000082   12....       LCALL   ?XSTACK_DISP0_8
   \   000085   7406         MOV     A,#0x6
   \   000087   F0           MOVX    @DPTR,A
    369            uartConfig.intEnable            = TRUE;              // 2x30 don't care - see uart driver.
   \   000088   7416         MOV     A,#0x16
   \   00008A   12....       LCALL   ?XSTACK_DISP0_8
   \   00008D   7401         MOV     A,#0x1
   \   00008F   F0           MOVX    @DPTR,A
    370            uartConfig.callBackFunc         = SerialApp_CallBack;
   \   000090   741B         MOV     A,#0x1b
   \   000092   12....       LCALL   ?XSTACK_DISP0_8
   \   000095   74..         MOV     A,#(??SerialApp_CallBack?relay & 0xff)
   \   000097   F0           MOVX    @DPTR,A
   \   000098   A3           INC     DPTR
   \   000099   74..         MOV     A,#((??SerialApp_CallBack?relay >> 8) & 0xff)
   \   00009B   F0           MOVX    @DPTR,A
    371            HalUARTOpen (SERIAL_APP_PORT, &uartConfig);
   \   00009C                ; Setup parameters for call to function HalUARTOpen
   \   00009C   85..82       MOV     DPL,?XSP + 0
   \   00009F   85..83       MOV     DPH,?XSP + 1
   \   0000A2   AA82         MOV     R2,DPL
   \   0000A4   AB83         MOV     R3,DPH
   \   0000A6   7900         MOV     R1,#0x0
   \   0000A8   12....       LCALL   ??HalUARTOpen?relay
    372          
    373          #if defined ( LCD_SUPPORTED )
    374            HalLcdWriteString( "SerialApp", HAL_LCD_LINE_2 );
   \   0000AB                ; Setup parameters for call to function HalLcdWriteString
   \   0000AB   7901         MOV     R1,#0x1
   \   0000AD   7A..         MOV     R2,#(`?<Constant "SerialApp">` & 0xff)
   \   0000AF   7B..         MOV     R3,#((`?<Constant "SerialApp">` >> 8) & 0xff)
   \   0000B1   12....       LCALL   ??HalLcdWriteString?relay
    375          #endif
    376          
    377            // Update the display
    378          #if defined ( LCD_SUPPORTED )
    379              HalLcdWriteString( "LightCtl", HAL_LCD_LINE_1 );
   \   0000B4                ; Setup parameters for call to function HalLcdWriteString
   \   0000B4   7900         MOV     R1,#0x0
   \   0000B6   7A..         MOV     R2,#(`?<Constant "LightCtl">` & 0xff)
   \   0000B8   7B..         MOV     R3,#((`?<Constant "LightCtl">` >> 8) & 0xff)
   \   0000BA   12....       LCALL   ??HalLcdWriteString?relay
    380          #endif
    381              
    382            //ZDO_RegisterForZDOMsg( LightCtl_TaskID, End_Device_Bind_rsp );
    383            //ZDO_RegisterForZDOMsg( LightCtl_TaskID, Match_Desc_rsp );
    384          }
   \   0000BD   741D         MOV     A,#0x1d
   \   0000BF   12....       LCALL   ?DEALLOC_XSTACK8
   \   0000C2   D083         POP     DPH
   \   0000C4   D082         POP     DPL
   \   0000C6   02....       LJMP    ?BRET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   7402         MOV     A,#0x2
   \   000002   90....       MOV     DPTR,#(LightCtl_DstAddr + 8)
   \   000005   F0           MOVX    @DPTR,A
   \   000006   740A         MOV     A,#0xa
   \   000008   90....       MOV     DPTR,#(LightCtl_DstAddr + 9)
   \   00000B   F0           MOVX    @DPTR,A
   \   00000C   90....       MOV     DPTR,#LightCtl_DstAddr
   \   00000F   E4           CLR     A
   \   000010   F0           MOVX    @DPTR,A
   \   000011   A3           INC     DPTR
   \   000012   F0           MOVX    @DPTR,A
   \   000013   22           RET
    385          
    386          /*********************************************************************
    387           * @fn      LightCtl_ProcessEvent
    388           *
    389           * @brief   Generic Application Task event processor.  This function
    390           *          is called to process all events for the task.  Events
    391           *          include timers, messages and any other user defined events.
    392           *
    393           * @param   task_id  - The OSAL assigned task ID.
    394           * @param   events - events to process.  This is a bit map and can
    395           *                   contain more than one event.
    396           *
    397           * @return  none
    398           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    399          UINT16 LightCtl_ProcessEvent( byte task_id, UINT16 events )
   \                     LightCtl_ProcessEvent:
    400          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 11
   \   000005   74F5         MOV     A,#-0xb
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   EA           MOV     A,R2
   \   00000B   FE           MOV     R6,A
   \   00000C   EB           MOV     A,R3
   \   00000D   FF           MOV     R7,A
    401            afIncomingMSGPacket_t *MSGpkt;
    402            afDataConfirm_t *afDataConfirm;
    403          
    404            // Data Confirmation message fields
    405            byte sentEP;
    406            ZStatus_t sentStatus;
    407            byte sentTransID;       // This should match the value sent
    408            (void)task_id;  // Intentionally unreferenced parameter
    409          
    410            if ( events & SYS_EVENT_MSG )
   \   00000E   7480         MOV     A,#-0x80
   \   000010   5F           ANL     A,R7
   \   000011   F9           MOV     R1,A
   \   000012   E4           CLR     A
   \   000013   7001         JNZ     ??LightCtl_ProcessEvent_0
   \   000015   E9           MOV     A,R1
   \                     ??LightCtl_ProcessEvent_0:
   \   000016   7003         JNZ     $+5
   \   000018   02....       LJMP    ??LightCtl_ProcessEvent_1 & 0xFFFF
    411            {
    412              MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( LightCtl_TaskID );
   \   00001B                ; Setup parameters for call to function osal_msg_receive
   \   00001B   02....       LJMP    ??LightCtl_ProcessEvent_2 & 0xFFFF
    413              while ( MSGpkt )
    414              {
    415                switch ( MSGpkt->hdr.event )
    416                {
    417                  case ZDO_CB_MSG:
    418                    //LightCtl_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );
    419                    break;
    420                    
    421                  case KEY_CHANGE:
    422                    LightCtl_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
    423                    break;
    424          
    425                  case AF_DATA_CONFIRM_CMD:
    426                    // This message is received as a confirmation of a data packet sent.
    427                    // The status is of ZStatus_t type [defined in ZComDef.h]
    428                    // The message fields are defined in AF.h
    429                    afDataConfirm = (afDataConfirm_t *)MSGpkt;
    430                    sentEP = afDataConfirm->endpoint;
    431                    sentStatus = afDataConfirm->hdr.status;
    432                    sentTransID = afDataConfirm->transID;
    433                    (void)sentEP;
    434                    (void)sentTransID;
    435          
    436                    // Action taken when confirmation is received.
    437                    if ( sentStatus != ZSuccess )
    438                    {
    439                      // The data wasn't delivered -- Do something
    440                    }
    441                    break;
    442          
    443                  case AF_INCOMING_MSG_CMD:
    444                    LightCtl_MessageMSGCB( MSGpkt );
    445                    break;
    446          
    447                  case ZDO_STATE_CHANGE:
    448                    LightCtl_NwkState = (devStates_t)(MSGpkt->hdr.status);
   \                     ??LightCtl_ProcessEvent_3:
   \   00001E   85..82       MOV     DPL,?V0 + 0
   \   000021   85..83       MOV     DPH,?V0 + 1
   \   000024   A3           INC     DPTR
   \   000025   E0           MOVX    A,@DPTR
   \   000026   90....       MOV     DPTR,#LightCtl_NwkState
   \   000029   F0           MOVX    @DPTR,A
    449                    if ( (LightCtl_NwkState == DEV_ZB_COORD)
    450                        || (LightCtl_NwkState == DEV_ROUTER)
    451                        || (LightCtl_NwkState == DEV_END_DEVICE) )
   \   00002A   6409         XRL     A,#0x9
   \   00002C   600D         JZ      ??LightCtl_ProcessEvent_4
   \   00002E   E0           MOVX    A,@DPTR
   \   00002F   6407         XRL     A,#0x7
   \   000031   6008         JZ      ??LightCtl_ProcessEvent_4
   \   000033   E0           MOVX    A,@DPTR
   \   000034   6406         XRL     A,#0x6
   \   000036   6003         JZ      $+5
   \   000038   02....       LJMP    ??LightCtl_ProcessEvent_5 & 0xFFFF
    452                    {
    453                      #if defined(ZDO_COORDINATOR)
    454                      
    455                       UartShowNtkInfo(NLME_GetShortAddr(),aExtendedAddress + Z_EXTADDR_LEN - 1); 
    456                      
    457                      #else 
    458                      
    459                      LightCtl_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \                     ??LightCtl_ProcessEvent_4:
   \   00003B   12....       LCALL   ?Subroutine2 & 0xFFFF
    460                      LightCtl_DstAddr.endPoint = LightCtl_ENDPOINT;
    461                      LightCtl_DstAddr.addr.shortAddr = 0x0000;  //0x796F;0x0000
    462                      
    463                      uint16 short_ddr;
    464                      uint8 short_ddr_H;
    465                      uint8 short_ddr_L;
    466                    //  uint8 *pointer1;
    467                      uint8 tmpBuf[11];
    468                      
    469                      uint8 *xad;    
    470                    
    471                      short_ddr=NLME_GetShortAddr();
   \                     ??CrossCallReturnLabel_9:
   \   00003E                ; Setup parameters for call to function NLME_GetShortAddr
   \   00003E   12....       LCALL   ??NLME_GetShortAddr?relay
    472                      short_ddr_H=(uint8)((short_ddr&0xff00)>>8);
    473                      short_ddr_L=(uint8)short_ddr;
    474          
    475                      tmpBuf[0]=10;                           //一字节存放数据长度
   \   000041   740A         MOV     A,#0xa
   \   000043   85..82       MOV     DPL,?XSP + 0
   \   000046   85..83       MOV     DPH,?XSP + 1
   \   000049   F0           MOVX    @DPTR,A
    476                      tmpBuf[1]=short_ddr_H;              //一字节存放源地址高8位
   \   00004A   7401         MOV     A,#0x1
   \   00004C   12....       LCALL   ?XSTACK_DISP0_8
   \   00004F   EB           MOV     A,R3
   \   000050   F0           MOVX    @DPTR,A
    477                      tmpBuf[2]=short_ddr_L;              //一字节存放源地址低8位
   \   000051   7402         MOV     A,#0x2
   \   000053   12....       LCALL   ?XSTACK_DISP0_8
   \   000056   EA           MOV     A,R2
   \   000057   F0           MOVX    @DPTR,A
    478          
    479                      xad = NLME_GetExtAddr();
   \   000058                ; Setup parameters for call to function NLME_GetExtAddr
   \   000058   12....       LCALL   ??NLME_GetExtAddr?relay
   \   00005B   8A..         MOV     ?V0 + 2,R2
   \   00005D   8B..         MOV     ?V0 + 3,R3
   \   00005F   A8..         MOV     R0,?V0 + 2
   \   000061   A9..         MOV     R1,?V0 + 3
    480                      tmpBuf[3]=*xad++;
   \   000063   8882         MOV     DPL,R0
   \   000065   8983         MOV     DPH,R1
   \   000067   E0           MOVX    A,@DPTR
   \   000068   C0E0         PUSH    A
   \   00006A   7403         MOV     A,#0x3
   \   00006C   12....       LCALL   ?XSTACK_DISP0_8
   \   00006F   D0E0         POP     A
   \   000071   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_18:
   \   000074   A882         MOV     R0,DPL
   \   000076   A983         MOV     R1,DPH
    481                      tmpBuf[4]=*xad++;
   \   000078   E0           MOVX    A,@DPTR
   \   000079   C0E0         PUSH    A
   \   00007B   7404         MOV     A,#0x4
   \   00007D   12....       LCALL   ?XSTACK_DISP0_8
   \   000080   D0E0         POP     A
   \   000082   12....       LCALL   ?Subroutine1 & 0xFFFF
    482                      tmpBuf[5]=*xad++;
   \                     ??CrossCallReturnLabel_3:
   \   000085   C0E0         PUSH    A
   \   000087   7405         MOV     A,#0x5
   \   000089   12....       LCALL   ?XSTACK_DISP0_8
   \   00008C   D0E0         POP     A
   \   00008E   12....       LCALL   ?Subroutine1 & 0xFFFF
    483                      tmpBuf[6]=*xad++;
   \                     ??CrossCallReturnLabel_4:
   \   000091   C0E0         PUSH    A
   \   000093   7406         MOV     A,#0x6
   \   000095   12....       LCALL   ?XSTACK_DISP0_8
   \   000098   D0E0         POP     A
   \   00009A   12....       LCALL   ?Subroutine1 & 0xFFFF
    484                      tmpBuf[7]=*xad++;
   \                     ??CrossCallReturnLabel_5:
   \   00009D   C0E0         PUSH    A
   \   00009F   7407         MOV     A,#0x7
   \   0000A1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000A4   D0E0         POP     A
   \   0000A6   12....       LCALL   ?Subroutine1 & 0xFFFF
    485                      tmpBuf[8]=*xad++;
   \                     ??CrossCallReturnLabel_6:
   \   0000A9   C0E0         PUSH    A
   \   0000AB   7408         MOV     A,#0x8
   \   0000AD   12....       LCALL   ?XSTACK_DISP0_8
   \   0000B0   D0E0         POP     A
   \   0000B2   12....       LCALL   ?Subroutine1 & 0xFFFF
    486                      tmpBuf[9]=*xad++;
   \                     ??CrossCallReturnLabel_7:
   \   0000B5   C0E0         PUSH    A
   \   0000B7   7409         MOV     A,#0x9
   \   0000B9   12....       LCALL   ?XSTACK_DISP0_8
   \   0000BC   D0E0         POP     A
   \   0000BE   12....       LCALL   ?Subroutine7 & 0xFFFF
    487                      tmpBuf[10]=*xad;
   \                     ??CrossCallReturnLabel_19:
   \   0000C1   E0           MOVX    A,@DPTR
   \   0000C2   C0E0         PUSH    A
   \   0000C4   740A         MOV     A,#0xa
   \   0000C6   12....       LCALL   ?XSTACK_DISP0_8
   \   0000C9   D0E0         POP     A
   \   0000CB   F0           MOVX    @DPTR,A
    488                      
    489                      if ( AF_DataRequest( &LightCtl_DstAddr,
    490                                             (endPointDesc_t *)&LightCtl_epDesc,
    491                                              LightCtl_CLUSTERID,
    492                                              11, tmpBuf,
    493                                              &LightCtl_TransID, 
    494                                              AF_DISCV_ROUTE, 
    495                                              AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   \   0000CC                ; Setup parameters for call to function AF_DataRequest
   \   0000CC   75..1E       MOV     ?V0 + 2,#0x1e
   \   0000CF   78..         MOV     R0,#?V0 + 2
   \   0000D1   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   0000D4   75....       MOV     ?V0 + 2,#(LightCtl_TransID & 0xff)
   \   0000D7   75....       MOV     ?V0 + 3,#((LightCtl_TransID >> 8) & 0xff)
   \   0000DA   78..         MOV     R0,#?V0 + 2
   \   0000DC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000DF   7403         MOV     A,#0x3
   \   0000E1   12....       LCALL   ?XSTACK_DISP0_8
   \   0000E4   8582..       MOV     ?V0 + 2,DPL
   \   0000E7   8583..       MOV     ?V0 + 3,DPH
   \   0000EA   78..         MOV     R0,#?V0 + 2
   \   0000EC   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000EF   75..0B       MOV     ?V0 + 2,#0xb
   \   0000F2   75..00       MOV     ?V0 + 3,#0x0
   \   0000F5   78..         MOV     R0,#?V0 + 2
   \   0000F7   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   0000FA   75..01       MOV     ?V0 + 2,#0x1
   \   0000FD   78..         MOV     R0,#?V0 + 2
   \   0000FF   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000102   7920         MOV     R1,#0x20
   \   000104   7C..         MOV     R4,#(LightCtl_epDesc & 0xff)
   \   000106   7D..         MOV     R5,#((LightCtl_epDesc >> 8) & 0xff)
   \   000108   7A..         MOV     R2,#(LightCtl_DstAddr & 0xff)
   \   00010A   7B..         MOV     R3,#((LightCtl_DstAddr >> 8) & 0xff)
   \   00010C   12....       LCALL   ??AF_DataRequest?relay
   \   00010F   7409         MOV     A,#0x9
   \   000111   12....       LCALL   ?DEALLOC_XSTACK8
    496                      {
    497                        ;
    498                      }
    499                      else
    500                      {
    501                        ;
    502                      }
    503                      #endif
    504                      
    505                    }
    506                    break;
    507          
    508                  default:
    509                    break;
    510                }
    511          
    512                // Release the memory
    513                osal_msg_deallocate( (uint8 *)MSGpkt );
   \                     ??LightCtl_ProcessEvent_5:
   \   000114                ; Setup parameters for call to function osal_msg_deallocate
   \   000114   AA..         MOV     R2,?V0 + 0
   \   000116   AB..         MOV     R3,?V0 + 1
   \   000118   12....       LCALL   ??osal_msg_deallocate?relay
    514          
    515                // Next
    516                MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( LightCtl_TaskID );
   \   00011B                ; Setup parameters for call to function osal_msg_receive
   \                     ??LightCtl_ProcessEvent_2:
   \   00011B   90....       MOV     DPTR,#LightCtl_TaskID
   \   00011E   E0           MOVX    A,@DPTR
   \   00011F   F9           MOV     R1,A
   \   000120   12....       LCALL   ??osal_msg_receive?relay
   \   000123   8A..         MOV     ?V0 + 0,R2
   \   000125   8B..         MOV     ?V0 + 1,R3
   \   000127   E5..         MOV     A,?V0 + 0
   \   000129   7002         JNZ     ??LightCtl_ProcessEvent_6
   \   00012B   E5..         MOV     A,?V0 + 1
   \                     ??LightCtl_ProcessEvent_6:
   \   00012D   603A         JZ      ??LightCtl_ProcessEvent_7
   \   00012F   85..82       MOV     DPL,?V0 + 0
   \   000132   85..83       MOV     DPH,?V0 + 1
   \   000135   E0           MOVX    A,@DPTR
   \   000136   12....       LCALL   ?UC_SWITCH_SPARSE
   \                     `?<Jumptable for LightCtl_ProcessEvent>_0`:
   \   000139   00           DB        0
   \   00013A   03           DB        3
   \   00013B   1A           DB        26
   \   00013C   ....         DW        ??LightCtl_ProcessEvent_8
   \   00013E   C0           DB        192
   \   00013F   ....         DW        ??LightCtl_ProcessEvent_9
   \   000141   D1           DB        209
   \   000142   ....         DW        ??LightCtl_ProcessEvent_3
   \   000144   ....         DW        ??LightCtl_ProcessEvent_5
   \                     ??LightCtl_ProcessEvent_9:
   \   000146                ; Setup parameters for call to function LightCtl_HandleKeys
   \   000146   85..82       MOV     DPL,?V0 + 0
   \   000149   85..83       MOV     DPH,?V0 + 1
   \   00014C   A3           INC     DPTR
   \   00014D   A3           INC     DPTR
   \   00014E   A3           INC     DPTR
   \   00014F   E0           MOVX    A,@DPTR
   \   000150   FA           MOV     R2,A
   \   000151   85..82       MOV     DPL,?V0 + 0
   \   000154   85..83       MOV     DPH,?V0 + 1
   \   000157   A3           INC     DPTR
   \   000158   A3           INC     DPTR
   \   000159   E0           MOVX    A,@DPTR
   \   00015A   F9           MOV     R1,A
   \   00015B   12....       LCALL   ??LightCtl_HandleKeys?relay
   \   00015E   80B4         SJMP    ??LightCtl_ProcessEvent_5
   \                     ??LightCtl_ProcessEvent_8:
   \   000160                ; Setup parameters for call to function LightCtl_MessageMSGCB
   \   000160   AA..         MOV     R2,?V0 + 0
   \   000162   AB..         MOV     R3,?V0 + 1
   \   000164   12....       LCALL   ??LightCtl_MessageMSGCB?relay
   \   000167   80AB         SJMP    ??LightCtl_ProcessEvent_5
    517              }
    518          
    519              // return unprocessed events
    520              return (events ^ SYS_EVENT_MSG);
   \                     ??LightCtl_ProcessEvent_7:
   \   000169   EE           MOV     A,R6
   \   00016A   FA           MOV     R2,A
   \   00016B   7480         MOV     A,#-0x80
   \   00016D   6F           XRL     A,R7
   \                     ??LightCtl_ProcessEvent_10:
   \   00016E   FB           MOV     R3,A
   \   00016F   802D         SJMP    ??LightCtl_ProcessEvent_11
    521            }
    522          
    523            // Send a message out - This event is generated by a timer
    524            //  (setup in LightCtl_Init()).
    525            if ( events & LightCtl_SEND_MSG_EVT )
   \                     ??LightCtl_ProcessEvent_1:
   \   000171   EE           MOV     A,R6
   \   000172   A2E0         MOV     C,0xE0 /* A   */.0
   \   000174   501A         JNC     ??LightCtl_ProcessEvent_12
    526            {
    527              // Send "the" message
    528              LightCtl_SendTheMessage();
   \   000176                ; Setup parameters for call to function LightCtl_SendTheMessage
   \   000176   12....       LCALL   ??LightCtl_SendTheMessage?relay
    529          
    530              // Setup to send message again
    531              osal_start_timerEx( LightCtl_TaskID,
    532                                  LightCtl_SEND_MSG_EVT,
    533                                LightCtl_SEND_MSG_TIMEOUT );
   \   000179                ; Setup parameters for call to function osal_start_timerEx
   \   000179   7C88         MOV     R4,#-0x78
   \   00017B   7D13         MOV     R5,#0x13
   \   00017D   7A01         MOV     R2,#0x1
   \   00017F   7B00         MOV     R3,#0x0
   \   000181   90....       MOV     DPTR,#LightCtl_TaskID
   \   000184   E0           MOVX    A,@DPTR
   \   000185   F9           MOV     R1,A
   \   000186   12....       LCALL   ??osal_start_timerEx?relay
    534          
    535              // return unprocessed events
    536              return (events ^ LightCtl_SEND_MSG_EVT);
   \   000189   7401         MOV     A,#0x1
   \   00018B   6E           XRL     A,R6
   \   00018C   FA           MOV     R2,A
   \   00018D   EF           MOV     A,R7
   \   00018E   80DE         SJMP    ??LightCtl_ProcessEvent_10
    537            }
    538            
    539            //对接收的串口数据进行处理
    540            if ( events & UART_RX_CB_EVT )  //串口数据处理
   \                     ??LightCtl_ProcessEvent_12:
   \   000190   5402         ANL     A,#0x2
   \   000192   6006         JZ      ??LightCtl_ProcessEvent_13
    541            { 
    542          
    543              //SampleApp_SPI_SendData( databuf, rxlen+1+2 );  
    544              return (events ^ UART_RX_CB_EVT);
   \   000194   7402         MOV     A,#0x2
   \   000196   6E           XRL     A,R6
   \   000197   FA           MOV     R2,A
   \   000198   8004         SJMP    ??LightCtl_ProcessEvent_11
    545            }
    546          
    547            // Discard unknown events
    548            return 0;
   \                     ??LightCtl_ProcessEvent_13:
   \   00019A   7A00         MOV     R2,#0x0
   \   00019C   7B00         MOV     R3,#0x0
   \                     ??LightCtl_ProcessEvent_11:
   \   00019E   740B         MOV     A,#0xb
   \   0001A0   12....       LCALL   ?DEALLOC_XSTACK8
   \   0001A3   7F04         MOV     R7,#0x4
   \   0001A5   02....       LJMP    ?BANKED_LEAVE_XDATA
    549          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine7 & 0xFFFF
   \                     ??CrossCallReturnLabel_20:
   \   000003   08           INC     R0
   \   000004   A983         MOV     R1,DPH
   \   000006   E0           MOVX    A,@DPTR
   \   000007   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   8882         MOV     DPL,R0
   \   000003   8983         MOV     DPH,R1
   \   000005   A3           INC     DPTR
   \   000006   22           RET
    550          
    551          /*********************************************************************
    552           * Event Generation Functions
    553           */
    554          
    555          /*********************************************************************
    556           * @fn      LightCtl_ProcessZDOMsgs()
    557           *
    558           * @brief   Process response messages
    559           *
    560           * @param   none
    561           *
    562           * @return  none
    563           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    564          void LightCtl_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
   \                     LightCtl_ProcessZDOMsgs:
    565          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    566            switch ( inMsg->clusterID )
   \   000005   EA           MOV     A,R2
   \   000006   240C         ADD     A,#0xc
   \   000008   F582         MOV     DPL,A
   \   00000A   EB           MOV     A,R3
   \   00000B   3400         ADDC    A,#0x0
   \   00000D   F583         MOV     DPH,A
   \   00000F   E0           MOVX    A,@DPTR
   \   000010   F5..         MOV     ?V0 + 0,A
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \   000014   F5..         MOV     ?V0 + 1,A
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   12....       LCALL   ?US_SWITCH_SPARSE
   \                     `?<Jumptable for LightCtl_ProcessZDOMsgs>_0`:
   \   00001B   0000         DW        0
   \   00001D   0200         DW        2
   \   00001F   0680         DW        32774
   \   000021   ....         DW        ??LightCtl_ProcessZDOMsgs_0
   \   000023   2080         DW        32800
   \   000025   ....         DW        ??LightCtl_ProcessZDOMsgs_1
   \   000027   ....         DW        ??LightCtl_ProcessZDOMsgs_2
    567            {
    568              case End_Device_Bind_rsp:
    569                if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
   \                     ??LightCtl_ProcessZDOMsgs_1:
   \   000029   EA           MOV     A,R2
   \   00002A   2413         ADD     A,#0x13
   \   00002C   F582         MOV     DPL,A
   \   00002E   EB           MOV     A,R3
   \   00002F   3400         ADDC    A,#0x0
   \   000031   F583         MOV     DPH,A
   \   000033   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_16:
   \   000036   E0           MOVX    A,@DPTR
   \   000037   7009         JNZ     ??LightCtl_ProcessZDOMsgs_3
    570                {
    571                  // Light LED
    572                  HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   000039                ; Setup parameters for call to function HalLedSet
   \   000039   7A01         MOV     R2,#0x1
   \                     ??LightCtl_ProcessZDOMsgs_4:
   \   00003B   7908         MOV     R1,#0x8
   \   00003D   12....       LCALL   ??HalLedSet?relay
   \   000040   8055         SJMP    ??LightCtl_ProcessZDOMsgs_2
    573                }
    574          #if defined(BLINK_LEDS)
    575                else
    576                {
    577                  // Flash LED to show failure
    578                  HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
   \                     ??LightCtl_ProcessZDOMsgs_3:
   \   000042                ; Setup parameters for call to function HalLedSet
   \   000042   7A04         MOV     R2,#0x4
   \   000044   80F5         SJMP    ??LightCtl_ProcessZDOMsgs_4
    579                }
    580          #endif
    581                break;
    582          
    583              case Match_Desc_rsp:
    584                {
    585                  ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
   \                     ??LightCtl_ProcessZDOMsgs_0:
   \   000046                ; Setup parameters for call to function ZDO_ParseEPListRsp
   \   000046   12....       LCALL   ??ZDO_ParseEPListRsp?relay
   \   000049   8A..         MOV     ?V0 + 0,R2
   \   00004B   8B..         MOV     ?V0 + 1,R3
   \   00004D   AE..         MOV     R6,?V0 + 0
   \   00004F   AF..         MOV     R7,?V0 + 1
    586                  if ( pRsp )
   \   000051   EE           MOV     A,R6
   \   000052   7001         JNZ     ??LightCtl_ProcessZDOMsgs_5
   \   000054   EF           MOV     A,R7
   \                     ??LightCtl_ProcessZDOMsgs_5:
   \   000055   6040         JZ      ??LightCtl_ProcessZDOMsgs_2
    587                  {
    588                    if ( pRsp->status == ZSuccess && pRsp->cnt )
   \   000057   8E82         MOV     DPL,R6
   \   000059   8F83         MOV     DPH,R7
   \   00005B   E0           MOVX    A,@DPTR
   \   00005C   7032         JNZ     ??LightCtl_ProcessZDOMsgs_6
   \   00005E   A3           INC     DPTR
   \   00005F   A3           INC     DPTR
   \   000060   A3           INC     DPTR
   \   000061   E0           MOVX    A,@DPTR
   \   000062   602C         JZ      ??LightCtl_ProcessZDOMsgs_6
    589                    {
    590                      LightCtl_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
   \   000064   7402         MOV     A,#0x2
   \   000066   90....       MOV     DPTR,#(LightCtl_DstAddr + 8)
   \   000069   F0           MOVX    @DPTR,A
    591                      LightCtl_DstAddr.addr.shortAddr = pRsp->nwkAddr;
   \   00006A   8E82         MOV     DPL,R6
   \   00006C   8F83         MOV     DPH,R7
   \   00006E   A3           INC     DPTR
   \   00006F   E0           MOVX    A,@DPTR
   \   000070   F8           MOV     R0,A
   \   000071   A3           INC     DPTR
   \   000072   E0           MOVX    A,@DPTR
   \   000073   F9           MOV     R1,A
   \   000074   90....       MOV     DPTR,#LightCtl_DstAddr
   \   000077   E8           MOV     A,R0
   \   000078   F0           MOVX    @DPTR,A
   \   000079   A3           INC     DPTR
   \   00007A   E9           MOV     A,R1
   \   00007B   F0           MOVX    @DPTR,A
    592                      // Take the first endpoint, Can be changed to search through endpoints
    593                      LightCtl_DstAddr.endPoint = pRsp->epList[0];
   \   00007C   8E82         MOV     DPL,R6
   \   00007E   8F83         MOV     DPH,R7
   \   000080   A3           INC     DPTR
   \   000081   A3           INC     DPTR
   \   000082   A3           INC     DPTR
   \   000083   A3           INC     DPTR
   \   000084   E0           MOVX    A,@DPTR
   \   000085   90....       MOV     DPTR,#(LightCtl_DstAddr + 9)
   \   000088   F0           MOVX    @DPTR,A
    594          
    595                      // Light LED
    596                      HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
   \   000089                ; Setup parameters for call to function HalLedSet
   \   000089   7A01         MOV     R2,#0x1
   \   00008B   7908         MOV     R1,#0x8
   \   00008D   12....       LCALL   ??HalLedSet?relay
    597                    }
    598                    osal_mem_free( pRsp );
   \                     ??LightCtl_ProcessZDOMsgs_6:
   \   000090                ; Setup parameters for call to function osal_mem_free
   \   000090   EE           MOV     A,R6
   \   000091   FA           MOV     R2,A
   \   000092   EF           MOV     A,R7
   \   000093   FB           MOV     R3,A
   \   000094   12....       LCALL   ??osal_mem_free?relay
    599                  }
    600                }
    601                break;
    602            }
    603          }
   \                     ??LightCtl_ProcessZDOMsgs_2:
   \   000097   80..         SJMP    ??Subroutine11_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_22:
   \   000003   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   E0           MOVX    A,@DPTR
   \   000001   F8           MOV     R0,A
   \   000002   A3           INC     DPTR
   \   000003   E0           MOVX    A,@DPTR
   \   000004   F583         MOV     DPH,A
   \   000006   8882         MOV     DPL,R0
   \   000008   22           RET
    604          
    605          /*********************************************************************
    606           * @fn      LightCtl_HandleKeys
    607           *
    608           * @brief   Handles all key events for this device.
    609           *
    610           * @param   shift - true if in shift/alt.
    611           * @param   keys - bit field for key events. Valid entries:
    612           *                 HAL_KEY_SW_4
    613           *                 HAL_KEY_SW_3
    614           *                 HAL_KEY_SW_2
    615           *                 HAL_KEY_SW_1
    616           *
    617           * @return  none
    618           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    619          void LightCtl_HandleKeys( byte shift, byte keys )
   \                     LightCtl_HandleKeys:
    620          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
   \   000005   EA           MOV     A,R2
   \   000006   FE           MOV     R6,A
    621            //zAddrType_t dstAddr;
    622            
    623            // Shift is used to make each button/switch dual purpose.
    624            if ( shift )
   \   000007   E9           MOV     A,R1
   \   000008   6003         JZ      $+5
   \   00000A   02....       LJMP    ??LightCtl_HandleKeys_0 & 0xFFFF
    625            {
    626              if ( keys & HAL_KEY_SW_1 )
    627              {
    628              }
    629              if ( keys & HAL_KEY_SW_2 )
    630              {
    631              }
    632              if ( keys & HAL_KEY_SW_3 )
    633              {
    634              }
    635              if ( keys & HAL_KEY_SW_4 )
    636              {
    637              }
    638            }
    639            else
    640            {
    641              if ( keys & HAL_KEY_SW_1 )
   \   00000D   EE           MOV     A,R6
   \   00000E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000010   5070         JNC     ??LightCtl_HandleKeys_1
    642              {
    643                HalLedBlink ( HAL_LED_1, 10, 50, 500 );
   \   000012                ; Setup parameters for call to function HalLedBlink
   \   000012   7CF4         MOV     R4,#-0xc
   \   000014   7D01         MOV     R5,#0x1
   \   000016   7B32         MOV     R3,#0x32
   \   000018   7A0A         MOV     R2,#0xa
   \   00001A   7901         MOV     R1,#0x1
   \   00001C   12....       LCALL   ??HalLedBlink?relay
    644                
    645                static byte cnt=0;
    646                
    647          
    648                if ( AF_DataRequest( &LightCtl_DstAddr, &LightCtl_epDesc,
    649                                     LightCtl_CLUSTERID,
    650                                     1,
    651                                     (byte *)&cnt,
    652                                     &LightCtl_TransID,
    653                                     AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   \   00001F                ; Setup parameters for call to function AF_DataRequest
   \   00001F   75..1E       MOV     ?V0 + 0,#0x1e
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000027   75....       MOV     ?V0 + 0,#(LightCtl_TransID & 0xff)
   \   00002A   75....       MOV     ?V0 + 1,#((LightCtl_TransID >> 8) & 0xff)
   \   00002D   78..         MOV     R0,#?V0 + 0
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   75....       MOV     ?V0 + 0,#(??cnt & 0xff)
   \   000035   75....       MOV     ?V0 + 1,#((??cnt >> 8) & 0xff)
   \   000038   78..         MOV     R0,#?V0 + 0
   \   00003A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00003D   75..01       MOV     ?V0 + 0,#0x1
   \   000040   75..00       MOV     ?V0 + 1,#0x0
   \   000043   78..         MOV     R0,#?V0 + 0
   \   000045   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000048   78..         MOV     R0,#?V0 + 0
   \   00004A   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00004D   7920         MOV     R1,#0x20
   \   00004F   7C..         MOV     R4,#(LightCtl_epDesc & 0xff)
   \   000051   7D..         MOV     R5,#((LightCtl_epDesc >> 8) & 0xff)
   \   000053   7A..         MOV     R2,#(LightCtl_DstAddr & 0xff)
   \   000055   7B..         MOV     R3,#((LightCtl_DstAddr >> 8) & 0xff)
   \   000057   12....       LCALL   ??AF_DataRequest?relay
   \   00005A   7409         MOV     A,#0x9
   \   00005C   12....       LCALL   ?DEALLOC_XSTACK8
   \   00005F   E9           MOV     A,R1
   \   000060   7020         JNZ     ??LightCtl_HandleKeys_1
    654                {
    655                  // Successfully requested to be sent.
    656                  HalLcdWriteValue( cnt, 16, HAL_LCD_LINE_2 );
   \   000062                ; Setup parameters for call to function HalLcdWriteValue
   \   000062   78..         MOV     R0,#?V0 + 0
   \   000064   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000067   7910         MOV     R1,#0x10
   \   000069   90....       MOV     DPTR,#??cnt
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   FA           MOV     R2,A
   \   00006E   7B00         MOV     R3,#0x0
   \   000070   7C00         MOV     R4,#0x0
   \   000072   7D00         MOV     R5,#0x0
   \   000074   12....       LCALL   ??HalLcdWriteValue?relay
   \   000077   7401         MOV     A,#0x1
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
    657                  
    658                  cnt++;
   \   00007C   90....       MOV     DPTR,#??cnt
   \   00007F   E0           MOVX    A,@DPTR
   \   000080   04           INC     A
   \   000081   F0           MOVX    @DPTR,A
    659                }
    660                
    661              }
    662          
    663              if ( keys & HAL_KEY_SW_2 )
   \                     ??LightCtl_HandleKeys_1:
   \   000082   EE           MOV     A,R6
   \   000083   A2E1         MOV     C,0xE0 /* A   */.1
   \   000085   500D         JNC     ??LightCtl_HandleKeys_2
    664              {
    665                HalLedBlink ( HAL_LED_2, 10, 50, 500 );
   \   000087                ; Setup parameters for call to function HalLedBlink
   \   000087   7CF4         MOV     R4,#-0xc
   \   000089   7D01         MOV     R5,#0x1
   \   00008B   7B32         MOV     R3,#0x32
   \   00008D   7A0A         MOV     R2,#0xa
   \   00008F   7902         MOV     R1,#0x2
   \   000091   12....       LCALL   ??HalLedBlink?relay
    666          
    667                // Initiate an End Device Bind Request for the mandatory endpoint
    668                /*dstAddr.addrMode = Addr16Bit;
    669                dstAddr.addr.shortAddr = 0x0000; // Coordinator
    670                ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(), 
    671                                      LightCtl_epDesc.endPoint,
    672                                      LightCtl_PROFID,
    673                                      LightCtl_MAX_CLUSTERS, (cId_t *)LightCtl_ClusterList,
    674                                      LightCtl_MAX_CLUSTERS, (cId_t *)LightCtl_ClusterList,
    675                                      FALSE );*/
    676              }
    677          
    678              if ( keys & HAL_KEY_SW_3 )
   \                     ??LightCtl_HandleKeys_2:
   \   000094   EE           MOV     A,R6
   \   000095   A2E4         MOV     C,0xE0 /* A   */.4
   \   000097   5023         JNC     ??LightCtl_HandleKeys_3
    679              {
    680                HalLedBlink ( HAL_LED_3, 10, 50, 500 );
   \   000099                ; Setup parameters for call to function HalLedBlink
   \   000099   7CF4         MOV     R4,#-0xc
   \   00009B   7D01         MOV     R5,#0x1
   \   00009D   7B32         MOV     R3,#0x32
   \   00009F   7A0A         MOV     R2,#0xa
   \   0000A1   7904         MOV     R1,#0x4
   \   0000A3   12....       LCALL   ??HalLedBlink?relay
    681                
    682                HalUARTWrite(SERIAL_APP_PORT, "123", 3);
   \   0000A6                ; Setup parameters for call to function HalUARTWrite
   \   0000A6   7C03         MOV     R4,#0x3
   \   0000A8   7D00         MOV     R5,#0x0
   \   0000AA   7A..         MOV     R2,#(`?<Constant "123">` & 0xff)
   \   0000AC   7B..         MOV     R3,#((`?<Constant "123">` >> 8) & 0xff)
   \   0000AE   7900         MOV     R1,#0x0
   \   0000B0   12....       LCALL   ??HalUARTWrite?relay
    683                HalLcdWriteString("Joystick HAL_KEY_SW_3", HAL_LCD_LINE_2 );
   \   0000B3                ; Setup parameters for call to function HalLcdWriteString
   \   0000B3   7901         MOV     R1,#0x1
   \   0000B5   7A..         MOV     R2,#(`?<Constant "Joystick HAL_KEY_SW_3">` & 0xff)
   \   0000B7   7B..         MOV     R3,#((`?<Constant "Joystick HAL_KEY_SW_3">` >> 8) & 0xff)
   \   0000B9   12....       LCALL   ??HalLcdWriteString?relay
    684              }
    685          
    686              if ( keys & HAL_KEY_SW_4 )
   \                     ??LightCtl_HandleKeys_3:
   \   0000BC   EE           MOV     A,R6
   \   0000BD   A2E3         MOV     C,0xE0 /* A   */.3
   \   0000BF   500D         JNC     ??LightCtl_HandleKeys_0
    687              {
    688                HalLedBlink ( HAL_LED_4, 10, 50, 500 );
   \   0000C1                ; Setup parameters for call to function HalLedBlink
   \   0000C1   7CF4         MOV     R4,#-0xc
   \   0000C3   7D01         MOV     R5,#0x1
   \   0000C5   7B32         MOV     R3,#0x32
   \   0000C7   7A0A         MOV     R2,#0xa
   \   0000C9   7908         MOV     R1,#0x8
   \   0000CB   12....       LCALL   ??HalLedBlink?relay
    689                
    690                // Initiate a Match Description Request (Service Discovery)
    691                /*dstAddr.addrMode = AddrBroadcast;
    692                dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
    693                ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR,
    694                                  LightCtl_PROFID,
    695                                  LightCtl_MAX_CLUSTERS, (cId_t *)LightCtl_ClusterList,
    696                                  LightCtl_MAX_CLUSTERS, (cId_t *)LightCtl_ClusterList,
    697                                  FALSE );*/
    698              }
    699            }
    700          }
   \                     ??LightCtl_HandleKeys_0:
   \   0000CE   02....       LJMP    ??Subroutine11_0 & 0xFFFF

   \                                 In  segment XDATA_Z, align 1, keep-with-next
   \                     ??cnt:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    701          
    702          /*********************************************************************
    703           * LOCAL FUNCTIONS
    704           */
    705          
    706          /*********************************************************************
    707           * @fn      LightCtl_MessageMSGCB
    708           *
    709           * @brief   Data message processor callback.  This function processes
    710           *          any incoming data - probably from other devices.  So, based
    711           *          on cluster ID, perform the intended action.
    712           *
    713           * @param   none
    714           *
    715           * @return  none
    716           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    717          void LightCtl_MessageMSGCB( afIncomingMSGPacket_t *pkt )
   \                     LightCtl_MessageMSGCB:
    718          {
   \   000000   74F7         MOV     A,#-0x9
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 9
   \   000005                ; Auto size: 0
    719            //uint16 flashTime;
    720            /*
    721            uint16 short_ddr;
    722            uint8 *pointer1; 
    723            uint8 *pointer2;
    724            uint8 *pointer3;
    725            uint8 *pointer4;
    726            uint8 *pointer5;
    727            uint8 *pointer6;
    728            uint8 *pointer7;
    729            uint8 *pointer8;
    730            uint8 *pointer9;
    731            
    732            uint8 str_1[ ]="Source address:";
    733            uint8 str_2[ ]="Destination address:";
    734            uint8 str_3[ ]="Data length:";
    735            uint8 str_4[ ]="Data:";
    736            uint8 str_5[ ]={'\n'};
    737            
    738            pointer1=&str_1[0];
    739            pointer2=&str_2[0];
    740            pointer3=&str_3[0];
    741            pointer4=&str_4[0];
    742            pointer9=&str_5[0];
    743            
    744            uint8 Src_short_ddr_H;
    745            uint8 Src_short_ddr_L;
    746            uint8 Des_short_ddr_H;
    747            uint8 Des_short_ddr_L;
    748            
    749            uint8 word_buffer[4];
    750            uint8 Src_shortaddr[7];
    751            uint8 Des_shortaddr[7];*/
    752            
    753            uint16 short_ddr;
    754            uint8 short_ddr_H;
    755            uint8 short_ddr_L;
    756            uint8 *pIeeeAddr;  
    757            
    758            
    759            switch ( pkt->clusterId )
   \   000005   8A82         MOV     DPL,R2
   \   000007   8B83         MOV     DPH,R3
   \   000009   A3           INC     DPTR
   \   00000A   A3           INC     DPTR
   \   00000B   A3           INC     DPTR
   \   00000C   A3           INC     DPTR
   \   00000D   E0           MOVX    A,@DPTR
   \   00000E   6401         XRL     A,#0x1
   \   000010   7002         JNZ     ??LightCtl_MessageMSGCB_0
   \   000012   A3           INC     DPTR
   \   000013   E0           MOVX    A,@DPTR
   \                     ??LightCtl_MessageMSGCB_0:
   \   000014   703B         JNZ     ??LightCtl_MessageMSGCB_1
    760            {
    761              case LightCtl_CLUSTERID:
    762                // "the" message
    763          #if defined( LCD_SUPPORTED )
    764                HalLcdWriteScreen( (char*)pkt->cmd.Data, "rcvd" );
   \   000016   EA           MOV     A,R2
   \   000017   2421         ADD     A,#0x21
   \   000019   FE           MOV     R6,A
   \   00001A   EB           MOV     A,R3
   \   00001B   3400         ADDC    A,#0x0
   \   00001D   FF           MOV     R7,A
   \   00001E                ; Setup parameters for call to function HalLcdWriteScreen
   \   00001E   7C..         MOV     R4,#(`?<Constant "rcvd">` & 0xff)
   \   000020   7D..         MOV     R5,#((`?<Constant "rcvd">` >> 8) & 0xff)
   \   000022   8E82         MOV     DPL,R6
   \   000024   8F83         MOV     DPH,R7
   \   000026   E0           MOVX    A,@DPTR
   \   000027   FA           MOV     R2,A
   \   000028   A3           INC     DPTR
   \   000029   E0           MOVX    A,@DPTR
   \   00002A   FB           MOV     R3,A
   \   00002B   12....       LCALL   ??HalLcdWriteScreen?relay
    765          #elif defined( WIN32 )
    766                WPRINTSTR( pkt->cmd.Data );
    767          #endif
    768               
    769                short_ddr_H=pkt->cmd.Data[1];
    770                short_ddr_L=pkt->cmd.Data[2];
    771                
    772                short_ddr=(short_ddr_H<<8)|short_ddr_L;
    773                
    774                pIeeeAddr = &pkt->cmd.Data[3];
    775                
    776                UartShowNtkInfo(short_ddr,pIeeeAddr + Z_EXTADDR_LEN - 1);
   \   00002E   8E82         MOV     DPL,R6
   \   000030   8F83         MOV     DPH,R7
   \   000032   E0           MOVX    A,@DPTR
   \   000033   F8           MOV     R0,A
   \   000034   A3           INC     DPTR
   \   000035   E0           MOVX    A,@DPTR
   \   000036   F9           MOV     R1,A
   \   000037                ; Setup parameters for call to function UartShowNtkInfo
   \   000037   E8           MOV     A,R0
   \   000038   240A         ADD     A,#0xa
   \   00003A   FC           MOV     R4,A
   \   00003B   E9           MOV     A,R1
   \   00003C   3400         ADDC    A,#0x0
   \   00003E   FD           MOV     R5,A
   \   00003F   8882         MOV     DPL,R0
   \   000041   8983         MOV     DPH,R1
   \   000043   A3           INC     DPTR
   \   000044   E0           MOVX    A,@DPTR
   \   000045   FB           MOV     R3,A
   \   000046   8882         MOV     DPL,R0
   \   000048   8983         MOV     DPH,R1
   \   00004A   A3           INC     DPTR
   \   00004B   A3           INC     DPTR
   \   00004C   E0           MOVX    A,@DPTR
   \   00004D   FA           MOV     R2,A
   \   00004E   12....       LCALL   ??UartShowNtkInfo?relay
    777                
    778                
    779                //HalUARTWrite(SERIAL_APP_PORT, pkt->cmd.Data, pkt->cmd.DataLength);
    780                
    781                /*####################################################*/
    782          //      flashTime = BUILD_UINT16(pkt->cmd.Data[1], pkt->cmd.Data[2] );
    783          //      HalLedBlink( HAL_LED_4, 4, 50, (flashTime / 4) );
    784                
    785                /*pointer5=&(pkt->cmd.Data[3]);         //pointer5:具体数据首地址
    786          
    787                word_buffer[0]=(pkt->cmd.Data[0])/100+48;
    788                word_buffer[1]=((pkt->cmd.Data[0])%100)/10+48;
    789                word_buffer[2]=(pkt->cmd.Data[0])%10+48;
    790                word_buffer[3]='\n';
    791                pointer6=word_buffer;                      //pointer6:数据长度
    792          
    793          //----------------
    794                Src_short_ddr_H=pkt->cmd.Data[1];
    795                Src_short_ddr_L=pkt->cmd.Data[2];
    796          
    797                Src_shortaddr[0]=48;
    798                Src_shortaddr[1]=120;
    799                Src_shortaddr[2]=hextoword1(Src_short_ddr_H);
    800                Src_shortaddr[3]=hextoword2(Src_short_ddr_H);
    801                Src_shortaddr[4]=hextoword1(Src_short_ddr_L);
    802                Src_shortaddr[5]=hextoword2(Src_short_ddr_L);
    803                Src_shortaddr[6]='\n';
    804                pointer7=&Src_shortaddr[0];         //pointer7:源地址
    805                //----------------
    806                short_ddr=NLME_GetShortAddr();
    807                Des_short_ddr_H=(uint8)((short_ddr&0xff00)>>8);
    808                Des_short_ddr_L=(uint8)short_ddr;
    809                Des_shortaddr[0]=48;
    810                Des_shortaddr[1]=120;
    811                Des_shortaddr[2]=hextoword1(Des_short_ddr_H);
    812                Des_shortaddr[3]=hextoword2(Des_short_ddr_H);
    813                Des_shortaddr[4]=hextoword1(Des_short_ddr_L);
    814                Des_shortaddr[5]=hextoword2(Des_short_ddr_L);
    815                Des_shortaddr[6]='\n';
    816                pointer8=&Des_shortaddr[0];       //pointer8:目的地址
    817          
    818                //----------------      
    819                HalUARTWrite ( 0, pointer1, 15 );   //源地址
    820                HalUARTWrite ( 0, pointer7, 7 );
    821                
    822                HalUARTWrite ( 0, pointer2, 20 );   //目的地址
    823                HalUARTWrite ( 0, pointer8, 7 );
    824                  
    825                HalUARTWrite ( 0, pointer3, 12 );   //数据长度
    826                HalUARTWrite ( 0, pointer6, 4 );
    827                
    828                HalUARTWrite ( 0, pointer4, 5 );    //具体数据     
    829                HalUARTWrite ( 0, pointer5, pkt->cmd.Data[0] );  //pkt->cmd.Data[0]=rxlen,为原始长度 
    830                
    831                HalUARTWrite ( 0, pointer9, 1 );    //换行符
    832                HalUARTWrite ( 0, pointer9, 1 );
    833                
    834                //pointer1=&(pkt->cmd.Data[3]);
    835                //HalUARTWrite ( 0, pointer1, 6 );*/
    836                /*####################################################*/
    837          
    838                
    839                break;
    840            }
    841          }
   \                     ??LightCtl_MessageMSGCB_1:
   \   000051   7F01         MOV     R7,#0x1
   \   000053   02....       LJMP    ?BANKED_LEAVE_XDATA
    842          
    843          /*********************************************************************
    844           * @fn      LightCtl_SendTheMessage
    845           *
    846           * @brief   Send "the" message.
    847           *
    848           * @param   none
    849           *
    850           * @return  none
    851           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    852          void LightCtl_SendTheMessage( void )
   \                     LightCtl_SendTheMessage:
    853          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 12
   \   000005   74F4         MOV     A,#-0xc
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    854            char theMessageData[] = "Hello World";
   \   00000A   85..82       MOV     DPL,?XSP + 0
   \   00000D   85..83       MOV     DPH,?XSP + 1
   \   000010   AC82         MOV     R4,DPL
   \   000012   AD83         MOV     R5,DPH
   \   000014   7583..       MOV     DPH,#((`?<Constant "Hello World">` >> 8) & 0xff)
   \   000017   7582..       MOV     DPL,#(`?<Constant "Hello World">` & 0xff)
   \   00001A   740C         MOV     A,#0xc
   \   00001C   12....       LCALL   ?MOVE_LONG8_XDATA_XDATA
    855          
    856            if ( AF_DataRequest( &LightCtl_DstAddr, &LightCtl_epDesc,
    857                                 LightCtl_CLUSTERID,
    858                                 (byte)osal_strlen( theMessageData ) + 1,
    859                                 (byte *)&theMessageData,
    860                                 &LightCtl_TransID,
    861                                 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
   \   00001F                ; Setup parameters for call to function AF_DataRequest
   \   00001F   75..1E       MOV     ?V0 + 0,#0x1e
   \   000022   78..         MOV     R0,#?V0 + 0
   \   000024   12....       LCALL   ?PUSH_XSTACK_I_ONE
   \   000027   75....       MOV     ?V0 + 0,#(LightCtl_TransID & 0xff)
   \   00002A   75....       MOV     ?V0 + 1,#((LightCtl_TransID >> 8) & 0xff)
   \   00002D   78..         MOV     R0,#?V0 + 0
   \   00002F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000032   7403         MOV     A,#0x3
   \   000034   12....       LCALL   ?XSTACK_DISP0_8
   \   000037   8582..       MOV     ?V0 + 0,DPL
   \   00003A   8583..       MOV     ?V0 + 1,DPH
   \   00003D   78..         MOV     R0,#?V0 + 0
   \   00003F   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   000042                ; Setup parameters for call to function osal_strlen
   \   000042   7405         MOV     A,#0x5
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   AA82         MOV     R2,DPL
   \   000049   AB83         MOV     R3,DPH
   \   00004B   12....       LCALL   ??osal_strlen?relay
   \   00004E   EA           MOV     A,R2
   \   00004F   F8           MOV     R0,A
   \   000050   7401         MOV     A,#0x1
   \   000052   28           ADD     A,R0
   \   000053   F5..         MOV     ?V0 + 0,A
   \   000055   E4           CLR     A
   \   000056   3400         ADDC    A,#0x0
   \   000058   F5..         MOV     ?V0 + 1,A
   \   00005A   78..         MOV     R0,#?V0 + 0
   \   00005C   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00005F   75..01       MOV     ?V0 + 0,#0x1
   \   000062   75..00       MOV     ?V0 + 1,#0x0
   \   000065   78..         MOV     R0,#?V0 + 0
   \   000067   12....       LCALL   ?PUSH_XSTACK_I_TWO
   \   00006A   7920         MOV     R1,#0x20
   \   00006C   7C..         MOV     R4,#(LightCtl_epDesc & 0xff)
   \   00006E   7D..         MOV     R5,#((LightCtl_epDesc >> 8) & 0xff)
   \   000070   7A..         MOV     R2,#(LightCtl_DstAddr & 0xff)
   \   000072   7B..         MOV     R3,#((LightCtl_DstAddr >> 8) & 0xff)
   \   000074   12....       LCALL   ??AF_DataRequest?relay
   \   000077   7409         MOV     A,#0x9
   \   000079   12....       LCALL   ?DEALLOC_XSTACK8
    862            {
    863              // Successfully requested to be sent.
    864            }
    865            else
    866            {
    867              // Error occurred in request to send.
    868            }
    869          }
   \   00007C   740C         MOV     A,#0xc
   \   00007E   02....       LJMP    ?Subroutine10 & 0xFFFF
    870          
    871          /*********************************************************************
    872           * @fn      SerialApp_CallBack
    873           *
    874           * @brief   Send data OTA.
    875           *
    876           * @param   port - UART port.
    877           * @param   event - the UART port event flag.
    878           *
    879           * @return  none
    880           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    881          static void SerialApp_CallBack(uint8 port, uint8 event)
   \                     SerialApp_CallBack:
    882          {
   \   000000   74F6         MOV     A,#-0xa
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 10
   \   000005                ; Auto size: 0
    883            /*(void)port;
    884            if (!SerialApp_Len && 
    885                (SerialApp_Len = HalUARTRead(SERIAL_APP_PORT, SerialApp_Buf+1, SERIAL_APP_TX_MAX)))
    886            {
    887              // Pre-pend sequence number to the Tx message.
    888              SerialApp_Buf[0] = ++SerialApp_TxSeq;
    889            }*/
    890            
    891            //  uint8  rxlen;    //接收数据长度
    892          //  uint8*  dataybuf;//接收数据块指针
    893            extern uint8 LightCtl_TaskID;
    894            uint16 short_ddr;
    895            uint8 short_ddr_H;
    896            uint8 short_ddr_L;
    897          //  uint8 *pointer1;
    898          //  uint8 word_buffer[8];
    899          
    900            short_ddr=NLME_GetShortAddr();
   \   000005                ; Setup parameters for call to function NLME_GetShortAddr
   \   000005   12....       LCALL   ??NLME_GetShortAddr?relay
   \   000008   8A..         MOV     ?V0 + 0,R2
   \   00000A   8B..         MOV     ?V0 + 1,R3
    901            short_ddr_H=(uint8)((short_ddr&0xff00)>>8);
    902            short_ddr_L=(uint8)short_ddr;
    903            rxlen=Hal_UART_RxBufLen(SERIAL_APP_PORT);  //接收缓冲区数据长度,字节为单位
   \   00000C                ; Setup parameters for call to function Hal_UART_RxBufLen
   \   00000C   7900         MOV     R1,#0x0
   \   00000E   12....       LCALL   ??Hal_UART_RxBufLen?relay
   \   000011   EA           MOV     A,R2
   \   000012   90....       MOV     DPTR,#rxlen
   \   000015   F0           MOVX    @DPTR,A
    904            databuf=osal_mem_alloc(rxlen+1+2);   //多分配3字节,分配如下
   \   000016                ; Setup parameters for call to function osal_mem_alloc
   \   000016   F8           MOV     R0,A
   \   000017   7403         MOV     A,#0x3
   \   000019   28           ADD     A,R0
   \   00001A   0A           INC     R2
   \   00001B   0A           INC     R2
   \   00001C   0A           INC     R2
   \   00001D   E4           CLR     A
   \   00001E   3400         ADDC    A,#0x0
   \   000020   FB           MOV     R3,A
   \   000021   12....       LCALL   ??osal_mem_alloc?relay
   \   000024   90....       MOV     DPTR,#databuf
   \   000027   EA           MOV     A,R2
   \   000028   F0           MOVX    @DPTR,A
   \   000029   A3           INC     DPTR
   \   00002A   EB           MOV     A,R3
   \   00002B   F0           MOVX    @DPTR,A
    905            databuf[0]=rxlen;                           //一字节存放数据长度
   \   00002C   90....       MOV     DPTR,#rxlen
   \   00002F   E0           MOVX    A,@DPTR
   \   000030   C0E0         PUSH    A
   \   000032   90....       MOV     DPTR,#databuf
   \   000035   12....       LCALL   ?Subroutine6 & 0xFFFF
   \                     ??CrossCallReturnLabel_17:
   \   000038   D0E0         POP     A
   \   00003A   12....       LCALL   ?Subroutine3 & 0xFFFF
    906            databuf[1]=short_ddr_H;              //一字节存放源地址高8位
   \                     ??CrossCallReturnLabel_10:
   \   00003D   E5..         MOV     A,?V0 + 1
   \   00003F   12....       LCALL   ?Subroutine3 & 0xFFFF
    907            databuf[2]=short_ddr_L;              //一字节存放源地址低8位
   \                     ??CrossCallReturnLabel_11:
   \   000042   A3           INC     DPTR
   \   000043   E5..         MOV     A,?V0 + 0
   \   000045   F0           MOVX    @DPTR,A
    908          //databuf[rxlen+1]='\n';                    //一字节存放换行符
    909            HalUARTRead ( SERIAL_APP_PORT, databuf+3, rxlen); //读接收缓冲区数据到内存databuf+3
   \   000046                ; Setup parameters for call to function HalUARTRead
   \   000046   90....       MOV     DPTR,#rxlen
   \   000049   E0           MOVX    A,@DPTR
   \   00004A   FC           MOV     R4,A
   \   00004B   7D00         MOV     R5,#0x0
   \   00004D   90....       MOV     DPTR,#databuf
   \   000050   E0           MOVX    A,@DPTR
   \   000051   2403         ADD     A,#0x3
   \   000053   FA           MOV     R2,A
   \   000054   A3           INC     DPTR
   \   000055   E0           MOVX    A,@DPTR
   \   000056   3400         ADDC    A,#0x0
   \   000058   FB           MOV     R3,A
   \   000059   7900         MOV     R1,#0x0
   \   00005B   12....       LCALL   ??HalUARTRead?relay
    910          
    911            /* 回显数据(测试用)
    912            word_buffer[0]='l';
    913            word_buffer[1]='e';
    914            word_buffer[2]='n';
    915            word_buffer[3]=':';  
    916            word_buffer[4]=databuf[0]/100+48;
    917            word_buffer[5]=(databuf[0]%100)/10+48;
    918            word_buffer[6]=databuf[0]%10+48;
    919            word_buffer[7]='\n';
    920            pointer1=word_buffer; 
    921            //  HalUARTWrite()写入串口正确说明数据已经正确地存储在databuf中!
    922            HalUARTWrite ( SPI_MGR_DEFAULT_PORT, pointer1, 8 );  
    923            HalUARTWrite ( SPI_MGR_DEFAULT_PORT, databuf+1, rxlen+1 );//把数据送串口输出
    924            */  
    925            if(!rxlen)
   \   00005E   90....       MOV     DPTR,#rxlen
   \   000061   E0           MOVX    A,@DPTR
   \   000062   700B         JNZ     ??SerialApp_CallBack_0
    926              osal_mem_free( databuf );  //释放内存  
   \   000064                ; Setup parameters for call to function osal_mem_free
   \   000064   90....       MOV     DPTR,#databuf
   \   000067   E0           MOVX    A,@DPTR
   \   000068   FA           MOV     R2,A
   \   000069   A3           INC     DPTR
   \   00006A   E0           MOVX    A,@DPTR
   \   00006B   FB           MOV     R3,A
   \   00006C   12....       LCALL   ??osal_mem_free?relay
    927              osal_set_event(LightCtl_TaskID,UART_RX_CB_EVT);
   \                     ??SerialApp_CallBack_0:
   \   00006F                ; Setup parameters for call to function osal_set_event
   \   00006F   7A02         MOV     R2,#0x2
   \   000071   7B00         MOV     R3,#0x0
   \   000073   90....       MOV     DPTR,#LightCtl_TaskID
   \   000076   E0           MOVX    A,@DPTR
   \   000077   F9           MOV     R1,A
   \   000078   12....       LCALL   ??osal_set_event?relay
    928          //  rxCB_to_SampleApp( databuf, rxlen );
    929          }
   \   00007B   02....       LJMP    ??Subroutine11_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   90....       MOV     DPTR,#databuf
   \   000004   12....       LCALL   ?Subroutine8 & 0xFFFF
   \                     ??CrossCallReturnLabel_21:
   \   000007   A3           INC     DPTR
   \   000008   22           RET

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??hextoword1?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    hextoword1

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??hextoword2?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    hextoword2

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??UartShowNtkInfo?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    UartShowNtkInfo

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??LightCtl_Init?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LightCtl_Init

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??LightCtl_ProcessEvent?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LightCtl_ProcessEvent

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??LightCtl_ProcessZDOMsgs?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LightCtl_ProcessZDOMsgs

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??LightCtl_HandleKeys?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LightCtl_HandleKeys

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??LightCtl_MessageMSGCB?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LightCtl_MessageMSGCB

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??LightCtl_SendTheMessage?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    LightCtl_SendTheMessage

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??SerialApp_CallBack?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    SerialApp_CallBack

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "my short address is:">`:
   \   000000   6D792073     DB "my short address is:"
   \            686F7274
   \            20616464
   \            72657373
   \            2069733A
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "join the network succ...">`:
   \   000000   6A6F696E     DB "join the network successfully "
   \            20746865
   \            206E6574
   \            776F726B
   \            20737563
   \            63657373
   \            66756C6C
   \            792000  

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant {32}>`:
   \   000000   20           DB 32

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "my ieee address is:">`:
   \   000000   6D792069     DB "my ieee address is:"
   \            65656520
   \            61646472
   \            65737320
   \            69733A00

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "SerialApp">`:
   \   000000   53657269     DB "SerialApp"
   \            616C4170
   \            7000    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "LightCtl">`:
   \   000000   4C696768     DB "LightCtl"
   \            7443746C
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "123">`:
   \   000000   31323300     DB "123"

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Joystick HAL_KEY_SW_3">`:
   \   000000   4A6F7973     DB "Joystick HAL_KEY_SW_3"
   \            7469636B
   \            2048414C
   \            5F4B4559
   \            5F53575F
   \            3300    

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "rcvd">`:
   \   000000   72637664     DB "rcvd"
   \            00      

   \                                 In  segment XDATA_ROM_C, align 1
   \                     `?<Constant "Hello World">`:
   \   000000   48656C6C     DB "Hello World"
   \            6F20576F
   \            726C6400
    930          
    931          /*********************************************************************
    932          *********************************************************************/

   Maximum stack usage in bytes:

     Function                     ISTACK PSTACK XSTACK
     --------                     ------ ------ ------
     LightCtl_HandleKeys              0      0     42
       -> HalLedBlink                 0      0     20
       -> AF_DataRequest              0      0     38
       -> HalLcdWriteValue            0      0     22
       -> HalLedBlink                 0      0     20
       -> HalLedBlink                 0      0     20
       -> HalUARTWrite                0      0     20
       -> HalLcdWriteString           0      0     20
       -> HalLedBlink                 0      0     20
     LightCtl_Init                    3      0     29
       -> afRegister                  4      0     58
       -> RegisterForKeys             4      0     58
       -> HalUARTOpen                 4      0     58
       -> HalLcdWriteString           4      0     58
       -> HalLcdWriteString           4      0     58
     LightCtl_MessageMSGCB            0      0     32
       -> HalLcdWriteScreen           0      0     18
       -> UartShowNtkInfo             0      0     18
     LightCtl_ProcessEvent            1      0     32
       -> osal_msg_receive            0      0     46
       -> NLME_GetShortAddr           0      0     46
       -> NLME_GetExtAddr             0      0     46
       -> AF_DataRequest              0      0     64
       -> osal_msg_deallocate         0      0     46
       -> osal_msg_receive            0      0     46
       -> LightCtl_HandleKeys         0      0     46
       -> LightCtl_MessageMSGCB       0      0     46
       -> LightCtl_SendTheMessage     0      0     46
       -> osal_start_timerEx          0      0     46
     LightCtl_ProcessZDOMsgs          0      0     10
       -> HalLedSet                   0      0     20
       -> HalLedSet                   0      0     20
       -> ZDO_ParseEPListRsp          0      0     20
       -> HalLedSet                   0      0     20
       -> osal_mem_free               0      0     20
     LightCtl_SendTheMessage          2      0     54
       -> osal_strlen                 0      0     54
       -> AF_DataRequest              0      0     62
     SerialApp_CallBack               1      0     10
       -> NLME_GetShortAddr           0      0     20
       -> Hal_UART_RxBufLen           0      0     20
       -> osal_mem_alloc              0      0     20
       -> HalUARTRead                 0      0     20
       -> osal_mem_free               0      0     20
       -> osal_set_event              0      0     20
     UartShowNtkInfo                  2      0    116
       -> hextoword1                  0      0    214
       -> hextoword2                  0      0    214
       -> hextoword1                  0      0    214
       -> hextoword2                  0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
       -> HalUARTWrite                0      0    214
     hextoword1                       0      0    107
     hextoword2                       0      0    107


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     rxlen                                     1
     databuf                                   2
     LightCtl_ClusterList                      2
     LightCtl_SimpleDesc                      12
     LightCtl_epDesc                           6
     LightCtl_TaskID                           1
     LightCtl_NwkState                         1
     LightCtl_TransID                          1
     LightCtl_DstAddr                         12
     hextoword1                               16
     ?Subroutine9                              5
     hextoword2                               17
     UartShowNtkInfo                         371
     ?Subroutine5                             13
     ?Subroutine4                             10
     ?Subroutine0                             29
     ?Subroutine10                             3
     ??Subroutine11_0                          5
     LightCtl_Init                           201
     ?Subroutine2                             20
     LightCtl_ProcessEvent                   424
     ?Subroutine1                              8
     ?Subroutine7                              7
     LightCtl_ProcessZDOMsgs                 153
     ?Subroutine6                              4
     ?Subroutine8                              9
     LightCtl_HandleKeys                     209
     cnt                                       1
     LightCtl_MessageMSGCB                    86
     LightCtl_SendTheMessage                 129
     SerialApp_CallBack                      126
     ?Subroutine3                              9
     ??hextoword1?relay                        6
     ??hextoword2?relay                        6
     ??UartShowNtkInfo?relay                   6
     ??LightCtl_Init?relay                     6
     ??LightCtl_ProcessEvent?relay             6
     ??LightCtl_ProcessZDOMsgs?relay           6
     ??LightCtl_HandleKeys?relay               6
     ??LightCtl_MessageMSGCB?relay             6
     ??LightCtl_SendTheMessage?relay           6
     ??SerialApp_CallBack?relay                6
     ?<Constant "my short address is:">       21
     ?<Constant "join the network succ...">   31
     ?<Constant {32}>                          1
     ?<Constant "my ieee address is:">        20
     ?<Constant "SerialApp">                  10
     ?<Constant "LightCtl">                    9
     ?<Constant "123">                         4
     ?<Constant "Joystick HAL_KEY_SW_3">      22
     ?<Constant "rcvd">                        5
     ?<Constant "Hello World">                12

 
 1 854 bytes in segment BANKED_CODE
    60 bytes in segment BANK_RELAYS
   149 bytes in segment XDATA_ROM_C
    25 bytes in segment XDATA_Z
 
 1 914 bytes of CODE  memory
   149 bytes of CONST memory
    25 bytes of XDATA memory

Errors: none
Warnings: none
