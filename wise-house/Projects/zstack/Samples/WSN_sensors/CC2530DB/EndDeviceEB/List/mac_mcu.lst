###############################################################################
#                                                                             #
# IAR C/C++ Compiler V7.51A/W32 for 8051                29/Sep/2011  15:47:21 #
# Copyright 2004-2009 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Com #
#                          ponents\mac\low_level\srf04\single_chip\mac_mcu.c  #
#    Command line       =  -f "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0 #
#                          \Projects\zstack\Samples\LightCtlPrj\CC2530DB\..\. #
#                          .\..\Tools\CC2530DB\f8wEndev.cfg" (-DCPU32MHZ      #
#                          -DROOT=__near_func -DBLINK_LEDS) -f "C:\Texas      #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\Tools\CC #
#                          2530DB\f8wConfig.cfg" (-DSECURE=0                  #
#                          -DZG_SECURE_DYNAMIC=0 -DREFLECTOR                  #
#                          -DDEFAULT_CHANLIST=0x00001000                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x1212                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=100               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116 "-DCONST=const __code"    #
#                          -DGENERIC=__generic -DRFD_RCVC_ALWAYS_ON=FALSE     #
#                          -DPOLL_RATE=1000 -DQUEUED_POLL_RATE=100            #
#                          -DRESPONSE_POLL_RATE=100) -DREJOIN_POLL_RATE=440   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Co #
#                          mponents\mac\low_level\srf04\single_chip\mac_mcu.c #
#                          " -D NWK_AUTO_POLL -D ZTOOL_P1 -D MT_TASK -D       #
#                          MT_SYS_FUNC -D MT_ZDO_FUNC -D LCD_SUPPORTED=DEBUG  #
#                          -D HAL_UART=TRUE -D xPOWER_SAVING -lC "C:\Texas    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\EndDeviceEB\List\ #
#                          " -lA "C:\Texas Instruments\ZStack-CC2530-2.2.2-1. #
#                          3.0\Projects\zstack\Samples\LightCtlPrj\CC2530DB\E #
#                          ndDeviceEB\List\" --diag_suppress Pe001,Pa010 -o   #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevi #
#                          ceEB\Obj\" -e --require_prototypes --debug         #
#                          --core=plain --dptr=16,1 --data_model=large        #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 8 -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\" -I "C:\Texas    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\SOURCE\" -I    #
#                          "C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pr #
#                          ojects\zstack\Samples\LightCtlPrj\CC2530DB\..\..\. #
#                          .\ZMAIN\TI2530DB\" -I "C:\Texas                    #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MT\" -I "C:\Texas                         #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\HAL\TARGET\CC2530EB\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\MCU\CCSOC\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\OSAL\INCLUDE\" -I "C:\Texas               #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\AF\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\NWK\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SEC\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SAPI\" -I "C:\Texas                 #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\SYS\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\STACK\ZDO\" -I "C:\Texas                  #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\F8W\" -I "C:\Texas                   #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\ZMAC\" -I "C:\Texas                       #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SADDR\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\SERVICES\SDATA\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\INCLUDE\" -I "C:\Texas                #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\HIGH_LEVEL\" -I "C:\Texas             #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\" -I "C:\Texas        #
#                          Instruments\ZStack-CC2530-2.2.2-1.3.0\Projects\zst #
#                          ack\Samples\LightCtlPrj\CC2530DB\..\..\..\..\..\CO #
#                          MPONENTS\MAC\LOW_LEVEL\srf04\SINGLE_CHIP\" -I      #
#                          "C:\Program Files\IAR Systems\Embedded Workbench   #
#                          5.3\8051\INC\" -I "C:\Program Files\IAR            #
#                          Systems\Embedded Workbench 5.3\8051\INC\CLIB\"     #
#                          -Ohz                                               #
#    List file          =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevic #
#                          eEB\List\mac_mcu.lst                               #
#    Object file        =  C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Pro #
#                          jects\zstack\Samples\LightCtlPrj\CC2530DB\EndDevic #
#                          eEB\Obj\mac_mcu.r51                                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Texas Instruments\ZStack-CC2530-2.2.2-1.3.0\Components\mac\low_level\srf04\single_chip\mac_mcu.c
      1          /**************************************************************************************************
      2            Filename:       mac_mcu.c
      3            Revised:        $Date: 2009-09-18 16:00:34 -0700 (Fri, 18 Sep 2009) $
      4            Revision:       $Revision: 20794 $
      5          
      6            Description:    Describe the purpose and contents of the file.
      7          
      8          
      9            Copyright 2006-2009 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED “AS IS” WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          
     45          /* hal */
     46          #include "hal_defs.h"
     47          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x91
   \   unsigned char volatile __sfr RFIRQF1
   \                     RFIRQF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x94
   \   unsigned char volatile __sfr T2CTRL
   \                     T2CTRL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9b
   \   unsigned char volatile __sfr S1CON
   \                     S1CON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa1
   \   unsigned char volatile __sfr T2IRQF
   \                     T2IRQF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa2
   \   unsigned char volatile __sfr T2M0
   \                     T2M0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa3
   \   unsigned char volatile __sfr T2M1
   \                     T2M1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa4
   \   unsigned char volatile __sfr T2MOVF0
   \                     T2MOVF0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa5
   \   unsigned char volatile __sfr T2MOVF1
   \                     T2MOVF1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa6
   \   unsigned char volatile __sfr T2MOVF2
   \                     T2MOVF2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa7
   \   unsigned char volatile __sfr T2IRQM
   \                     T2IRQM:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa9
   \   unsigned char volatile __sfr IP0
   \                     IP0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb4
   \   unsigned char volatile __sfr ADCCON1
   \                     ADCCON1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb9
   \   unsigned char volatile __sfr IP1
   \                     IP1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbc
   \   unsigned char volatile __sfr RNDL
   \                     RNDL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbd
   \   unsigned char volatile __sfr RNDH
   \                     RNDH:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbf
   \   unsigned char volatile __sfr RFERRF
   \                     RFERRF:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc3
   \   unsigned char volatile __sfr T2MSEL
   \                     T2MSEL:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xe9
   \   unsigned char volatile __sfr RFIRQF0
   \                     RFIRQF0:
   \   000000                DS 1
     48          
     49          /* low-level specific */
     50          #include "mac_rx.h"
     51          #include "mac_tx.h"
     52          #include "mac_backoff_timer.h"
     53          #include "mac_csp_tx.h"
     54          #include "mac_rx_onoff.h"
     55          #include "mac_low_level.h"
     56          
     57          /* target specific */
     58          #include "mac_mcu.h"
     59          #include "mac_radio_defs.h"
     60          
     61          /* debug */
     62          #include "mac_assert.h"
     63          
     64          
     65          /* ------------------------------------------------------------------------------------------------
     66           *                                           Defines
     67           * ------------------------------------------------------------------------------------------------
     68           */
     69          
     70          #if !defined (OSC32K_CRYSTAL_INSTALLED) || (defined (OSC32K_CRYSTAL_INSTALLED) && (OSC32K_CRYSTAL_INSTALLED == TRUE))
     71          #define T2CNF_BASE_VALUE    (RUN | SYNC)
     72          #else
     73          #define T2CNF_BASE_VALUE     RUN
     74          #endif
     75          
     76          /* for optimized indexing of uint32's */
     77          #if HAL_MCU_LITTLE_ENDIAN()
     78          #define UINT32_NDX0   0
     79          #define UINT32_NDX1   1
     80          #define UINT32_NDX2   2
     81          #define UINT32_NDX3   3
     82          #else
     83          #define UINT32_NDX0   3
     84          #define UINT32_NDX1   2
     85          #define UINT32_NDX2   1
     86          #define UINT32_NDX3   0
     87          #endif
     88          
     89          /* ------------------------------------------------------------------------------------------------
     90           *                                        Local Variables
     91           * ------------------------------------------------------------------------------------------------
     92           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     93          uint8       macChipVersion = 0;
   \                     macChipVersion:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z

   \                                 In  segment XDATA_Z, align 1, keep-with-next
     94          static int8 maxRssi;
   \                     maxRssi:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
     95          
     96          
     97          /*
     98           *  This number is used to calculate the precision count for OSAL timer update. In Beacon mode,
     99           *  the overflow count may be initialized to zero or to a constant. The "skip" in overflow count
    100           *  needs to be accounted for in this variable.
    101           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    102          static uint32 accumulatedOverflowCount = 0;
   \                     accumulatedOverflowCount:
   \   000000                DS 4
   \   000004                REQUIRE __INIT_XDATA_Z
    103          
    104          /* ------------------------------------------------------------------------------------------------
    105           *                                       Local Prototypes
    106           * ------------------------------------------------------------------------------------------------
    107           */
    108          static void mcuRecordMaxRssiIsr(void);
    109          static uint32 macMcuOverflowGetCompare(void);
    110          
    111          
    112          /**************************************************************************************************
    113           * @fn          macMcuInit
    114           *
    115           * @brief       Initialize the MCU.
    116           *
    117           * @param       none
    118           *
    119           * @return      none
    120           **************************************************************************************************
    121           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    122          void macMcuInit(void)
   \                     macMcuInit:
    123          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    124            halIntState_t  s;
    125          
    126            /* This CORR_THR value should be changed to 0x14 before attempting RX. Testing has shown that
    127             * too many false frames are received if the reset value is used. Make it more likely to detect
    128             * sync by removing the requirement that both symbols in the SFD must have a correlation value
    129             * above the correlation threshold, and make sync word detection less likely by raising the
    130             * correlation threshold.
    131             */
    132            MDMCTRL1 = CORR_THR;
   \   000004   7414         MOV     A,#0x14
   \   000006   9061A9       MOV     DPTR,#0x61a9
   \   000009   F0           MOVX    @DPTR,A
    133          
    134            /* tuning adjustments for optimal radio performance; details available in datasheet */
    135            RXCTRL = 0x3F;
   \   00000A   743F         MOV     A,#0x3f
   \   00000C   9061AB       MOV     DPTR,#0x61ab
   \   00000F   F0           MOVX    @DPTR,A
    136          
    137            /* Raises the CCA threshold from about -108dBm to about -80 dBm input level.
    138             */
    139            CCACTRL0 = CCA_THR;
   \   000010   74F8         MOV     A,#-0x8
   \   000012   906196       MOV     DPTR,#0x6196
   \   000015   F0           MOVX    @DPTR,A
    140          
    141            /* Makes sync word detection less likely by requiring two zero symbols before the sync word.
    142             * details available in datasheet.
    143             */
    144            MDMCTRL0 = 0x85;
   \   000016   7485         MOV     A,#-0x7b
   \   000018   9061A8       MOV     DPTR,#0x61a8
   \   00001B   F0           MOVX    @DPTR,A
    145          
    146            /* Adjust current in synthesizer; details available in datasheet. */
    147            FSCTRL = 0x5A;
   \   00001C   745A         MOV     A,#0x5a
   \   00001E   9061AC       MOV     DPTR,#0x61ac
   \   000021   F0           MOVX    @DPTR,A
    148          
    149            /* Adjust current in VCO; details available in datasheet. */
    150            FSCAL1 = 0x00;
   \   000022   E4           CLR     A
   \   000023   9061AE       MOV     DPTR,#0x61ae
   \   000026   F0           MOVX    @DPTR,A
    151          
    152            /* Adjust target value for AGC control loop; details available in datasheet. */
    153            AGCCTRL1 = 0x15;
   \   000027   7415         MOV     A,#0x15
   \   000029   9061B2       MOV     DPTR,#0x61b2
   \   00002C   F0           MOVX    @DPTR,A
    154          
    155            /* Disable source address matching an autopend for now */
    156            SRCMATCH = 0;
   \   00002D   E4           CLR     A
   \   00002E   906182       MOV     DPTR,#0x6182
   \   000031   F0           MOVX    @DPTR,A
    157          
    158            /* Tune ADC performance, details available in datasheet. */
    159            ADCTEST0 = 0x10;
   \   000032   7410         MOV     A,#0x10
   \   000034   9061B5       MOV     DPTR,#0x61b5
   \   000037   F0           MOVX    @DPTR,A
    160            ADCTEST1 = 0x0E;
   \   000038   740E         MOV     A,#0xe
   \   00003A   9061B6       MOV     DPTR,#0x61b6
   \   00003D   F0           MOVX    @DPTR,A
    161            ADCTEST2 = 0x03;
   \   00003E   7403         MOV     A,#0x3
   \   000040   9061B7       MOV     DPTR,#0x61b7
   \   000043   F0           MOVX    @DPTR,A
    162          
    163            /* Sets TX anti-aliasing filter to appropriate bandwidth.
    164             * Reduces spurious emissions close to signal.
    165             */
    166            TXFILTCFG = TXFILTCFG_RESET_VALUE;
   \   000044   7409         MOV     A,#0x9
   \   000046   9061FA       MOV     DPTR,#0x61fa
   \   000049   F0           MOVX    @DPTR,A
    167          
    168            /* disable the CSPT register compare function */
    169            CSPT = 0xFF;
   \   00004A   74FF         MOV     A,#-0x1
   \   00004C   9061E5       MOV     DPTR,#0x61e5
   \   00004F   F0           MOVX    @DPTR,A
    170          
    171            /* enable general RF interrupts */
    172            IEN2 |= RFIE;
   \   000050   439A01       ORL     0x9a,#0x1
    173          
    174            /* enable general REERR interrupts */
    175            IEN0 |= RFERRIE;
   \   000053   D2A8         SETB    0xa8.0
    176          
    177            /* set RF interrupts one notch above lowest priority (four levels available) */
    178            IP0 |=  IP_RFERR_RF_DMA_BV;
   \   000055   43A901       ORL     0xa9,#0x1
    179            IP1 &= ~IP_RFERR_RF_DMA_BV;
   \   000058   53B9FE       ANL     0xb9,#0xfe
    180          
    181            /* read chip version */
    182            macChipVersion = CHVER;
   \   00005B   906249       MOV     DPTR,#0x6249
   \   00005E   E0           MOVX    A,@DPTR
   \   00005F   90....       MOV     DPTR,#macChipVersion
   \   000062   F0           MOVX    @DPTR,A
    183          
    184            /*-------------------------------------------------------------------------------
    185             *  Initialize MAC timer.
    186             */
    187          
    188            /* set timer rollover */
    189            HAL_ENTER_CRITICAL_SECTION(s);
   \   000063   A2AF         MOV     C,0xa8.7
   \   000065   E4           CLR     A
   \   000066   92E0         MOV     0xE0 /* A   */.0,C
   \   000068   C2AF         CLR     0xa8.7
    190            MAC_MCU_T2_ACCESS_PERIOD_VALUE();
   \   00006A   75C302       MOV     0xc3,#0x2
    191            T2M0 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() & 0xFF;
   \   00006D   75A200       MOV     0xa2,#0x0
    192            T2M1 = MAC_RADIO_TIMER_TICKS_PER_BACKOFF() >> 8;
   \   000070   75A328       MOV     0xa3,#0x28
    193            HAL_EXIT_CRITICAL_SECTION(s);
   \   000073   A2E0         MOV     C,0xE0 /* A   */.0
   \   000075   92AF         MOV     0xa8.7,C
    194          
    195            /* start timer */
    196            MAC_RADIO_TIMER_WAKE_UP();
   \   000077   439401       ORL     0x94,#0x1
   \                     ??macMcuInit_0:
   \   00007A   E594         MOV     A,0x94
   \   00007C   A2E2         MOV     C,0xE0 /* A   */.2
   \   00007E   50FA         JNC     ??macMcuInit_0
    197          
    198            /* Enable latch mode */
    199            T2CTRL |= LATCH_MODE;
   \   000080   439408       ORL     0x94,#0x8
    200          
    201            /* enable timer interrupts */
    202            T2IE = 1;
   \   000083   D2BA         SETB    0xb8.2
    203          
    204           /*----------------------------------------------------------------------------------------------
    205            *  Initialize random seed value.
    206            */
    207          
    208            /*
    209             *  Set radio for infinite reception.  Once radio reaches this state,
    210             *  it will stay in receive mode regardless RF activity.
    211             */
    212            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_INFINITE_RECEPTION;
   \   000085   7448         MOV     A,#0x48
   \   000087   906189       MOV     DPTR,#0x6189
   \   00008A   F0           MOVX    @DPTR,A
    213          
    214            /* turn on the receiver */
    215            macRxOn();
   \   00008B                ; Setup parameters for call to function macRxOn
   \   00008B   12....       LCALL   ??macRxOn?relay
    216          
    217            /*
    218             *  Wait for radio to reach infinite reception state by checking RSSI valid flag.
    219             *  Once it does, the least significant bit of ADTSTH should be pretty random.
    220             */
    221            while (!(RSSISTAT & 0x01));
   \                     ??macMcuInit_1:
   \   00008E   906199       MOV     DPTR,#0x6199
   \   000091   E0           MOVX    A,@DPTR
   \   000092   A2E0         MOV     C,0xE0 /* A   */.0
   \   000094   50F8         JNC     ??macMcuInit_1
    222          
    223            /* put 16 random bits into the seed value */
    224            {
    225              uint16 rndSeed;
    226              uint8  i;
    227          
    228              rndSeed = 0;
   \   000096   7800         MOV     R0,#0x0
   \   000098   7900         MOV     R1,#0x0
    229          
    230              for(i=0; i<16; i++)
   \   00009A   7C10         MOV     R4,#0x10
    231              {
    232                /* use most random bit of analog to digital receive conversion to populate the random seed */
    233                rndSeed = (rndSeed << 1) | (RFRND & 0x01);
   \                     ??macMcuInit_2:
   \   00009C   E8           MOV     A,R0
   \   00009D   C3           CLR     C
   \   00009E   33           RLC     A
   \   00009F   F8           MOV     R0,A
   \   0000A0   E9           MOV     A,R1
   \   0000A1   33           RLC     A
   \   0000A2   F9           MOV     R1,A
   \   0000A3   9061A7       MOV     DPTR,#0x61a7
   \   0000A6   E0           MOVX    A,@DPTR
   \   0000A7   A2E0         MOV     C,0xE0 /* A   */.0
   \   0000A9   E4           CLR     A
   \   0000AA   92E0         MOV     0xE0 /* A   */.0,C
   \   0000AC   48           ORL     A,R0
   \   0000AD   F8           MOV     R0,A
    234              }
   \   0000AE   1C           DEC     R4
   \   0000AF   EC           MOV     A,R4
   \   0000B0   70EA         JNZ     ??macMcuInit_2
    235          
    236              /*
    237               *  The seed value must not be zero or 0x0380 (0x8003 in the polynomial).  If it is, the psuedo
    238               *  random sequence won’t be random.  There is an extremely small chance this seed could randomly
    239               *  be zero or 0x0380.  The following check makes sure this does not happen.
    240               */
    241              if (rndSeed == 0x0000 || rndSeed == 0x0380)
   \   0000B2   E8           MOV     A,R0
   \   0000B3   7001         JNZ     ??macMcuInit_3
   \   0000B5   E9           MOV     A,R1
   \                     ??macMcuInit_3:
   \   0000B6   600A         JZ      ??macMcuInit_4
   \   0000B8   7480         MOV     A,#-0x80
   \   0000BA   68           XRL     A,R0
   \   0000BB   7003         JNZ     ??macMcuInit_5
   \   0000BD   7403         MOV     A,#0x3
   \   0000BF   69           XRL     A,R1
   \                     ??macMcuInit_5:
   \   0000C0   7004         JNZ     ??macMcuInit_6
    242              {
    243                rndSeed = 0xBABE; /* completely arbitrary "random" value */
   \                     ??macMcuInit_4:
   \   0000C2   78BE         MOV     R0,#-0x42
   \   0000C4   79BA         MOV     R1,#-0x46
    244              }
    245          
    246              /*
    247               *  Two writes to RNDL will set the random seed.  A write to RNDL copies current contents
    248               *  of RNDL to RNDH before writing new the value to RNDL.
    249               */
    250              RNDL = rndSeed & 0xFF;
   \                     ??macMcuInit_6:
   \   0000C6   E8           MOV     A,R0
   \   0000C7   F5BC         MOV     0xbc,A
    251              RNDL = rndSeed >> 8;
   \   0000C9   E9           MOV     A,R1
   \   0000CA   F5BC         MOV     0xbc,A
    252            }
    253          
    254            /* turn off the receiver */
    255            macRxOff();
   \   0000CC                ; Setup parameters for call to function macRxOff
   \   0000CC   12....       LCALL   ??macRxOff?relay
    256          
    257            /* take receiver out of infinite reception mode; set back to normal operation */
    258            FRMCTRL0 = FRMCTRL0_RESET_VALUE | RX_MODE_NORMAL_OPERATION;
   \   0000CF   7440         MOV     A,#0x40
   \   0000D1   906189       MOV     DPTR,#0x6189
   \   0000D4   F0           MOVX    @DPTR,A
    259          
    260            /* Turn on autoack */
    261            MAC_RADIO_TURN_ON_AUTO_ACK();
   \   0000D5   E0           MOVX    A,@DPTR
   \   0000D6   D2E5         SETB    0xE0 /* A   */.5
   \   0000D8   F0           MOVX    @DPTR,A
    262          
    263            /* Initialize SRCEXTPENDEN and SRCSHORTPENDEN to zeros */
    264            MAC_RADIO_SRC_MATCH_INIT_EXTPENDEN();
   \   0000D9   E4           CLR     A
   \   0000DA   906164       MOV     DPTR,#0x6164
   \   0000DD   F0           MOVX    @DPTR,A
   \   0000DE   906165       MOV     DPTR,#0x6165
   \   0000E1   F0           MOVX    @DPTR,A
   \   0000E2   906166       MOV     DPTR,#0x6166
   \   0000E5   F0           MOVX    @DPTR,A
    265            MAC_RADIO_SRC_MATCH_INIT_SHORTPENDEN();
   \   0000E6   906167       MOV     DPTR,#0x6167
   \   0000E9   F0           MOVX    @DPTR,A
   \   0000EA   906168       MOV     DPTR,#0x6168
   \   0000ED   F0           MOVX    @DPTR,A
   \   0000EE   906169       MOV     DPTR,#0x6169
   \   0000F1   F0           MOVX    @DPTR,A
    266          }
   \   0000F2                REQUIRE ?Subroutine6
   \   0000F2                REQUIRE T2CTRL
   \   0000F2                REQUIRE IEN2
   \   0000F2                REQUIRE T2M0
   \   0000F2                REQUIRE T2M1
   \   0000F2                REQUIRE _A_IEN0
   \   0000F2                REQUIRE IP0
   \   0000F2                REQUIRE _A_IEN1
   \   0000F2                REQUIRE IP1
   \   0000F2                REQUIRE RNDL
   \   0000F2                REQUIRE T2MSEL
   \   0000F2                ; // Fall through to label ?Subroutine6

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine6:
   \   000000   D083         POP     DPH
   \   000002   D082         POP     DPL
   \   000004   02....       LJMP    ?BRET
    267          
    268          
    269          /**************************************************************************************************
    270           * @fn          macMcuRandomByte
    271           *
    272           * @brief       Returns a random byte using a special hardware feature that generates new
    273           *              random values based on the truly random seed set earlier.
    274           *
    275           * @param       none
    276           *
    277           * @return      a random byte
    278           **************************************************************************************************
    279           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    280          uint8 macMcuRandomByte(void)
   \                     macMcuRandomByte:
    281          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    282            /* clock the random generator to get a new random value */
    283            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   74F3         MOV     A,#-0xd
   \   000002   55B4         ANL     A,0xb4
   \   000004   4404         ORL     A,#0x4
   \   000006   F5B4         MOV     0xb4,A
    284          
    285            /* return new randomized value from hardware */
    286            return(RNDH);
   \   000008   A9BD         MOV     R1,0xbd
   \   00000A   02....       LJMP    ?BRET
   \   00000D                REQUIRE ADCCON1
   \   00000D                REQUIRE RNDH
    287          }
    288          
    289          
    290          /**************************************************************************************************
    291           * @fn          macMcuRandomWord
    292           *
    293           * @brief       Returns a random word using a special hardware feature that generates new
    294           *              random values based on the truly random seed set earlier.
    295           *
    296           * @param       none
    297           *
    298           * @return      a random word
    299           **************************************************************************************************
    300           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    301          uint16 macMcuRandomWord(void)
   \                     macMcuRandomWord:
    302          {
   \   000000                ; Saved register size: 2
   \   000000                ; Auto size: 0
    303            uint16 random_word;
    304          
    305            /* clock the random generator to get a new random value */
    306            ADCCON1 = (ADCCON1 & ~RCTRL_BITS) | RCTRL_CLOCK_LFSR;
   \   000000   74F3         MOV     A,#-0xd
   \   000002   55B4         ANL     A,0xb4
   \   000004   4404         ORL     A,#0x4
   \   000006   F5B4         MOV     0xb4,A
    307          
    308            /* read random word */
    309            random_word  = (RNDH << 8);
   \   000008   E5BD         MOV     A,0xbd
   \   00000A   FB           MOV     R3,A
    310            random_word +=  RNDL;
   \   00000B   E5BC         MOV     A,0xbc
   \   00000D   FA           MOV     R2,A
    311          
    312            /* return new randomized value from hardware */
    313            return(random_word);
   \   00000E   02....       LJMP    ?BRET
   \   000011                REQUIRE ADCCON1
   \   000011                REQUIRE RNDL
   \   000011                REQUIRE RNDH
    314          }
    315          
    316          
    317          /**************************************************************************************************
    318           * @fn          macMcuTimerForceDelay
    319           *
    320           * @brief       Delay the timer by the requested number of ticks.
    321           *
    322           * @param       none
    323           *
    324           * @return      none
    325           **************************************************************************************************
    326           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    327          void macMcuTimerForceDelay(uint16 x)
   \                     macMcuTimerForceDelay:
    328          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    329            halIntState_t  s;
    330          
    331            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A2AF         MOV     C,0xa8.7
   \   000002   E4           CLR     A
   \   000003   92E0         MOV     0xE0 /* A   */.0,C
   \   000005   FC           MOV     R4,A
   \   000006   C2AF         CLR     0xa8.7
    332            MAC_MCU_T2_ACCESS_COUNT_VALUE();
   \   000008   75C300       MOV     0xc3,#0x0
    333            T2M0 = (x) & 0xFF;
   \   00000B   EA           MOV     A,R2
   \   00000C   F5A2         MOV     0xa2,A
    334            T2M1 = (x) >> 8;
   \   00000E   EB           MOV     A,R3
   \   00000F   F5A3         MOV     0xa3,A
    335            HAL_EXIT_CRITICAL_SECTION(s);
   \   000011                REQUIRE ?Subroutine5
   \   000011                REQUIRE T2M0
   \   000011                REQUIRE T2M1
   \   000011                REQUIRE _A_IEN0
   \   000011                REQUIRE T2MSEL
   \   000011                ; // Fall through to label ?Subroutine5
    336          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine5:
   \   000000   EC           MOV     A,R4
   \   000001   A2E0         MOV     C,0xE0 /* A   */.0
   \   000003   92AF         MOV     0xa8.7,C
   \   000005   02....       LJMP    ?BRET
    337          
    338          /**************************************************************************************************
    339           * @fn          macMcuTimerCapture
    340           *
    341           * @brief       Returns the last timer capture.  This capture should have occurred at the
    342           *              receive time of the last frame (the last time SFD transitioned to active).
    343           *
    344           * @param       none
    345           *
    346           * @return      last capture of hardware timer (full 16-bit value)
    347           **************************************************************************************************
    348           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    349          uint16 macMcuTimerCapture(void)
   \                     macMcuTimerCapture:
    350          {
   \   000000                ; Saved register size: 2
   \   000000                ; Auto size: 0
    351            uint16         timerCapture;
    352            halIntState_t  s;
    353          
    354            HAL_ENTER_CRITICAL_SECTION(s);
   \   000000   A2AF         MOV     C,0xa8.7
   \   000002   E4           CLR     A
   \   000003   92E0         MOV     0xE0 /* A   */.0,C
   \   000005   FC           MOV     R4,A
   \   000006   C2AF         CLR     0xa8.7
    355            MAC_MCU_T2_ACCESS_CAPTURE_VALUE();
   \   000008   75C301       MOV     0xc3,#0x1
    356            timerCapture = T2M1 << 8;
   \   00000B   E5A3         MOV     A,0xa3
   \   00000D   FB           MOV     R3,A
    357            timerCapture |= T2M0;
   \   00000E   E5A2         MOV     A,0xa2
   \   000010   FA           MOV     R2,A
    358            HAL_EXIT_CRITICAL_SECTION(s);
   \   000011   80..         SJMP    ?Subroutine5
   \   000013                REQUIRE T2M0
   \   000013                REQUIRE T2M1
   \   000013                REQUIRE _A_IEN0
   \   000013                REQUIRE T2MSEL
    359          
    360            return (timerCapture);
    361          }
    362          
    363          
    364          /**************************************************************************************************
    365           * @fn          macMcuOverflowCount
    366           *
    367           * @brief       Returns the value of the overflow counter which is a special hardware feature.
    368           *              The overflow count actually is 24 bits of information.
    369           *
    370           * @param       none
    371           *
    372           * @return      value of overflow counter
    373           **************************************************************************************************
    374           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    375          uint32 macMcuOverflowCount(void)
   \                     macMcuOverflowCount:
    376          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    377            uint32         overflowCount;
    378            halIntState_t  s;
    379          
    380            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    381          
    382            HAL_ENTER_CRITICAL_SECTION(s);
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   92E0         MOV     0xE0 /* A   */.0,C
   \   00000F   FA           MOV     R2,A
   \   000010   C2AF         CLR     0xa8.7
    383          
    384            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    385            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000012   75C300       MOV     0xc3,#0x0
    386          
    387            /* Latch the entire T2MOVFx first by reading T2M0. */
    388            T2M0;
   \   000015   E5A2         MOV     A,0xa2
    389            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   000017   02....       LJMP    ?Subroutine7 & 0xFFFF
   \   00001A                REQUIRE T2M0
   \   00001A                REQUIRE T2MOVF0
   \   00001A                REQUIRE T2MOVF1
   \   00001A                REQUIRE T2MOVF2
   \   00001A                REQUIRE _A_IEN0
   \   00001A                REQUIRE T2MSEL
    390            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
    391            ((uint8 *)&overflowCount)[UINT32_NDX2] = T2MOVF2;
    392            ((uint8 *)&overflowCount)[UINT32_NDX3] = 0;
    393            HAL_EXIT_CRITICAL_SECTION(s);
    394          
    395            return (overflowCount);
    396          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E4           CLR     A
   \   000001   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_7:
   \   000004   78..         MOV     R0,#?V0 + 0
   \   000006   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine7:
   \   000000   E5A4         MOV     A,0xa4
   \   000002   85..82       MOV     DPL,?XSP + 0
   \   000005   85..83       MOV     DPH,?XSP + 1
   \   000008   F0           MOVX    @DPTR,A
   \   000009   E5A5         MOV     A,0xa5
   \   00000B   C0E0         PUSH    A
   \   00000D   7401         MOV     A,#0x1
   \   00000F   12....       LCALL   ?XSTACK_DISP0_8
   \   000012   D0E0         POP     A
   \   000014   F0           MOVX    @DPTR,A
   \   000015   E5A6         MOV     A,0xa6
   \   000017   C0E0         PUSH    A
   \   000019   7402         MOV     A,#0x2
   \   00001B   12....       LCALL   ?XSTACK_DISP0_8
   \   00001E   D0E0         POP     A
   \   000020   F0           MOVX    @DPTR,A
   \   000021   7403         MOV     A,#0x3
   \   000023   12....       LCALL   ?XSTACK_DISP0_8
   \   000026   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_6:
   \   000029   12....       LCALL   ?L_MOV_X
   \   00002C   AA..         MOV     R2,?V0 + 0
   \   00002E   AB..         MOV     R3,?V0 + 1
   \   000030   AC..         MOV     R4,?V0 + 2
   \   000032   AD..         MOV     R5,?V0 + 3
   \   000034                REQUIRE ??Subroutine10_0
   \   000034                ; // Fall through to label ??Subroutine10_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine10_0:
   \   000000   7404         MOV     A,#0x4
   \   000002                REQUIRE ??Subroutine11_0
   \   000002                ; // Fall through to label ??Subroutine11_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine11_0:
   \   000000   12....       LCALL   ?DEALLOC_XSTACK8
   \   000003   7F04         MOV     R7,#0x4
   \   000005   02....       LJMP    ?BANKED_LEAVE_XDATA

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine4:
   \   000000   F0           MOVX    @DPTR,A
   \   000001   EA           MOV     A,R2
   \   000002   A2E0         MOV     C,0xE0 /* A   */.0
   \   000004   92AF         MOV     0xa8.7,C
   \   000006   85..82       MOV     DPL,?XSP + 0
   \   000009   85..83       MOV     DPH,?XSP + 1
   \   00000C   22           RET
    397          
    398          
    399          /**************************************************************************************************
    400           * @fn          macMcuOverflowCapture
    401           *
    402           * @brief       Returns the last capture of the overflow counter.  A special hardware feature
    403           *              captures the overflow counter when the regular hardware timer is captured.
    404           *
    405           * @param       none
    406           *
    407           * @return      last capture of overflow count
    408           **************************************************************************************************
    409           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    410          uint32 macMcuOverflowCapture(void)
   \                     macMcuOverflowCapture:
    411          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    412            uint32         overflowCapture;
    413            halIntState_t  s;
    414          
    415            /* for efficiency, the 32-bit value is encoded using endian abstracted indexing */
    416            HAL_ENTER_CRITICAL_SECTION(s);
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   92E0         MOV     0xE0 /* A   */.0,C
   \   00000F   FA           MOV     R2,A
   \   000010   C2AF         CLR     0xa8.7
    417            MAC_MCU_T2_ACCESS_OVF_CAPTURE_VALUE();
   \   000012   75C310       MOV     0xc3,#0x10
    418            ((uint8 *)&overflowCapture)[UINT32_NDX0] = T2MOVF0;
   \   000015   02....       LJMP    ?Subroutine7 & 0xFFFF
   \   000018                REQUIRE T2MOVF0
   \   000018                REQUIRE T2MOVF1
   \   000018                REQUIRE T2MOVF2
   \   000018                REQUIRE _A_IEN0
   \   000018                REQUIRE T2MSEL
    419            ((uint8 *)&overflowCapture)[UINT32_NDX1] = T2MOVF1;
    420            ((uint8 *)&overflowCapture)[UINT32_NDX2] = T2MOVF2;
    421            ((uint8 *)&overflowCapture)[UINT32_NDX3] = 0;
    422            HAL_EXIT_CRITICAL_SECTION(s);
    423          
    424            return (overflowCapture);
    425          }
    426          
    427          
    428          /**************************************************************************************************
    429           * @fn          macMcuOverflowSetCount
    430           *
    431           * @brief       Sets the value of the hardware overflow counter.
    432           *
    433           * @param       count - new overflow count value
    434           *
    435           * @return      none
    436           **************************************************************************************************
    437           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    438          void macMcuOverflowSetCount(uint32 count)
   \                     macMcuOverflowSetCount:
    439          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine3 & 0xFFFF
    440            halIntState_t  s;
    441          
    442            MAC_ASSERT(! (count >> 24) );   /* illegal count value */
   \                     ??CrossCallReturnLabel_4:
   \   00000D   85..82       MOV     DPL,?XSP + 0
   \   000010   85..83       MOV     DPH,?XSP + 1
   \   000013   C082         PUSH    DPL
   \   000015   C083         PUSH    DPH
   \   000017   90....       MOV     DPTR,#__Constant_ff000000
   \   00001A   78..         MOV     R0,#?V0 + 0
   \   00001C   12....       LCALL   ?L_MOV_X
   \   00001F   D083         POP     DPH
   \   000021   D082         POP     DPL
   \   000023   78..         MOV     R0,#?V0 + 0
   \   000025   12....       LCALL   ?L_AND_X
   \   000028   90....       MOV     DPTR,#__Constant_0
   \   00002B   78..         MOV     R0,#?V0 + 0
   \   00002D   12....       LCALL   ?L_EQ_X
   \   000030   6003         JZ      ??macMcuOverflowSetCount_0
   \   000032                ; Setup parameters for call to function halAssertHandler
   \   000032   12....       LCALL   ??halAssertHandler?relay
    443          
    444            /* save the current overflow count */
    445            accumulatedOverflowCount += macMcuOverflowCount();
   \                     ??macMcuOverflowSetCount_0:
   \   000035                ; Setup parameters for call to function macMcuOverflowCount
   \   000035   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000038   90....       MOV     DPTR,#accumulatedOverflowCount
   \   00003B   78..         MOV     R0,#?V0 + 0
   \   00003D   12....       LCALL   ?L_ADD_TO_X
    446          
    447            /* deduct the initial count */
    448            accumulatedOverflowCount -= count;
   \   000040   85..82       MOV     DPL,?XSP + 0
   \   000043   85..83       MOV     DPH,?XSP + 1
   \   000046   78..         MOV     R0,#?V0 + 0
   \   000048   12....       LCALL   ?L_MOV_X
   \   00004B   90....       MOV     DPTR,#accumulatedOverflowCount
   \   00004E   78..         MOV     R0,#?V0 + 0
   \   000050   12....       LCALL   ?L_SUB_FROM_X
    449          
    450            HAL_ENTER_CRITICAL_SECTION(s);
   \   000053   A2AF         MOV     C,0xa8.7
   \   000055   E4           CLR     A
   \   000056   92E0         MOV     0xE0 /* A   */.0,C
   \   000058   FA           MOV     R2,A
   \   000059   C2AF         CLR     0xa8.7
    451            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   00005B   75C300       MOV     0xc3,#0x0
    452          
    453            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    454            /* T2OF2 must be written last */
    455            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   00005E   85..82       MOV     DPL,?XSP + 0
   \   000061   85..83       MOV     DPH,?XSP + 1
   \   000064   E0           MOVX    A,@DPTR
   \   000065   F5A4         MOV     0xa4,A
    456            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   000067   7401         MOV     A,#0x1
   \   000069   12....       LCALL   ?XSTACK_DISP0_8
   \   00006C   E0           MOVX    A,@DPTR
   \   00006D   F5A5         MOV     0xa5,A
    457            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   00006F   7402         MOV     A,#0x2
   \   000071   12....       LCALL   ?XSTACK_DISP0_8
   \   000074   E0           MOVX    A,@DPTR
   \   000075   F5A6         MOV     0xa6,A
    458            HAL_EXIT_CRITICAL_SECTION(s);
   \   000077                REQUIRE ?Subroutine9
   \   000077                REQUIRE T2MOVF0
   \   000077                REQUIRE T2MOVF1
   \   000077                REQUIRE T2MOVF2
   \   000077                REQUIRE _A_IEN0
   \   000077                REQUIRE T2MSEL
   \   000077                ; // Fall through to label ?Subroutine9
    459          }

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine9:
   \   000000   EA           MOV     A,R2
   \   000001   A2E0         MOV     C,0xE0 /* A   */.0
   \   000003   92AF         MOV     0xa8.7,C
   \   000005   02....       LJMP    ??Subroutine10_0 & 0xFFFF

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine3:
   \   000000   85..82       MOV     DPL,?XSP + 0
   \   000003   85..83       MOV     DPH,?XSP + 1
   \   000006   EA           MOV     A,R2
   \   000007   F0           MOVX    @DPTR,A
   \   000008   A3           INC     DPTR
   \   000009   EB           MOV     A,R3
   \   00000A   F0           MOVX    @DPTR,A
   \   00000B   A3           INC     DPTR
   \   00000C   EC           MOV     A,R4
   \   00000D   F0           MOVX    @DPTR,A
   \   00000E   A3           INC     DPTR
   \   00000F   ED           MOV     A,R5
   \   000010   F0           MOVX    @DPTR,A
   \   000011   22           RET

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine2:
   \   000000   12....       LCALL   ??macMcuOverflowCount?relay
   \   000003   8A..         MOV     ?V0 + 0,R2
   \   000005   8B..         MOV     ?V0 + 1,R3
   \   000007   8C..         MOV     ?V0 + 2,R4
   \   000009   8D..         MOV     ?V0 + 3,R5
   \   00000B   22           RET
    460          
    461          
    462          /**************************************************************************************************
    463           * @fn          macMcuOverflowSetCompare
    464           *
    465           * @brief       Set overflow count compare value.  An interrupt is triggered when the overflow
    466           *              count equals this compare value.
    467           *
    468           * @param       count - overflow count compare value
    469           *
    470           * @return      none
    471           **************************************************************************************************
    472           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    473          void macMcuOverflowSetCompare(uint32 count)
   \                     macMcuOverflowSetCompare:
    474          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   12....       LCALL   ?Subroutine3 & 0xFFFF
    475            halIntState_t  s;
    476            uint8 enableCompareInt = 0;
   \                     ??CrossCallReturnLabel_5:
   \   00000D   7E00         MOV     R6,#0x0
    477          
    478            MAC_ASSERT( !(count >> 24) );   /* illegal count value */
   \   00000F   85..82       MOV     DPL,?XSP + 0
   \   000012   85..83       MOV     DPH,?XSP + 1
   \   000015   C082         PUSH    DPL
   \   000017   C083         PUSH    DPH
   \   000019   90....       MOV     DPTR,#__Constant_ff000000
   \   00001C   78..         MOV     R0,#?V0 + 0
   \   00001E   12....       LCALL   ?L_MOV_X
   \   000021   D083         POP     DPH
   \   000023   D082         POP     DPL
   \   000025   78..         MOV     R0,#?V0 + 0
   \   000027   12....       LCALL   ?L_AND_X
   \   00002A   90....       MOV     DPTR,#__Constant_0
   \   00002D   78..         MOV     R0,#?V0 + 0
   \   00002F   12....       LCALL   ?L_EQ_X
   \   000032   6003         JZ      ??macMcuOverflowSetCompare_0
   \   000034                ; Setup parameters for call to function halAssertHandler
   \   000034   12....       LCALL   ??halAssertHandler?relay
    479          
    480            HAL_ENTER_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_0:
   \   000037   A2AF         MOV     C,0xa8.7
   \   000039   E4           CLR     A
   \   00003A   92E0         MOV     0xE0 /* A   */.0,C
   \   00003C   FA           MOV     R2,A
   \   00003D   C2AF         CLR     0xa8.7
    481          
    482            /*  Disable overflow compare interrupts. */
    483            if (T2IRQM & TIMER2_OVF_COMPARE1M)
   \   00003F   E5A7         MOV     A,0xa7
   \   000041   A2E4         MOV     C,0xE0 /* A   */.4
   \   000043   5004         JNC     ??macMcuOverflowSetCompare_1
    484            {
    485              enableCompareInt = 1;
   \   000045   0E           INC     R6
    486              T2IRQM &= ~TIMER2_OVF_COMPARE1M;
   \   000046   53A7EF       ANL     0xa7,#0xef
    487            }
    488          
    489            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
   \                     ??macMcuOverflowSetCompare_1:
   \   000049   75C330       MOV     0xc3,#0x30
    490          
    491            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    492            T2MOVF0 = ((uint8 *)&count)[UINT32_NDX0];
   \   00004C   85..82       MOV     DPL,?XSP + 0
   \   00004F   85..83       MOV     DPH,?XSP + 1
   \   000052   E0           MOVX    A,@DPTR
   \   000053   F5A4         MOV     0xa4,A
    493            T2MOVF1 = ((uint8 *)&count)[UINT32_NDX1];
   \   000055   7401         MOV     A,#0x1
   \   000057   12....       LCALL   ?XSTACK_DISP0_8
   \   00005A   E0           MOVX    A,@DPTR
   \   00005B   F5A5         MOV     0xa5,A
    494            T2MOVF2 = ((uint8 *)&count)[UINT32_NDX2];
   \   00005D   7402         MOV     A,#0x2
   \   00005F   12....       LCALL   ?XSTACK_DISP0_8
   \   000062   E0           MOVX    A,@DPTR
   \   000063   F5A6         MOV     0xa6,A
    495          
    496            /*
    497             *  Now that new compare value is stored, clear the interrupt flag.  This is important just
    498             *  in case a false match was generated as the multi-byte compare value was written.
    499             */
    500            T2IRQF &= ~TIMER2_OVF_COMPARE1F;
   \   000065   53A1EF       ANL     0xa1,#0xef
    501          
    502            /* re-enable overflow compare interrupts if they were previously enabled */
    503            if (enableCompareInt)
   \   000068   EE           MOV     A,R6
   \   000069   6003         JZ      ??macMcuOverflowSetCompare_2
    504            {
    505              T2IRQM |= TIMER2_OVF_COMPARE1M;
   \   00006B   43A710       ORL     0xa7,#0x10
    506            }
    507          
    508            HAL_EXIT_CRITICAL_SECTION(s);
   \                     ??macMcuOverflowSetCompare_2:
   \   00006E   80..         SJMP    ?Subroutine9
   \   000070                REQUIRE T2IRQF
   \   000070                REQUIRE T2MOVF0
   \   000070                REQUIRE T2MOVF1
   \   000070                REQUIRE T2MOVF2
   \   000070                REQUIRE T2IRQM
   \   000070                REQUIRE _A_IEN0
   \   000070                REQUIRE T2MSEL
    509          }
    510          
    511          
    512          /**************************************************************************************************
    513           * @fn          macMcuOverflowGetCompare
    514           *
    515           * @brief       Get overflow count compare value.
    516           *
    517           * @param       none
    518           *
    519           * @return      overflow count compare value
    520           **************************************************************************************************
    521           */
    522          uint32 macMcuOverflowGetCompare(void)
    523          {
    524            halIntState_t  s;
    525            uint32         compare;
    526          
    527            HAL_ENTER_CRITICAL_SECTION(s);
    528          
    529            MAC_MCU_T2_ACCESS_OVF_CMP1_VALUE();
    530          
    531            /* for efficiency, the 32-bit value is decoded using endian abstracted indexing */
    532            ((uint8 *)&compare)[UINT32_NDX0] = T2MOVF0;
    533            ((uint8 *)&compare)[UINT32_NDX1] = T2MOVF1;
    534            ((uint8 *)&compare)[UINT32_NDX2] = T2MOVF2;
    535            ((uint8 *)&compare)[UINT32_NDX3] = 0;
    536          
    537            HAL_EXIT_CRITICAL_SECTION(s);
    538          
    539            return(compare);
    540          }
    541          
    542          
    543          /**************************************************************************************************
    544           * @fn          macMcuTimer2Isr
    545           *
    546           * @brief       Interrupt service routine for timer2, the MAC timer.
    547           *
    548           * @param       none
    549           *
    550           * @return      none
    551           **************************************************************************************************
    552           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    553          HAL_ISR_FUNCTION( macMcuTimer2Isr, T2_VECTOR )
   \                     macMcuTimer2Isr:
    554          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    555            uint8 t2irqm = T2IRQM;
   \   000007   E5A7         MOV     A,0xa7
   \   000009   FA           MOV     R2,A
    556            uint8 t2irqf = T2IRQF;
   \   00000A   E5A1         MOV     A,0xa1
   \   00000C   FB           MOV     R3,A
    557          
    558            /*------------------------------------------------------------------------------------------------
    559             *  Overflow compare interrupt - triggers when then overflow counter is
    560             *  equal to the overflow compare register.
    561             */
    562            if ((t2irqf & TIMER2_OVF_COMPARE1F) & t2irqm)
   \   00000D   EA           MOV     A,R2
   \   00000E   5B           ANL     A,R3
   \   00000F   5410         ANL     A,#0x10
   \   000011   6008         JZ      ??macMcuTimer2Isr_0
    563            {
    564          
    565              /* call function for dealing with the timer compare interrupt */
    566              macBackoffTimerCompareIsr();
   \   000013                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   000013   12....       LCALL   ??macBackoffTimerCompareIsr?relay
    567          
    568              /* clear overflow compare interrupt flag */
    569              T2IRQF &= ~TIMER2_OVF_COMPARE1F;
   \   000016   53A1EF       ANL     0xa1,#0xef
   \   000019   802A         SJMP    ??macMcuTimer2Isr_1
    570            }
    571          
    572            /*------------------------------------------------------------------------------------------------
    573             *  Overflow interrupt - triggers when the hardware timer rolls over.
    574             */
    575            else if ((t2irqf & TIMER2_PERF) & t2irqm)
   \                     ??macMcuTimer2Isr_0:
   \   00001B   EA           MOV     A,R2
   \   00001C   A2E0         MOV     C,0xE0 /* A   */.0
   \   00001E   C0D0         PUSH    PSW
   \   000020   EB           MOV     A,R3
   \   000021   A2E0         MOV     C,0xE0 /* A   */.0
   \   000023   92F0         MOV     B.0,C
   \   000025   12....       LCALL   ?POP_BIT_ISP
   \   000028   1581         DEC     SP
   \   00002A   82F0         ANL     C,B.0
   \   00002C   5017         JNC     ??macMcuTimer2Isr_1
    576            {
    577              /* call energy detect interrupt function, this interrupt not used for any other functionality */
    578              mcuRecordMaxRssiIsr();
   \   00002E   906198       MOV     DPTR,#0x6198
   \   000031   E0           MOVX    A,@DPTR
   \   000032   FA           MOV     R2,A
   \   000033   90....       MOV     DPTR,#maxRssi
   \   000036   E0           MOVX    A,@DPTR
   \   000037   C3           CLR     C
   \   000038   9A           SUBB    A,R2
   \   000039   A2D2         MOV     C,0xD0 /* PSW */.2
   \   00003B   65D0         XRL     A,PSW
   \   00003D   33           RLC     A
   \   00003E   5002         JNC     ??macMcuTimer2Isr_2
   \   000040   EA           MOV     A,R2
   \   000041   F0           MOVX    @DPTR,A
    579          
    580              /* clear the interrupt flag */
    581              T2IRQF &= ~TIMER2_PERF;
   \                     ??macMcuTimer2Isr_2:
   \   000042   53A1FE       ANL     0xa1,#0xfe
    582            }
    583          }
   \                     ??macMcuTimer2Isr_1:
   \   000045                REQUIRE ?Subroutine8
   \   000045                REQUIRE T2IRQF
   \   000045                REQUIRE T2IRQM
   \   000045                ; // Fall through to label ?Subroutine8

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
   \                     ?Subroutine8:
   \   000000   7F01         MOV     R7,#0x1
   \   000002   02....       LJMP    ?INTERRUPT_LEAVE_XSP
    584          
    585          
    586          /**************************************************************************************************
    587           * @fn          macMcuTimer2OverflowWorkaround
    588           *
    589           * @brief       For CC2530, T2 interrupt won’t be generated when the current count is greater than
    590           *              the comparator. The interrupt is only generated when the current count is equal to
    591           *              the comparator. When the CC2530 is waking up from sleep, there is a small window
    592           *              that the count may be grater than the comparator, therefore, missing the interrupt.
    593           *              This workaround will call the T2 ISR when the current T2 count is greater than the
    594           *              comparator.
    595           *
    596           * @param       none
    597           *
    598           * @return      none
    599           **************************************************************************************************
    600           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    601          void macMcuTimer2OverflowWorkaround(void)
   \                     macMcuTimer2OverflowWorkaround:
    602          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    603            if (T2IRQM & TIMER2_OVF_COMPARE1F)
   \   00000A   E5A7         MOV     A,0xa7
   \   00000C   A2E4         MOV     C,0xE0 /* A   */.4
   \   00000E   5053         JNC     ??macMcuTimer2OverflowWorkaround_0
    604            {
    605              /* T2 comapre 1 interrupt is enabled but T2 compare 1 intererrupt is not generated */
    606              if (!(T2IRQF & TIMER2_OVF_COMPARE1F))
   \   000010   E5A1         MOV     A,0xa1
   \   000012   A2E4         MOV     C,0xE0 /* A   */.4
   \   000014   404D         JC      ??macMcuTimer2OverflowWorkaround_0
    607              {
    608                if (MAC_RADIO_BACKOFF_COUNT() > macMcuOverflowGetCompare())
   \   000016   A2AF         MOV     C,0xa8.7
   \   000018   E4           CLR     A
   \   000019   92E0         MOV     0xE0 /* A   */.0,C
   \   00001B   FA           MOV     R2,A
   \   00001C   C2AF         CLR     0xa8.7
   \   00001E   75C330       MOV     0xc3,#0x30
   \   000021   E5A4         MOV     A,0xa4
   \   000023   85..82       MOV     DPL,?XSP + 0
   \   000026   85..83       MOV     DPH,?XSP + 1
   \   000029   F0           MOVX    @DPTR,A
   \   00002A   E5A5         MOV     A,0xa5
   \   00002C   C0E0         PUSH    A
   \   00002E   7401         MOV     A,#0x1
   \   000030   12....       LCALL   ?XSTACK_DISP0_8
   \   000033   D0E0         POP     A
   \   000035   F0           MOVX    @DPTR,A
   \   000036   E5A6         MOV     A,0xa6
   \   000038   C0E0         PUSH    A
   \   00003A   7402         MOV     A,#0x2
   \   00003C   12....       LCALL   ?XSTACK_DISP0_8
   \   00003F   D0E0         POP     A
   \   000041   F0           MOVX    @DPTR,A
   \   000042   7403         MOV     A,#0x3
   \   000044   12....       LCALL   ?XSTACK_DISP0_8
   \   000047   E4           CLR     A
   \   000048   12....       LCALL   ?Subroutine1 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   00004B   C082         PUSH    DPL
   \   00004D   C083         PUSH    DPH
   \   00004F                ; Setup parameters for call to function macMcuOverflowCount
   \   00004F   12....       LCALL   ?Subroutine2 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   000052   D083         POP     DPH
   \   000054   D082         POP     DPL
   \   000056   78..         MOV     R0,#?V0 + 0
   \   000058   12....       LCALL   ?UL_GT_X
   \   00005B   5006         JNC     ??macMcuTimer2OverflowWorkaround_0
    609                {
    610                  /* Set the flag to trigger the timer compare interrupt */
    611                  macBackoffTimerCompareIsr();
   \   00005D                ; Setup parameters for call to function macBackoffTimerCompareIsr
   \   00005D   12....       LCALL   ??macBackoffTimerCompareIsr?relay
    612                  T2IRQF &= ~TIMER2_OVF_COMPARE1F;
   \   000060   53A1EF       ANL     0xa1,#0xef
    613                }
    614              }
    615            }
    616          }
   \                     ??macMcuTimer2OverflowWorkaround_0:
   \   000063   02....       LJMP    ??Subroutine10_0 & 0xFFFF
   \   000066                REQUIRE T2IRQF
   \   000066                REQUIRE T2IRQM
   \   000066                REQUIRE T2MOVF0
   \   000066                REQUIRE T2MOVF1
   \   000066                REQUIRE T2MOVF2
   \   000066                REQUIRE _A_IEN0
   \   000066                REQUIRE T2MSEL

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine1:
   \   000000   12....       LCALL   ?Subroutine4 & 0xFFFF
   \                     ??CrossCallReturnLabel_8:
   \   000003   22           RET
    617          
    618          
    619          /**************************************************************************************************
    620           * @fn          macMcuPrecisionCount
    621           *
    622           * @brief       This function is used by higher layer to read a free running counter driven by
    623           *              MAC timer.
    624           *
    625           * @param       none
    626           *
    627           * @return      overflowCount
    628           **************************************************************************************************
    629           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    630          uint16 macMcuPrecisionCount(void)
   \                     macMcuPrecisionCount:
    631          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 2
   \   000005   74FE         MOV     A,#-0x2
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
    632            uint16         overflowCount;
    633            halIntState_t  s;
    634          
    635            HAL_ENTER_CRITICAL_SECTION(s);
   \   00000A   A2AF         MOV     C,0xa8.7
   \   00000C   E4           CLR     A
   \   00000D   92E0         MOV     0xE0 /* A   */.0,C
   \   00000F   FA           MOV     R2,A
   \   000010   C2AF         CLR     0xa8.7
    636          
    637            /* This T2 access macro allows accessing both T2MOVFx and T2Mx */
    638            MAC_MCU_T2_ACCESS_OVF_COUNT_VALUE();
   \   000012   75C300       MOV     0xc3,#0x0
    639          
    640            /* Latch the entire T2MOVFx first by reading T2M0.
    641             * T2M0 and T2MOVF2 are discarded.
    642             */
    643            T2M0;
   \   000015   E5A2         MOV     A,0xa2
    644            ((uint8 *)&overflowCount)[UINT32_NDX0] = T2MOVF0;
   \   000017   E5A4         MOV     A,0xa4
   \   000019   85..82       MOV     DPL,?XSP + 0
   \   00001C   85..83       MOV     DPH,?XSP + 1
   \   00001F   F0           MOVX    @DPTR,A
    645            ((uint8 *)&overflowCount)[UINT32_NDX1] = T2MOVF1;
   \   000020   E5A5         MOV     A,0xa5
   \   000022   C0E0         PUSH    A
   \   000024   7401         MOV     A,#0x1
   \   000026   12....       LCALL   ?XSTACK_DISP0_8
   \   000029   D0E0         POP     A
   \   00002B   12....       LCALL   ?Subroutine1 & 0xFFFF
    646            HAL_EXIT_CRITICAL_SECTION(s);
    647          
    648            /* the overflowCount needs to account for the accumulated overflow count in Beacon mode.
    649             * It's okay to let it overflow since only LSBs are used.
    650             */
    651            overflowCount += (uint16)accumulatedOverflowCount;
    652          
    653            return(overflowCount);
   \                     ??CrossCallReturnLabel_1:
   \   00002E   C082         PUSH    DPL
   \   000030   C083         PUSH    DPH
   \   000032   90....       MOV     DPTR,#accumulatedOverflowCount
   \   000035   78..         MOV     R0,#?V0 + 0
   \   000037   12....       LCALL   ?L_MOV_X
   \   00003A   D083         POP     DPH
   \   00003C   D082         POP     DPL
   \   00003E   E0           MOVX    A,@DPTR
   \   00003F   25..         ADD     A,?V0 + 0
   \   000041   FA           MOV     R2,A
   \   000042   A3           INC     DPTR
   \   000043   E0           MOVX    A,@DPTR
   \   000044   35..         ADDC    A,?V0 + 1
   \   000046   FB           MOV     R3,A
   \   000047   7402         MOV     A,#0x2
   \   000049   02....       LJMP    ??Subroutine11_0 & 0xFFFF
   \   00004C                REQUIRE T2M0
   \   00004C                REQUIRE T2MOVF0
   \   00004C                REQUIRE T2MOVF1
   \   00004C                REQUIRE _A_IEN0
   \   00004C                REQUIRE T2MSEL
    654          }
    655          
    656          
    657          /**************************************************************************************************
    658           * @fn          macMcuRfIsr
    659           *
    660           * @brief       Interrupt service routine that handles all RF interrupts.  There are a number
    661           *              of conditions "ganged" onto this one ISR so each condition must be tested for.
    662           *
    663           * @param       none
    664           *
    665           * @return      none
    666           **************************************************************************************************
    667           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    668          HAL_ISR_FUNCTION( macMcuRfIsr, RF_VECTOR )
   \                     macMcuRfIsr:
    669          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    670            uint8 rfim;
    671          
    672            rfim = RFIRQM1;
   \   000007   9061A4       MOV     DPTR,#0x61a4
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FA           MOV     R2,A
    673          
    674            /*  The CPU level RF interrupt flag must be cleared here (before clearing RFIRQFx).
    675             *  to allow the interrupts to be nested.
    676             */
    677            S1CON = 0x00;
   \   00000C   759B00       MOV     0x9b,#0x0
    678          
    679            if ((RFIRQF1 & IRQ_CSP_MANINT) & rfim)
   \   00000F   E591         MOV     A,0x91
   \   000011   5A           ANL     A,R2
   \   000012   5408         ANL     A,#0x8
   \   000014   6008         JZ      ??macMcuRfIsr_0
    680            {
    681              /*
    682               *  Important!  Because of how the CSP programs are written, CSP_INT interrupts should
    683               *  be processed before CSP_STOP interrupts.  This becomes an issue when there are
    684               *  long critical sections.
    685               */
    686              /* clear flag */
    687              RFIRQF1 = ~IRQ_CSP_MANINT;
   \   000016   7591F7       MOV     0x91,#-0x9
    688              macCspTxIntIsr();
   \   000019                ; Setup parameters for call to function macCspTxIntIsr
   \   000019   12....       LCALL   ??macCspTxIntIsr?relay
   \   00001C   802A         SJMP    ??macMcuRfIsr_1
    689            }
    690            else if ((RFIRQF1 & IRQ_CSP_STOP) & rfim)
   \                     ??macMcuRfIsr_0:
   \   00001E   E591         MOV     A,0x91
   \   000020   5A           ANL     A,R2
   \   000021   5410         ANL     A,#0x10
   \   000023   6008         JZ      ??macMcuRfIsr_2
    691            {
    692              /* clear flag */
    693              RFIRQF1 = ~IRQ_CSP_STOP;
   \   000025   7591EF       MOV     0x91,#-0x11
    694              macCspTxStopIsr();
   \   000028                ; Setup parameters for call to function macCspTxStopIsr
   \   000028   12....       LCALL   ??macCspTxStopIsr?relay
   \   00002B   801B         SJMP    ??macMcuRfIsr_1
    695            }
    696            else if ((RFIRQF1 & IRQ_TXACKDONE) & rfim)
   \                     ??macMcuRfIsr_2:
   \   00002D   EA           MOV     A,R2
   \   00002E   A2E0         MOV     C,0xE0 /* A   */.0
   \   000030   C0D0         PUSH    PSW
   \   000032   E591         MOV     A,0x91
   \   000034   A2E0         MOV     C,0xE0 /* A   */.0
   \   000036   92F0         MOV     B.0,C
   \   000038   12....       LCALL   ?POP_BIT_ISP
   \   00003B   1581         DEC     SP
   \   00003D   82F0         ANL     C,B.0
   \   00003F   5007         JNC     ??macMcuRfIsr_1
    697            {
    698              /* disable interrupt - set up is for "one shot" operation */
    699              RFIRQM1 &= ~IM_TXACKDONE;
   \   000041   E0           MOVX    A,@DPTR
   \   000042   C2E0         CLR     0xE0 /* A   */.0
   \   000044   F0           MOVX    @DPTR,A
    700              macRxAckTxDoneCallback();
   \   000045                ; Setup parameters for call to function macRxAckTxDoneCallback
   \   000045   12....       LCALL   ??macRxAckTxDoneCallback?relay
    701            }
    702          
    703            rfim = RFIRQM0;
   \                     ??macMcuRfIsr_1:
   \   000048   9061A3       MOV     DPTR,#0x61a3
   \   00004B   E0           MOVX    A,@DPTR
   \   00004C   FA           MOV     R2,A
    704          
    705            /* process RFIRQF0 next */
    706            if ((RFIRQF0 & IRQ_FIFOP) & rfim)
   \   00004D   E5E9         MOV     A,0xe9
   \   00004F   5A           ANL     A,R2
   \   000050   5404         ANL     A,#0x4
   \   000052   600E         JZ      ??macMcuRfIsr_3
    707            {
    708              /* continue to execute interrup                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        t handler as long as FIFOP is active */
    709              do
    710              {
    711                macRxThresholdIsr();
   \                     ??macMcuRfIsr_4:
   \   000054                ; Setup parameters for call to function macRxThresholdIsr
   \   000054   12....       LCALL   ??macRxThresholdIsr?relay
    712                RFIRQF0 = ~IRQ_FIFOP;
   \   000057   75E9FB       MOV     0xe9,#-0x5
    713              } while (FSMSTAT1 & FIFOP);
   \   00005A   906193       MOV     DPTR,#0x6193
   \   00005D   E0           MOVX    A,@DPTR
   \   00005E   A2E6         MOV     C,0xE0 /* A   */.6
   \   000060   40F2         JC      ??macMcuRfIsr_4
    714            }
    715          }
   \                     ??macMcuRfIsr_3:
   \   000062   80..         SJMP    ?Subroutine8
   \   000064                REQUIRE RFIRQF1
   \   000064                REQUIRE S1CON
   \   000064                REQUIRE RFIRQF0
    716          
    717          
    718          /**************************************************************************************************
    719           * @fn          macMcuRfErrIsr
    720           *
    721           * @brief       Interrupt service routine that handles all RF Error interrupts.  Only the RX FIFO
    722           *              overflow condition is handled.
    723           *
    724           * @param       none
    725           *
    726           * @return      none
    727           **************************************************************************************************
    728           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    729          HAL_ISR_FUNCTION( macMcuRfErrIsr, RFERR_VECTOR )
   \                     macMcuRfErrIsr:
    730          {
   \   000000   C0E0         PUSH    A
   \   000002   74F2         MOV     A,#-0xe
   \   000004   12....       LCALL   ?INTERRUPT_ENTER_XSP
   \   000007                ; Saved register size: 15
   \   000007                ; Auto size: 0
    731            uint8 rferrm = RFERRM;
   \   000007   9061A5       MOV     DPTR,#0x61a5
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   FA           MOV     R2,A
    732          
    733            if ((RFERRF & RFERR_RXOVERF) & rferrm)
   \   00000C   E5BF         MOV     A,0xbf
   \   00000E   5A           ANL     A,R2
   \   00000F   5404         ANL     A,#0x4
   \   000011   6006         JZ      ??macMcuRfErrIsr_0
    734            {
    735              RFERRF &= ~RFERR_RXOVERF;
   \   000013   53BFFB       ANL     0xbf,#0xfb
    736              macRxFifoOverflowIsr();
   \   000016                ; Setup parameters for call to function macRxFifoOverflowIsr
   \   000016   12....       LCALL   ??macRxFifoOverflowIsr?relay
    737            }
    738          }
   \                     ??macMcuRfErrIsr_0:
   \   000019   02....       LJMP    ?Subroutine8
   \   00001C                REQUIRE RFERRF
    739          
    740          
    741          /**************************************************************************************************
    742           * @fn          macMcuRecordMaxRssiStart
    743           *
    744           * @brief       Starts recording of the maximum received RSSI value.
    745           *
    746           * @param       none
    747           *
    748           * @return      none
    749           **************************************************************************************************
    750           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    751          void macMcuRecordMaxRssiStart(void)
   \                     macMcuRecordMaxRssiStart:
    752          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    753            /* start maximum recorded value at the lowest possible value */
    754            maxRssi = -128;
   \   000004   7480         MOV     A,#-0x80
   \   000006   90....       MOV     DPTR,#maxRssi
   \   000009   F0           MOVX    @DPTR,A
    755          
    756            /* enable timer overflow interrupt */
    757            T2IRQM |= TIMER2_PERM;
   \   00000A   43A701       ORL     0xa7,#0x1
    758          }
   \   00000D   02....       LJMP    ?Subroutine6 & 0xFFFF
   \   000010                REQUIRE T2IRQM
    759          
    760          
    761          /**************************************************************************************************
    762           * @fn          macMcuRecordMaxRssiStop
    763           *
    764           * @brief       Stops recording of the maximum received RSSI.  It returns the maximum value
    765           *              received since starting the recording.
    766           *
    767           * @param       none
    768           *
    769           * @return      maximum received RSSI value
    770           **************************************************************************************************
    771           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    772          int8 macMcuRecordMaxRssiStop(void)
   \                     macMcuRecordMaxRssiStop:
    773          {
   \   000000   C082         PUSH    DPL
   \   000002   C083         PUSH    DPH
   \   000004                ; Saved register size: 2
   \   000004                ; Auto size: 0
    774            /* disable timer overflow interrupt */
    775            T2IRQM &= ~TIMER2_PERM;
   \   000004   53A7FE       ANL     0xa7,#0xfe
    776          
    777            return(maxRssi);
   \   000007   90....       MOV     DPTR,#maxRssi
   \   00000A   E0           MOVX    A,@DPTR
   \   00000B   F9           MOV     R1,A
   \   00000C   02....       LJMP    ?Subroutine6 & 0xFFFF
   \   00000F                REQUIRE T2IRQM
    778          }

   \                                 In  segment INTVEC, offset 0x3, root
   \                     `??macMcuRfErrIsr??INTVEC 3`:
   \   000003   02....       LJMP       (macMcuRfErrIsr)

   \                                 In  segment INTVEC, offset 0x53, root
   \                     `??macMcuTimer2Isr??INTVEC 83`:
   \   000053   02....       LJMP       (macMcuTimer2Isr)

   \                                 In  segment INTVEC, offset 0x83, root
   \                     `??macMcuRfIsr??INTVEC 131`:
   \   000083   02....       LJMP       (macMcuRfIsr)

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ff000000:
   \   000000   000000FF     DD 4278190080

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_0:
   \   000000   00000000     DD 0

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuInit?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuInit

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRandomByte?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomByte

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRandomWord?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRandomWord

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimerForceDelay?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerForceDelay

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimerCapture?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimerCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowCapture?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowCapture

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuOverflowSetCompare?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuOverflowSetCompare

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuTimer2OverflowWorkaround?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuTimer2OverflowWorkaround

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuPrecisionCount?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuPrecisionCount

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRecordMaxRssiStart?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStart

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??macMcuRecordMaxRssiStop?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    macMcuRecordMaxRssiStop
    779          
    780          
    781          /*=================================================================================================
    782           * @fn          macMcuRecordMaxRssiIsr
    783           *
    784           * @brief       Interrupt service routine called during recording of max RSSI value.
    785           *
    786           * @param       none
    787           *
    788           * @return      none
    789           *=================================================================================================
    790           */
    791          static void mcuRecordMaxRssiIsr(void)
    792          {
    793            int8 rssi;
    794          
    795            /* read latest RSSI value */
    796            rssi = RSSI;
    797          
    798            /* if new RSSI value is greater than the maximum already received, it is the new maximum */
    799            if (rssi > maxRssi)
    800            {
    801              maxRssi = rssi;
    802            }
    803          }
    804          
    805          
    806          /**************************************************************************************************
    807           *                                  Compile Time Integrity Checks
    808           **************************************************************************************************
    809           */
    810          #if ((IRQ_SFD != IM_SFD) || (IRQ_FIFOP != IM_FIFOP) || (IRQ_TXACKDONE != IM_TXACKDONE))
    811          #error "ERROR: Compile time error with RFIRQFx vs RFIRQMx register defines."
    812          #endif
    813          
    814          /**************************************************************************************************
    815          */

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     macMcuInit                         2      0      0
       -> macRxOn                       4      0      0
       -> macRxOff                      4      0      0
     macMcuOverflowCapture              1      0     16
     macMcuOverflowCount                1      0     32
     macMcuOverflowSetCompare           2      0     16
       -> halAssertHandler              0      0     32
     macMcuOverflowSetCount             2      0     16
       -> halAssertHandler              0      0     32
       -> macMcuOverflowCount           0      0     32
     macMcuPrecisionCount               2      0     14
     macMcuRandomByte                   0      0      0
     macMcuRandomWord                   2      0      0
     macMcuRecordMaxRssiStart           2      0      0
     macMcuRecordMaxRssiStop            2      0      0
     macMcuRfErrIsr                    15      0      0
       -> macRxFifoOverflowIsr         30      0      0
     macMcuRfIsr                       16      0      0
       -> macCspTxIntIsr               30      0      0
       -> macCspTxStopIsr              30      0      0
       -> macRxAckTxDoneCallback       30      0      0
       -> macRxThresholdIsr            30      0      0
     macMcuTimer2Isr                   16      0      0
       -> macBackoffTimerCompareIsr    30      0      0
     macMcuTimer2OverflowWorkaround     2      0     16
       -> macMcuOverflowCount           4      0     32
       -> macBackoffTimerCompareIsr     0      0     32
     macMcuTimerCapture                 2      0      0
     macMcuTimerForceDelay              0      0      0


   Segment part sizes:

     Function/Label                         Bytes
     --------------                         -----
     RFIRQF1                                   1
     T2CTRL                                    1
     IEN2                                      1
     S1CON                                     1
     T2IRQF                                    1
     T2M0                                      1
     T2M1                                      1
     T2MOVF0                                   1
     T2MOVF1                                   1
     T2MOVF2                                   1
     T2IRQM                                    1
     _A_IEN0                                   1
     IP0                                       1
     ADCCON1                                   1
     _A_IEN1                                   1
     IP1                                       1
     RNDL                                      1
     RNDH                                      1
     RFERRF                                    1
     T2MSEL                                    1
     RFIRQF0                                   1
     macChipVersion                            1
     maxRssi                                   1
     accumulatedOverflowCount                  4
     macMcuInit                              242
     ?Subroutine6                              7
     macMcuRandomByte                         13
     macMcuRandomWord                         17
     macMcuTimerForceDelay                    17
     ?Subroutine5                              8
     macMcuTimerCapture                       19
     macMcuOverflowCount                      26
     ?Subroutine0                              7
     ?Subroutine7                             52
     ??Subroutine10_0                          2
     ??Subroutine11_0                          8
     ?Subroutine4                             13
     macMcuOverflowCapture                    24
     macMcuOverflowSetCount                  119
     ?Subroutine9                              8
     ?Subroutine3                             18
     ?Subroutine2                             12
     macMcuOverflowSetCompare                112
     macMcuTimer2Isr                          69
     ?Subroutine8                              5
     macMcuTimer2OverflowWorkaround          102
     ?Subroutine1                              4
     macMcuPrecisionCount                     76
     macMcuRfIsr                             100
     macMcuRfErrIsr                           28
     macMcuRecordMaxRssiStart                 16
     macMcuRecordMaxRssiStop                  15
     ??macMcuRfErrIsr??INTVEC 3                3
     ??macMcuTimer2Isr??INTVEC 83              3
     ??macMcuRfIsr??INTVEC 131                 3
     __Constant_ff000000                       4
     __Constant_0                              4
     ??macMcuInit?relay                        6
     ??macMcuRandomByte?relay                  6
     ??macMcuRandomWord?relay                  6
     ??macMcuTimerForceDelay?relay             6
     ??macMcuTimerCapture?relay                6
     ??macMcuOverflowCount?relay               6
     ??macMcuOverflowCapture?relay             6
     ??macMcuOverflowSetCount?relay            6
     ??macMcuOverflowSetCompare?relay          6
     ??macMcuTimer2OverflowWorkaround?relay    6
     ??macMcuPrecisionCount?relay              6
     ??macMcuRecordMaxRssiStart?relay          6
     ??macMcuRecordMaxRssiStop?relay           6

 
 937 bytes in segment BANKED_CODE
  78 bytes in segment BANK_RELAYS
   9 bytes in segment INTVEC
 202 bytes in segment NEAR_CODE
  21 bytes in segment SFR_AN
   8 bytes in segment XDATA_ROM_C
   6 bytes in segment XDATA_Z
 
 1 217 bytes of CODE  memory (+  9 bytes shared)
     0 bytes of CONST memory (+  8 bytes shared)
     0 bytes of DATA  memory (+ 21 bytes shared)
     6 bytes of XDATA memory

Errors: none
Warnings: none
