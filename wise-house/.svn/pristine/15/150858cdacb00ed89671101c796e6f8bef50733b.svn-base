/******************************************************************************
	Filename:       GenericApp.c
	Revised:        $Date: 2012-03-07 01:04:58 -0800 (Wed, 07 Mar 2012) $
	Revision:       $Revision: 29656 $

	Description:    Generic Application (no Profile).


	Copyright 2004-2012 Texas Instruments Incorporated. All rights reserved.

	IMPORTANT: Your use of this Software is limited to those specific rights
	granted under the terms of a software license agreement between the user
	who downloaded the software, his/her employer (which must be your employer)
	and Texas Instruments Incorporated (the "License"). You may not use this
	Software unless you agree to abide by the terms of the License. The License
	limits your use, and you acknowledge, that the Software may not be modified,
	copied or distributed unless embedded on a Texas Instruments microcontroller
	or used solely and exclusively in conjunction with a Texas Instruments radio
	frequency transceiver, which is integrated into your product. Other than for
	the foregoing purpose, you may not use, reproduce, copy, prepare derivative
	works of, modify, distribute, perform, display or sell this Software and/or
	its documentation for any purpose.

	YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
	PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
	INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
	NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
	TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
	NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
	LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
	INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
	OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
	OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
	(INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.

	Should you have any questions regarding your right to use this Software,
	contact Texas Instruments Incorporated at www.TI.com.
******************************************************************************/

/*********************************************************************
	This application isn't intended to do anything useful, it is
	intended to be a simple example of an application's structure.

	This application sends "Hello World" to another "Generic"
	application every 5 seconds.  The application will also
	receives "Hello World" packets.

	The "Hello World" messages are sent/received as MSG type message.

	This applications doesn't have a profile, so it handles everything
	directly - itself.

	Key control:
		SW1:
		SW2:  initiates end device binding
		SW3:
		SW4:  initiates a match description request
*********************************************************************/

/*********************************************************************
 * INCLUDES
 */
#include "OSAL.h"
#include "AF.h"
#include "ZDApp.h"
#include "ZDObject.h"
#include "ZDProfile.h"
#include "osal_nv.h"

#include "GenericApp.h"
#include "DebugTrace.h"

#if !defined( WIN32 )
	#include "OnBoard.h"
#endif

/* HAL */
#include "hal_lcd.h"
#include "hal_led.h"
#include "hal_key.h"
#include "hal_uart.h"
#include "chdebug.h"

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

/* RTOS */
#if defined( IAR_ARMCM3_LM )
#include "RTOS_App.h"
#endif  

/*********************************************************************
 * MACROS
 */

/*********************************************************************
 * CONSTANTS
 */

/*********************************************************************
 * TYPEDEFS
 */

/*********************************************************************
 * GLOBAL VARIABLES
 */
// This list should be filled with Application specific Cluster IDs.
const cId_t GenericApp_ClusterList[GENERICAPP_MAX_CLUSTERS] =
{
	GENERICAPP_CLUSTERID
};

const SimpleDescriptionFormat_t GenericApp_SimpleDesc =
{
	GENERICAPP_ENDPOINT,              //  int Endpoint;
	GENERICAPP_PROFID,                //  uint16 AppProfId[2];
	GENERICAPP_DEVICEID,              //  uint16 AppDeviceId[2];
	GENERICAPP_DEVICE_VERSION,        //  int   AppDevVer:4;
	GENERICAPP_FLAGS,                 //  int   AppFlags:4;
	GENERICAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
	(cId_t *)GenericApp_ClusterList,  //  byte *pAppInClusterList;
	GENERICAPP_MAX_CLUSTERS,          //  byte  AppNumInClusters;
	(cId_t *)GenericApp_ClusterList   //  byte *pAppInClusterList;
};

// This is the Endpoint/Interface description.  It is defined here, but
// filled-in in GenericApp_Init().  Another way to go would be to fill
// in the structure here and make it a "const" (in code space).  The
// way it's defined in this sample app it is define in RAM.
endPointDesc_t GenericApp_epDesc;

/*********************************************************************
 * EXTERNAL VARIABLES
 */

/*********************************************************************
 * EXTERNAL FUNCTIONS
 */
/*********************************************************************
 * TYPEDEFS
 */
#if !defined( SERIAL_APP_PORT )
#define SERIAL_APP_PORT  0
#endif

#if !defined( SERIAL_APP_BAUD )
//#define SERIAL_APP_BAUD  HAL_UART_BR_38400
#define SERIAL_APP_BAUD  HAL_UART_BR_115200
#endif

// When the Rx buf space is less than this threshold, invoke the Rx callback.
#if !defined( SERIAL_APP_THRESH )
#define SERIAL_APP_THRESH  64
#endif

#if !defined( SERIAL_APP_RX_SZ )
#define SERIAL_APP_RX_SZ  128
#endif

#if !defined( SERIAL_APP_TX_SZ )
#define SERIAL_APP_TX_SZ  128
#endif

// Millisecs of idle time after a byte is received before invoking Rx callback.
#if !defined( SERIAL_APP_IDLE )
#define SERIAL_APP_IDLE  6
#endif

// Loopback Rx bytes to Tx for throughput testing.
#if !defined( SERIAL_APP_LOOPBACK )
#define SERIAL_APP_LOOPBACK  FALSE
#endif

// This is the max byte count per OTA message.
#if !defined( SERIAL_APP_TX_MAX )
#define SERIAL_APP_TX_MAX  50
#endif

#define MAXSENSOR 4

/*********************************************************************
 * GLOBAL VARIABLES
 */

XDATA static uint8 SerialApp_Buf[SERIAL_APP_TX_MAX];
static uint8 SerialApp_Len = 0;

#if defined(ZDO_COORDINATOR)
#define MAX_DEVICE_NUM_GEN	256
#define MAX_GROUP_NUM_GEN		MAX_DEVICE_NUM_GEN
#define FLASH_CACHE_GEN		1024

#define NV_GROUP_ID_WEIGHT		0x201

#define DEVICE_MASK_BYTES			((MAX_DEVICE_NUM_GEN + 7)/8)


#define GROUP_NAME_BYTES_GEN		16

#define NV_GROUP_NAME_START			0x280
#define NV_GROUP_NAME_END			(NV_GROUP_NAME_START + MAX_GROUP_NUM_GEN)


#define DEVICE_ADDR_BYTES_GEN		2
#define DEVICE_GROUP_ID_BYTES_GEN	2
#define DEVICE_NAME_BYTES_GEN		16
#define DEVICE_INFO_BYTES_GEN	(DEVICE_ADDR_BYTES_GEN + DEVICE_GROUP_ID_BYTES_GEN + DEVICE_NAME_BYTES_GEN)


#define NV_DEVICE_INFO_START		NV_GROUP_NAME_END
#define NV_DEVICE_INFO_END			(NV_DEVICE_INFO_START + MAX_DEVICE_NUM_GEN)

////每个终端节点上电时上报的短地址，所属组id，存入内存中
////上报的设备名字存入flash
static uint8 GenericApp_AddrNum = 0;

XDATA static uint8 pMaskDevice[DEVICE_MASK_BYTES] = {0};
XDATA static uint8 bufBig_gen[MAX_DEVICE_NUM_GEN*2] = {0};

////对组的操作，用一个位域指示组的存在性，用一个变量指示最后的组id号，
//static uint8 GenericApp_GroupIdMask[MAX_GROUP_NUM_GEN/8] = {0};
#endif
#if ! defined(RTR_NWK)
#define NV_GROUP_ID				0x201
#define NV_DEVICE_NAME				0x202
static uint16 GenericApp_GroupId = 0;
static char strDeviceName_gen[16] = {0};
#endif
static char strTemp_gen[50] = {0};

#define GENERICAPP_CMDID_SHORTADDR			0x0001
#define GENERICAPP_CMDID_LIGHT_WHITE			0x0002
#define GENERICAPP_CMDID_LIGHT_COLOR			0x0003
#define GENERICAPP_CMDID_SET_DEVICE_NAME	0x0004
#define GENERICAPP_CMDID_ADD_TO_GROUP		0x0010
#define GENERICAPP_CMDID_REMOVE_FROM_GROUP	0x0011
#define GENERICAPP_CMDID_READ_DEVICE_NAME	0x0021
#define GENERICAPP_CMDID_RESPONSE_READ_DEVICE_NAME	0x0022
#define GENERICAPP_CMDID_READ_GROUP_ID		0x0023
#define GENERICAPP_CMDID_RESPONSE_READ_GROUP_ID		0x0024
/*********************************************************************
 * LOCAL VARIABLES
 */
byte GenericApp_TaskID;   // Task ID for internal task/event processing
													// This variable will be received when
													// GenericApp_Init() is called.
devStates_t GenericApp_NwkState;


byte GenericApp_TransID;  // This is the unique message ID (counter)

afAddrType_t GenericApp_DstAddr;

/*********************************************************************
 * LOCAL FUNCTIONS
 */
static void GenericApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg );
static void GenericApp_HandleKeys( byte shift, byte keys );
static void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pckt );
static void GenericApp_SendMessage(afAddrMode_t addrMode,uint16 addr ,uint8* buf,uint16 buflen );
static void GenericApp_SendMessageCmd(afAddrMode_t addrMode,uint16 addr ,uint16 cmd,uint8* buf,uint16 buflen );

#if defined( IAR_ARMCM3_LM )
static void GenericApp_ProcessRtosMessage( void );
#endif
uint8 hex2CharHi(uint8 t );
uint8 hex2CharLow(uint8 t);
static void SerialApp_CallBack(uint8 port, uint8 event);
void PrintDeviceList_gen(void);

/*********************************************************************
 * NETWORK LAYER CALLBACKS
 */

/*********************************************************************
 * PUBLIC FUNCTIONS
 */
//十六进制转换成ascii,高字节
uint8 hex2CharHi(uint8 t )
{
	uint8 abc;
	uint8 cba;
	uint8 xx1;
	abc=t;
	cba=0xf0;
	abc=(abc&cba)>>4;
	if(abc<10)
	{
		xx1=abc+48;
	}
	else
	{
		xx1=abc+55;
	}
	return xx1;
}
/*********************************************************************
 * @fn      GenericApp_Init
 *
 * @brief   Initialization function for the Generic App Task.
 *          This is called during initialization and should contain
 *          any application specific initialization (ie. hardware
 *          initialization/setup, table initialization, power up
 *          notificaiton ... ).
 *
 * @param   task_id - the ID assigned by OSAL.  This ID should be
 *                    used to send messages and set timers.
 *
 * @return  none
 */
uint8 hex2CharLow(uint8 t)
{
	uint8 abc;
	uint8 cba;
	uint8 xx2;
	abc=t;
	cba=0x0f;
	abc=abc&cba;
	if(abc<10)
	{
		xx2=abc+48;
	}
	else
	{
		xx2=abc+55;
	}
	return xx2;
}

/*********************************************************************
 * @fn      GenericApp_Init
 *
 * @brief   Initialization function for the Generic App Task.
 *          This is called during initialization and should contain
 *          any application specific initialization (ie. hardware
 *          initialization/setup, table initialization, power up
 *          notificaiton ... ).
 *
 * @param   task_id - the ID assigned by OSAL.  This ID should be
 *                    used to send messages and set timers.
 *
 * @return  none
 */
void GenericApp_Init( uint8 task_id )
{
	halUARTCfg_t uartConfig;

	uartConfig.configured = TRUE;
	uartConfig.baudRate = HAL_UART_BR_115200;
	uartConfig.flowControl          = FALSE;
	uartConfig.flowControlThreshold = SERIAL_APP_THRESH;
	uartConfig.rx.maxBufSize        = SERIAL_APP_RX_SZ;
	uartConfig.tx.maxBufSize        = SERIAL_APP_TX_SZ;
	uartConfig.idleTimeout          = SERIAL_APP_IDLE;
	uartConfig.intEnable            = TRUE;
	uartConfig.callBackFunc         = SerialApp_CallBack;
	HalUARTOpen(0,&uartConfig);

	GenericApp_TaskID = task_id;
	GenericApp_NwkState = DEV_INIT;
	GenericApp_TransID = 0;

#if defined(ZDO_COORDINATOR) || defined(RTR_NWK)
	//#error d1
#else
	//#error d2
#endif
	// Device hardware initialization can be added here or in main() (Zmain.c).
	// If the hardware is application specific - add it here.
	// If the hardware is other parts of the device add it in main().

#if defined(ZDO_COORDINATOR) || defined(RTR_NWK)
	GenericApp_DstAddr.addrMode = (afAddrMode_t)AddrNotPresent;
	GenericApp_DstAddr.endPoint = 0;
	GenericApp_DstAddr.addr.shortAddr = 0;
#else
	GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
	GenericApp_DstAddr.addr.shortAddr = 0;
	// Take the first endpoint, Can be changed to search through endpoints
	GenericApp_DstAddr.endPoint = GENERICAPP_ENDPOINT;
#endif

	// Fill out the endpoint description.
	GenericApp_epDesc.endPoint = GENERICAPP_ENDPOINT;
	GenericApp_epDesc.task_id = &GenericApp_TaskID;
	GenericApp_epDesc.simpleDesc
						= (SimpleDescriptionFormat_t *)&GenericApp_SimpleDesc;
	GenericApp_epDesc.latencyReq = noLatencyReqs;

	/*strTemp_gen = osal_mem_alloc(sizeof(char)*40);
	if(strTemp_gen != NULL)
		memset(strTemp_gen,0,sizeof(char)*40);

	{
		char *strErr = "Cannot alloc strTemp_gen\r\n";
		HalUARTWrite(0,(uint8*)strErr,strlen(strErr));
	}*/
	#if defined(ZDO_COORDINATOR)
	/*
	pMaskDevice = osal_mem_alloc(sizeof(uint8)*DEVICE_MASK_BYTES);
	if(pMaskDevice != NULL)
		memset(pMaskDevice,0,sizeof(uint8)*DEVICE_MASK_BYTES);

	{
		sprintf(strTemp_gen," pMaskDevice=%x\r\n",strTemp_gen);
		HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
	}
	*/
	memset(bufBig_gen,0,sizeof(bufBig_gen));
	osal_nv_item_init(NV_GROUP_ID_WEIGHT,MAX_GROUP_NUM_GEN*sizeof(uint16),bufBig_gen);

	#elif ! defined(RTR_NWK)
	osal_nv_read(NV_GROUP_ID,0, 2, &GenericApp_GroupId);
	osal_nv_read(NV_DEVICE_NAME,0, 16, &strDeviceName_gen);
	#endif
	// Register the endpoint description with the AF
	afRegister( &GenericApp_epDesc );

	// Register for all key events - This app will handle all key events
	RegisterForKeys( GenericApp_TaskID );

	// Update the display
#if defined ( LCD_SUPPORTED )
	HalLcdWriteString( "GenericApp", HAL_LCD_LINE_1 );
#endif

	ZDO_RegisterForZDOMsg( GenericApp_TaskID, End_Device_Bind_rsp );
	ZDO_RegisterForZDOMsg( GenericApp_TaskID, Match_Desc_rsp );

#if defined( IAR_ARMCM3_LM )
	// Register this task with RTOS task initiator
	RTOS_RegisterApp( task_id, GENERICAPP_RTOS_MSG_EVT );
#endif

}

/*********************************************************************
 * @fn      GenericApp_ProcessEvent
 *
 * @brief   Generic Application Task event processor.  This function
 *          is called to process all events for the task.  Events
 *          include timers, messages and any other user defined events.
 *
 * @param   task_id  - The OSAL assigned task ID.
 * @param   events - events to process.  This is a bit map and can
 *                   contain more than one event.
 *
 * @return  none
 */
uint16 GenericApp_ProcessEvent( uint8 task_id, uint16 events )
{
	afIncomingMSGPacket_t *MSGpkt;
	afDataConfirm_t *afDataConfirm;

	// Data Confirmation message fields
	byte sentEP;
	ZStatus_t sentStatus;
	byte sentTransID;       // This should match the value sent
	(void)task_id;  // Intentionally unreferenced parameter

	if ( events & SYS_EVENT_MSG )
	{
		MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );
		while ( MSGpkt )
		{
			//sprintf(strTemp_gen,"event=%x,addr=%x\r\n",MSGpkt->hdr.event,NLME_GetShortAddr());
			//HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
		 	switch ( MSGpkt->hdr.event )
			{
				case ZDO_CB_MSG:
					GenericApp_ProcessZDOMsgs( (zdoIncomingMsg_t *)MSGpkt );
					break;

				case KEY_CHANGE:
					GenericApp_HandleKeys( ((keyChange_t *)MSGpkt)->state, ((keyChange_t *)MSGpkt)->keys );
					break;

				case AF_DATA_CONFIRM_CMD:
					// This message is received as a confirmation of a data packet sent.
					// The status is of ZStatus_t type [defined in ZComDef.h]
					// The message fields are defined in AF.h
					afDataConfirm = (afDataConfirm_t *)MSGpkt;
					sentEP = afDataConfirm->endpoint;
					sentStatus = afDataConfirm->hdr.status;
					sentTransID = afDataConfirm->transID;
					(void)sentEP;
					(void)sentTransID;

					// Action taken when confirmation is received.
					if ( sentStatus != ZSuccess )
					{
						// The data wasn't delivered -- Do something
					}
					break;

				case AF_INCOMING_MSG_CMD:
					GenericApp_MessageMSGCB( MSGpkt );
					break;

				case ZDO_STATE_CHANGE:
					GenericApp_NwkState = (devStates_t)(MSGpkt->hdr.status);
					//sprintf(strTemp_gen,"ZDO_STATE_CHANGE=%x,addr=%x\r\n",GenericApp_NwkState,NLME_GetShortAddr());
					//HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
					#if defined(ZDO_COORDINATOR)
						if ( (GenericApp_NwkState == DEV_ZB_COORD))
						{
							
						}
					#elif ! defined(RTR_NWK)
						if ( GenericApp_NwkState == DEV_END_DEVICE )
						{
							//report short addr to the coordinator
							uint8 sendBuf[20];
							uint16 shortAddr = NLME_GetShortAddr();
							int i;
							//uint8 group;
							sendBuf[0] = shortAddr&0xff;
							sendBuf[1] = shortAddr>>8;
							sendBuf[2] = GenericApp_GroupId&0xff;
							sendBuf[3] = GenericApp_GroupId>>8;
							for(i=0;i<16;i++)
								sendBuf[4 + i] = strDeviceName_gen[i];
							
							
							GenericApp_SendMessageCmd(afAddr16Bit,0,GENERICAPP_CMDID_SHORTADDR,sendBuf,20);
						}
					#endif

					break;

				default:
					break;
			}

			// Release the memory
			osal_msg_deallocate( (uint8 *)MSGpkt );

			// Next
			MSGpkt = (afIncomingMSGPacket_t *)osal_msg_receive( GenericApp_TaskID );
		}

		// return unprocessed events
		return (events ^ SYS_EVENT_MSG);
	}

	// Send a message out - This event is generated by a timer
	//  (setup in GenericApp_Init()).
	if ( events & GENERICAPP_SEND_MSG_EVT )
	{
		// Send "the" message
		//GenericApp_SendTheMessage();

		// Setup to send message again
		osal_start_timerEx( GenericApp_TaskID,
												GENERICAPP_SEND_MSG_EVT,
												GENERICAPP_SEND_MSG_TIMEOUT );

		// return unprocessed events
		return (events ^ GENERICAPP_SEND_MSG_EVT);
	}

	
#if defined( IAR_ARMCM3_LM )
	// Receive a message from the RTOS queue
	if ( events & GENERICAPP_RTOS_MSG_EVT )
	{
		// Process message from RTOS queue
		GenericApp_ProcessRtosMessage();

		// return unprocessed events
		return (events ^ GENERICAPP_RTOS_MSG_EVT);
	}
#endif

	// Discard unknown events
	return 0;
}

/*********************************************************************
 * Event Generation Functions
 */

/*********************************************************************
 * @fn      GenericApp_ProcessZDOMsgs()
 *
 * @brief   Process response messages
 *
 * @param   none
 *
 * @return  none
 */
static void GenericApp_ProcessZDOMsgs( zdoIncomingMsg_t *inMsg )
{
	switch ( inMsg->clusterID )
	{
		case End_Device_Bind_rsp:
			if ( ZDO_ParseBindRsp( inMsg ) == ZSuccess )
			{
				// Light LED
				HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
			}
#if defined( BLINK_LEDS )
			else
			{
				// Flash LED to show failure
				HalLedSet ( HAL_LED_4, HAL_LED_MODE_FLASH );
			}
#endif
			break;

		case Match_Desc_rsp:
			{
				ZDO_ActiveEndpointRsp_t *pRsp = ZDO_ParseEPListRsp( inMsg );
				if ( pRsp )
				{
					if ( pRsp->status == ZSuccess && pRsp->cnt )
					{
				char text[30];
						GenericApp_DstAddr.addrMode = (afAddrMode_t)Addr16Bit;
						GenericApp_DstAddr.addr.shortAddr = pRsp->nwkAddr;
						// Take the first endpoint, Can be changed to search through endpoints
						GenericApp_DstAddr.endPoint = pRsp->epList[0];

			sprintf(text,"endPoint=%d\n",GenericApp_DstAddr.endPoint);
			HalUARTWrite(0,(unsigned char *)text,strlen(text));

						// Light LED
						HalLedSet( HAL_LED_4, HAL_LED_MODE_ON );
					}
					osal_mem_free( pRsp );
				}
			}
			break;
	}
}

/*********************************************************************
 * @fn      GenericApp_HandleKeys
 *
 * @brief   Handles all key events for this device.
 *
 * @param   shift - true if in shift/alt.
 * @param   keys - bit field for key events. Valid entries:
 *                 HAL_KEY_SW_4
 *                 HAL_KEY_SW_3
 *                 HAL_KEY_SW_2
 *                 HAL_KEY_SW_1
 *
 * @return  none
 */
static void GenericApp_HandleKeys( uint8 shift, uint8 keys )
{
	zAddrType_t dstAddr;

	// Shift is used to make each button/switch dual purpose.
	if ( 0 )
	{
		if ( keys & HAL_KEY_SW_1 )
		{
		}
		if ( keys & HAL_KEY_SW_2 )
		{
		}
		if ( keys & HAL_KEY_SW_3 )
		{
		}
		if ( keys & HAL_KEY_SW_4 )
		{
		}
	}
	else
	{
		if ( keys & HAL_KEY_SW_1 )
		{
			// Since SW1 isn't used for anything else in this application...
#if defined( SWITCH1_BIND )
			// we can use SW1 to simulate SW2 for devices that only have one switch,
			keys |= HAL_KEY_SW_2;
#elif defined( SWITCH1_MATCH )
			// or use SW1 to simulate SW4 for devices that only have one switch
			keys |= HAL_KEY_SW_4;
#endif
		}

		if ( keys & HAL_KEY_SW_2 )
		{
			HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );

			// Initiate an End Device Bind Request for the mandatory endpoint
			dstAddr.addrMode = Addr16Bit;
			dstAddr.addr.shortAddr = 0x0000; // Coordinator
			ZDP_EndDeviceBindReq( &dstAddr, NLME_GetShortAddr(),
														GenericApp_epDesc.endPoint,
														GENERICAPP_PROFID,
														GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
														GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
														FALSE );
		}

		if ( keys & HAL_KEY_SW_3 )
		{
		}

		if ( keys & HAL_KEY_SW_4 )
		{
			HalLedSet ( HAL_LED_4, HAL_LED_MODE_OFF );
			// Initiate a Match Description Request (Service Discovery)
			dstAddr.addrMode = AddrBroadcast;
			dstAddr.addr.shortAddr = NWK_BROADCAST_SHORTADDR;
			ZDP_MatchDescReq( &dstAddr, NWK_BROADCAST_SHORTADDR,
												GENERICAPP_PROFID,
												GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
												GENERICAPP_MAX_CLUSTERS, (cId_t *)GenericApp_ClusterList,
												FALSE );
		}
	}
}

/*********************************************************************
 * LOCAL FUNCTIONS
 */

/*********************************************************************
 * @fn      GenericApp_MessageMSGCB
 *
 * @brief   Data message processor callback.  This function processes
 *          any incoming data - probably from other devices.  So, based
 *          on cluster ID, perform the intended action.
 *
 * @param   none
 *
 * @return  none
 */
static void GenericApp_MessageMSGCB( afIncomingMSGPacket_t *pkt )
{
#if 1
	int i;
	uint16 cmdId;
	ChDebugUnsigned(strTemp_gen,"Message DataLength=%d\r\n",pkt->cmd.DataLength);
	HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
	strTemp_gen[0] = 0;
	for(i = 0;i<pkt->cmd.DataLength;i++)
	{
		ChDebugHex(strTemp_gen+strlen(strTemp_gen)," %02x",pkt->cmd.Data[i]);
		if(i%8 == 7)
		{
			strcpy(strTemp_gen+strlen(strTemp_gen),"\r\n");
			HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
			strTemp_gen[0] = 0;
		}
	}
	strcpy(strTemp_gen+strlen(strTemp_gen),"\r\n");
	HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
	switch ( pkt->clusterId )
	{
		case GENERICAPP_CLUSTERID:
			cmdId = (pkt->cmd.Data[0])|(pkt->cmd.Data[1]<<8);
			switch(cmdId)
			{
			
			case GENERICAPP_CMDID_SHORTADDR:
				#if defined(ZDO_COORDINATOR)
				{
					uint8 find = 0;
					uint16 addr = (pkt->cmd.Data[2])|(pkt->cmd.Data[3]<<8);
					ChDebugHex(strTemp_gen,"addr=%x\r\n",addr);
					HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
					int i;
					int firstNullPos = -1;
					uint16 savedAddr = 0;
					////add new device info to the list
					{
						int deviceMaskBytes = DEVICE_MASK_BYTES;
						for(i=0;i<deviceMaskBytes;i++)
						{
							int k;
							int thisBits = 8;
							for(k=0;k<thisBits;k++)
							{
								if((pMaskDevice[i]>>k)&0x01)
								{
									savedAddr = 0;
									osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,0,2,&savedAddr);
									ChDebugHex(strTemp_gen,"savedAddr=%x\r\n",savedAddr);
									HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
									if(savedAddr == addr)
									{
										find = TRUE;
										//error 
										ChDebugHex(strTemp_gen,"error: addr[%04x]",savedAddr);
										strcpy(strTemp_gen," already exist\r\n");
										HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
										break;
									}
								}
								else
								{
									if(firstNullPos == -1)
										firstNullPos = i * 8 + k;
								}
							}
							if(find)
							{
								break;
							}
						}
					}
					ChDebugUnsigned(strTemp_gen,"find=%d\r\n",find);
					HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
					if( ! find)
					{
						if(firstNullPos != -1)
						{
							ChDebugSigned(strTemp_gen,"firstNullPos=%d\r\n",firstNullPos);
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
							if(SUCCESS == osal_nv_item_init(NV_DEVICE_INFO_START + firstNullPos,DEVICE_INFO_BYTES_GEN,&pkt->cmd.Data[2]))
								osal_nv_write(NV_DEVICE_INFO_START + firstNullPos,0,DEVICE_INFO_BYTES_GEN,&pkt->cmd.Data[2]);
							osal_nv_read(NV_DEVICE_INFO_START + firstNullPos,0,DEVICE_INFO_BYTES_GEN,bufBig_gen);
							{
								strcpy(strTemp_gen,"info read\r\n");
								HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
								strTemp_gen[0] = 0;
								for(i = 0;i<pkt->cmd.DataLength;i++)
								{
									ChDebugHex(strTemp_gen+strlen(strTemp_gen)," %02x",bufBig_gen[i]);
									if(i%8 == 7)
									{
										strcpy(strTemp_gen+strlen(strTemp_gen),"\r\n");
										HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
										strTemp_gen[0] = 0;
									}
								}
								strcpy(strTemp_gen+strlen(strTemp_gen),"\r\n");
								HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
							}
							pMaskDevice[firstNullPos/8] |= 1<<(firstNullPos%8);
							GenericApp_AddrNum++;
							{
								uint16 groupId = *((uint16*)(&pkt->cmd.Data[4]));
								if(groupId != 0)
								{
									uint16 *pGroupIdWeight = (uint16 *)bufBig_gen;
									memset(bufBig_gen,0,sizeof(bufBig_gen));
									osal_nv_read(NV_GROUP_ID_WEIGHT,0,MAX_GROUP_NUM_GEN*sizeof(uint16),pGroupIdWeight);
									for(i=1;i<MAX_GROUP_NUM_GEN;i++)
										if(i != groupId && pGroupIdWeight[i] != 0)
											pGroupIdWeight[i]--;
										else if(i == groupId )
											pGroupIdWeight[i] = 0xffff;
									osal_nv_write(NV_GROUP_ID_WEIGHT,0,MAX_GROUP_NUM_GEN*sizeof(uint16),pGroupIdWeight);
									//osal_mem_free(pGroupIdWeight);
								}
							}
						}
						else
						{
							//error 
							strcpy(strTemp_gen,"error: addr_list is full\r\n");
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
						}
					}
					strcpy(strTemp_gen,"next PrintDeviceList\r\n");
					HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
					PrintDeviceList_gen();
				}
				#endif
				break;
			case GENERICAPP_CMDID_LIGHT_WHITE:
				{
					if(pkt->cmd.Data[2] != 0)
						HalLedSet(HAL_LED_2,HAL_LED_MODE_ON);
					else
						HalLedSet(HAL_LED_2,HAL_LED_MODE_OFF);
				}
				break;
			case GENERICAPP_CMDID_LIGHT_COLOR:
				{
					if(pkt->cmd.Data[2] != 0)
						HalLedSet(HAL_LED_1,HAL_LED_MODE_ON);
					else
						HalLedSet(HAL_LED_1,HAL_LED_MODE_OFF);
				}
				break;
			case GENERICAPP_CMDID_SET_DEVICE_NAME:
				#if ! defined(RTR_NWK)
				{
					memcpy(strDeviceName_gen,&pkt->cmd.Data[2],16);
					if(SUCCESS == osal_nv_item_init(NV_DEVICE_NAME,16,&pkt->cmd.Data[2]))
						osal_nv_write(NV_DEVICE_NAME,0,16,&pkt->cmd.Data[2]);
				}
				#endif
				break;
			case GENERICAPP_CMDID_ADD_TO_GROUP:
				#if ! defined(RTR_NWK)
				{
					GenericApp_GroupId = *((uint16*)(pkt->cmd.Data+2));
					if(SUCCESS == osal_nv_item_init(NV_GROUP_ID,2,&pkt->cmd.Data[2]))
						osal_nv_write(NV_GROUP_ID,0,2,&pkt->cmd.Data[2]);
				}
				#endif
				break;
			case GENERICAPP_CMDID_REMOVE_FROM_GROUP:
				#if ! defined(RTR_NWK)
				{
					uint16 newGroupId = 0;
					osal_nv_write(NV_GROUP_ID,0,2,&newGroupId);
				}
				#endif
				break;
			case GENERICAPP_CMDID_READ_DEVICE_NAME:
				#if ! defined(RTR_NWK)
				{
					uint8 sendBuf[18];
					uint16 shortAddr = NLME_GetShortAddr();
					int i;
					//uint8 group;
					sendBuf[0] = shortAddr&0xff;
					sendBuf[1] = shortAddr>>8;
					for(i=0;i<16;i++)
						sendBuf[2 + i] = strDeviceName_gen[i];
					
					
					GenericApp_SendMessage(afAddr16Bit,0,sendBuf,18);
				}
				#endif
				break;
			case GENERICAPP_CMDID_RESPONSE_READ_DEVICE_NAME:
				#if defined(ZDO_COORDINATOR)
				sprintf(strTemp_gen,"addr[%04x],name=%s\r\n",*((uint16*)(pkt->cmd.Data)),(char*)pkt->cmd.Data[2]);
				HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
				#endif
				break;
			case GENERICAPP_CMDID_READ_GROUP_ID:
				#if ! defined(RTR_NWK)
				{
					uint8 sendBuf[18];
					uint16 shortAddr = NLME_GetShortAddr();
					int i;
					//uint8 group;
					sendBuf[0] = shortAddr&0xff;
					sendBuf[1] = shortAddr>>8;
					sendBuf[2] = GenericApp_GroupId&0xff;
					sendBuf[3] = GenericApp_GroupId>>8;
					
					
					GenericApp_SendMessage(afAddr16Bit,0,sendBuf,4);
				}
				#endif
				break;
			case GENERICAPP_CMDID_RESPONSE_READ_GROUP_ID:
				#if defined(ZDO_COORDINATOR)
				sprintf(strTemp_gen,"addr[%04x],group id=%d\r\n",*((uint16*)(pkt->cmd.Data)),*((uint16*)(pkt->cmd.Data+2)));
				HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
				#endif
				break;
			}
			break;
	}
#endif
}

/*********************************************************************
 * @fn      GenericApp_SendTheMessage
 *
 * @brief   Send "the" message.
 *
 * @param   none
 *
 * @return  none
 */
static void GenericApp_SendMessage(afAddrMode_t addrMode,uint16 addr ,uint8* buf,uint16 buflen )
{
	
	GenericApp_DstAddr.addrMode = addrMode;
	GenericApp_DstAddr.endPoint = GENERICAPP_ENDPOINT;
	GenericApp_DstAddr.addr.shortAddr = addr;
	
	
	if ( AF_DataRequest( &GenericApp_DstAddr, &GenericApp_epDesc,
											 GENERICAPP_CLUSTERID,
											 buflen,
											 (byte *)buf,
											 &GenericApp_TransID,
											 AF_DISCV_ROUTE, AF_DEFAULT_RADIUS ) == afStatus_SUCCESS )
	{
	}
	else
	{} 
}

/*********************************************************************
 * @fn      GenericApp_SendTheMessage
 *
 * @brief   Send "the" message.
 *
 * @param   none
 *
 * @return  none
 */
static void GenericApp_SendMessageCmd(afAddrMode_t addrMode,uint16 addr ,uint16 cmd,uint8* buf,uint16 buflen )
{
	int i;
	uint8 *sendBuf = osal_mem_alloc(30);
	sendBuf[0] = cmd&0xff;
	sendBuf[1] = cmd>>8;
	for(i=0;i<buflen;i++)
		sendBuf[i + 2] = buf[i];
	
	GenericApp_SendMessage(addrMode,addr,sendBuf,buflen + 2);
	osal_mem_free(sendBuf);
}

#if defined( IAR_ARMCM3_LM )
/*********************************************************************
 * @fn      GenericApp_ProcessRtosMessage
 *
 * @brief   Receive message from RTOS queue, send response back.
 *
 * @param   none
 *
 * @return  none
 */
static void GenericApp_ProcessRtosMessage( void )
{
	osalQueue_t inMsg;

	if ( osal_queue_receive( OsalQueue, &inMsg, 0 ) == pdPASS )
	{
		uint8 cmndId = inMsg.cmnd;
		uint32 counter = osal_build_uint32( inMsg.cbuf, 4 );

		switch ( cmndId )
		{
			case CMD_INCR:
				counter += 1;  /* Increment the incoming counter */
											 /* Intentionally fall through next case */

			case CMD_ECHO:
			{
				userQueue_t outMsg;

				outMsg.resp = RSP_CODE | cmndId;  /* Response ID */
				osal_buffer_uint32( outMsg.rbuf, counter );    /* Increment counter */
				osal_queue_send( UserQueue1, &outMsg, 0 );  /* Send back to UserTask */
				break;
			}
			
			default:
				break;  /* Ignore unknown command */    
		}
	}
}
#endif

/*********************************************************************
 * @fn      SerialApp_CallBack回调函数
 *
 * @brief   Send data OTA.
 *
 * @param   port - UART port.
 * @param   event - the UART port event flag.
 *
 * @return  none
 */
static void SerialApp_CallBack(uint8 port, uint8 event)
{
#if 1
	(void)port;

	uint8 checksum = 0;
	int i=0;
	uint8 sendBuf[30];
	
	if ((event & (HAL_UART_RX_FULL | HAL_UART_RX_ABOUT_FULL | HAL_UART_RX_TIMEOUT)) &&
#if SERIAL_APP_LOOPBACK
			(SerialApp_Len < SERIAL_APP_TX_MAX))
#else
			!SerialApp_Len)
#endif
	{
		if (!SerialApp_Len && 
			(SerialApp_Len = HalUARTRead(SERIAL_APP_PORT, SerialApp_Buf, SERIAL_APP_TX_MAX)))
		{
			//sprintf(strTemp_gen,"serial receive Len=%d,data=%02x,%02x,%02x,%02x\r\n",SerialApp_Len
			//	,SerialApp_Buf[0],SerialApp_Buf[1],SerialApp_Buf[2],SerialApp_Buf[3]);
			//HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
			// Pre-pend sequence number to the Tx message.
			uint16 cmdid = (SerialApp_Buf[0])|(SerialApp_Buf[1]<<8);
			
			
			switch(cmdid) //解析命令字
			{

			#if defined(ZDO_COORDINATOR)
			case 0x0001://read nv items
				{
					uint16 id = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					/* Length of item in NV memory */
					uint16 len = osal_nv_item_len(id);
					uint8 *pRetBuf;

					sprintf(strTemp_gen,"id[%x] len=%d\r\n",id,len);
					HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
					pRetBuf = osal_mem_alloc(len);
					if (pRetBuf != NULL)
					{
						if ((osal_nv_read(id,0, len, pRetBuf)) == ZSUCCESS)
						{
							int i;
							strTemp_gen[0] = 0;
							for(i = 0;i<len;i++)
							{
								sprintf(strTemp_gen+strlen(strTemp_gen),"%02x ",pRetBuf[i]);
								if(i%8 == 7)
								{
									sprintf(strTemp_gen+strlen(strTemp_gen),"\r\n");
									HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
									strTemp_gen[0] = 0;
								}
							}
							sprintf(strTemp_gen+strlen(strTemp_gen),"\r\n");
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
						}
					}
					osal_mem_free(pRetBuf);
				}
			case 0x0002://read addr table
				{
					PrintDeviceList_gen();
				}
					
				break;
			
			case 0x0003://send control cmds to endDevices
				{
					//addrmode[1],addr[2],cmds[...]
					uint16 addr = (SerialApp_Buf[3])|(SerialApp_Buf[4]<<8);
					uint16 cmd = (SerialApp_Buf[5])|(SerialApp_Buf[6]<<8);

					GenericApp_SendMessageCmd((afAddrMode_t)SerialApp_Buf[2], addr,cmd, &SerialApp_Buf[7], SerialApp_Len-7);
				}
				break;
			case 0x0004:
				{
					int deviceMaskBytes = DEVICE_MASK_BYTES;
					sprintf(strTemp_gen,"MaskDevice\r\n");
					HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
					strTemp_gen[0] = 0;
					for(i=0;i<deviceMaskBytes;i++)
					{
						sprintf(strTemp_gen + strlen(strTemp_gen),"%02x ",pMaskDevice[i]);
						if(i%8 == 7)
						{
							sprintf(strTemp_gen + strlen(strTemp_gen),"\r\n");
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
							strTemp_gen[0] = 0;
						}
					}
					sprintf(strTemp_gen,"\r\n");
					HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
			}
				break;
			case 0x0010://set device name
				{
					// addr[2],name[16]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					
					uint8 find = 0;
					int i;
					uint16 savedAddr = 0;
					////
					{
						int deviceMaskBytes = DEVICE_MASK_BYTES;
						for(i=0;i<deviceMaskBytes;i++)
						{
							int k;
							int thisBits = 8;
							for(k=0;k<thisBits;k++)
							{
								if((pMaskDevice[i]>>k)&0x01)
								{
									savedAddr = 0;
									osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,0,2,&savedAddr);
									if(savedAddr == addr)
									{
										osal_nv_write(NV_DEVICE_INFO_START + i * 8 + k,4,16,&SerialApp_Buf[4]);
										find = TRUE;
										break;
									}
								}
							}
							if(find)
							{
								break;
							}
						}
						if( ! find)
						{
							sprintf(strTemp_gen,"addr[%04x] not exist\r\n",addr);
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
						}
					}

					GenericApp_SendMessageCmd(afAddr16Bit, addr,GENERICAPP_CMDID_SET_DEVICE_NAME, &SerialApp_Buf[4], SerialApp_Len-4);
				}
				break;
			case 0x0011://read device name from coordinator
				{
					// addr[2]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					
					uint8 find = 0;
					int i;
					uint16 savedAddr = 0;
					////
					{
						int deviceMaskBytes = DEVICE_MASK_BYTES;
						for(i=0;i<deviceMaskBytes;i++)
						{
							int k;
							int thisBits = 8;
							for(k=0;k<thisBits;k++)
							{
								if((pMaskDevice[i]>>k)&0x01)
								{
									osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,0,2,&savedAddr);
									if(savedAddr == addr)
									{
										osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,4,DEVICE_NAME_BYTES_GEN,sendBuf);
										sendBuf[DEVICE_NAME_BYTES_GEN] = 0;
										sprintf(strTemp_gen,"addr[%04x],name=%s\r\n",addr,sendBuf);
										HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
										find = TRUE;
										break;
									}
								}
							}
							if(find)
							{
								break;
							}
						}
						if( ! find)
						{
							sprintf(strTemp_gen,"addr[%04x] not exist\r\n",addr);
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
						}
					}

				}
				break;
			case 0x0012://read device name from endDevice
				{
					// addr[2]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					
					GenericApp_SendMessageCmd(afAddr16Bit, addr,GENERICAPP_CMDID_READ_DEVICE_NAME, NULL,0);

				}
				break;
			case 0x0013://read group id from coordinator
				{
					// addr[2]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					
					uint8 find = 0;
					int i;
					uint16 savedAddr = 0;
					uint16 groupId = 0;
					////
					{
						int deviceMaskBytes = DEVICE_MASK_BYTES;
						for(i=0;i<deviceMaskBytes;i++)
						{
							int k;
							int thisBits = 8;
							for(k=0;k<thisBits;k++)
							{
								if((pMaskDevice[i]>>k)&0x01)
								{
									osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,0,2,&savedAddr);
									if(savedAddr == addr)
									{
										osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,2,2,&groupId);
										sendBuf[DEVICE_NAME_BYTES_GEN] = 0;
										sprintf(strTemp_gen,"addr[%04x],group id=%d\r\n",addr,groupId);
										HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
										find = TRUE;
										break;
									}
								}
							}
							if(find)
							{
								break;
							}
						}
						if( ! find)
						{
							sprintf(strTemp_gen,"addr[%04x] not exist\r\n",addr);
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
						}
					}

				}
				break;
			case 0x0014://read group id from endDevice
				{
					// addr[2]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					
					GenericApp_SendMessageCmd(afAddr16Bit, addr,GENERICAPP_CMDID_READ_GROUP_ID, NULL,0);

				}
				break;
			case 0x00020://create group
				{
					// addr[2],group ID[2],group name[16]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					
					uint8 find = 0;
					int i;
					uint16 savedAddr = 0;
					uint16 groupID = 1;
					////alloc new group ID
					{
						//find the minimum pGroupIdWeight
						uint16 minGroupIdWeight = 0xffff;
						{
							uint16 *pGroupIdWeight = (uint16*)bufBig_gen;
							memset(bufBig_gen,0,sizeof(bufBig_gen));
							osal_nv_read(NV_GROUP_ID_WEIGHT,0,MAX_GROUP_NUM_GEN*sizeof(uint16),pGroupIdWeight);
							for(i=1;i<MAX_GROUP_NUM_GEN;i++)
								if(minGroupIdWeight > pGroupIdWeight[i])
								{
									minGroupIdWeight = pGroupIdWeight[i];
									groupID = i;
								}
							pGroupIdWeight[groupID] = 0xffff;
							osal_nv_write(NV_GROUP_ID_WEIGHT,0,MAX_GROUP_NUM_GEN*sizeof(uint16),pGroupIdWeight);
							//osal_mem_free(pGroupIdWeight);
						}
					}
					if(SUCCESS == osal_nv_item_init(NV_GROUP_NAME_START + groupID,GROUP_NAME_BYTES_GEN,&SerialApp_Buf[6]))
						osal_nv_write(NV_GROUP_NAME_START + groupID,0,GROUP_NAME_BYTES_GEN,&SerialApp_Buf[6]);
					////
					{
						int deviceMaskBytes = DEVICE_MASK_BYTES;
						for(i=0;i<deviceMaskBytes;i++)
						{
							int k;
							int thisBits = 8;
							for(k=0;k<thisBits;k++)
							{
								if((pMaskDevice[i]>>k)&0x01)
								{
									osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,0,2,&savedAddr);
									if(savedAddr == addr)
									{
										osal_nv_write(NV_DEVICE_INFO_START + i * 8 + k,2,2,&groupID);
										find = TRUE;
										break;
									}
								}
							}
							if(find)
							{
								break;
							}
						}
						if( ! find)
						{
							sprintf(strTemp_gen,"addr[%04x] not exist\r\n",addr);
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
						}
					}

					GenericApp_SendMessageCmd(afAddr16Bit, addr,GENERICAPP_CMDID_ADD_TO_GROUP, &SerialApp_Buf[4], 2);
				}
				break;
			case 0x00021://add to a group
				{
					// addr[2],group ID[16]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					
					uint8 find = 0;
					int i;
					uint16 savedAddr = 0;
					uint16 groupID = (SerialApp_Buf[4])|(SerialApp_Buf[5]<<8);
					////update GroupIdWeight
					{
						if(groupID < MAX_GROUP_NUM_GEN)
						{
							uint16 pGroupIdWeight = 0;
							osal_nv_read(NV_GROUP_ID_WEIGHT,sizeof(uint16)*groupID,sizeof(uint16),&pGroupIdWeight);
							pGroupIdWeight = 0xffff;
							osal_nv_write(NV_GROUP_ID_WEIGHT,sizeof(uint16)*groupID,sizeof(uint16),&pGroupIdWeight);
						}
					}
					
					////
					{
						int deviceMaskBytes = DEVICE_MASK_BYTES;
						for(i=0;i<deviceMaskBytes;i++)
						{
							int k;
							int thisBits = 8;
							for(k=0;k<thisBits;k++)
							{
								if((pMaskDevice[i]>>k)&0x01)
								{
									osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,0,2,&savedAddr);
									if(savedAddr == addr)
									{
										osal_nv_write(NV_DEVICE_INFO_START + i * 8 + k,2,2,&groupID);
										find = TRUE;
										break;
									}
								}
							}
							if(find)
							{
								break;
							}
						}
						if( ! find)
						{
							sprintf(strTemp_gen,"addr[%04x] not exist\r\n",addr);
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
						}
					}

					GenericApp_SendMessageCmd(afAddr16Bit, addr,GENERICAPP_CMDID_ADD_TO_GROUP, &SerialApp_Buf[4], SerialApp_Len-4);
				}
				break;
			case 0x00022://remove from a group
				{
					// addr[2],group ID[2]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					
					uint8 find = 0;
					int i;
					uint16 savedAddr = 0;
					uint16 groupID = (SerialApp_Buf[4])|(SerialApp_Buf[5]<<8);
					uint16 newGroupID = 0;
					////update group id weight
					{
						if(groupID < MAX_GROUP_NUM_GEN)
						{
							uint16 pGroupIdWeight = 0;
							osal_nv_read(NV_GROUP_ID_WEIGHT,sizeof(uint16)*groupID,sizeof(uint16),&pGroupIdWeight);
							if(pGroupIdWeight >= 255)
								pGroupIdWeight -= 255;
							else
								pGroupIdWeight = 0;
							osal_nv_write(NV_GROUP_ID_WEIGHT,sizeof(uint16)*groupID,sizeof(uint16),&pGroupIdWeight);
						}
					}
					////
					{
						int deviceMaskBytes = DEVICE_MASK_BYTES;
						for(i=0;i<deviceMaskBytes;i++)
						{
							int k;
							int thisBits = 8;
							for(k=0;k<thisBits;k++)
							{
								if((pMaskDevice[i]>>k)&0x01)
								{
									osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,0,2,&savedAddr);
									if(savedAddr == addr)
									{
										osal_nv_write(NV_DEVICE_INFO_START + i * 8 + k,2,2,&newGroupID);
										find = TRUE;
										break;
									}
								}
							}
							if(find)
							{
								break;
							}
						}
						if( ! find)
						{
							sprintf(strTemp_gen,"addr[%04x] not exist\r\n",addr);
							HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
						}
					}

					GenericApp_SendMessageCmd(afAddr16Bit, addr,GENERICAPP_CMDID_REMOVE_FROM_GROUP, NULL,0);
				}
				break;
			case 0x00023://read group name
				{
					// group ID[2]
					uint16 groupID = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);

					if(groupID < MAX_GROUP_NUM_GEN)
						osal_nv_read(NV_GROUP_NAME_START + groupID,0,GROUP_NAME_BYTES_GEN,&sendBuf);
					sendBuf[GROUP_NAME_BYTES_GEN] = 0;
					////
					{
						sprintf(strTemp_gen,"group name[%d] = %s\r\n",groupID,(char*)sendBuf);
						HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
					}
				}
				break;
			case 0x00024://set group name
				{
					// group ID[2],group name[16]
					uint16 groupID = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);

					if(groupID < MAX_GROUP_NUM_GEN)
						osal_nv_write(NV_GROUP_NAME_START + groupID,0,GROUP_NAME_BYTES_GEN,&SerialApp_Buf[4]);
				}
				break;
			case 0x0030://endDevice control
				{
					// addr[2],cmds[2],data[...]
					uint16 addr = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					uint16 cmd = (SerialApp_Buf[4])|(SerialApp_Buf[5]<<8);

					GenericApp_SendMessageCmd(afAddr16Bit, addr,cmd, &SerialApp_Buf[6], SerialApp_Len-6);

				}
				break;
			case 0x0040://group control
				{
					// group id[2],cmds[2],data[...]
					uint16 groupId = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);
					uint16 cmd = (SerialApp_Buf[4])|(SerialApp_Buf[5]<<8);

					GenericApp_SendMessageCmd(afAddrGroup, groupId,cmd, &SerialApp_Buf[6], SerialApp_Len-6);

				}
				break;
			case 0x0050://broadcast control
				{
					// cmds[2],data[...]
					uint16 cmd = (SerialApp_Buf[2])|(SerialApp_Buf[3]<<8);

					GenericApp_SendMessageCmd(afAddrBroadcast, 0xffff,cmd, &SerialApp_Buf[4], SerialApp_Len-4);

				}
				break;

			#endif
			default:
				break;
			}
				
				
			SerialApp_Len = 0;
		}
	}
#endif
}
void PrintDeviceList_gen(void)
{
	#if defined(ZDO_COORDINATOR)
	int i;
	int deviceMaskBytes = DEVICE_MASK_BYTES;
	uint8 *bufRead = osal_mem_alloc(DEVICE_INFO_BYTES_GEN + 1);
	sprintf(strTemp_gen,"addr list num=%d\r\n",GenericApp_AddrNum);
	HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
	for(i=0;i<deviceMaskBytes;i++)
	{
		int k;
		int thisBits = 8;
		for(k=0;k<thisBits;k++)
		{
			if((pMaskDevice[i]>>k)&0x01)
			{
				sprintf(strTemp_gen,"index=%d\r\n",i * 8 + k);
				HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
				memset(bufRead,0,DEVICE_INFO_BYTES_GEN+1);
				osal_nv_read(NV_DEVICE_INFO_START + i * 8 + k,0,DEVICE_INFO_BYTES_GEN,bufRead);
				bufRead[DEVICE_INFO_BYTES_GEN] = 0;
				sprintf(strTemp_gen,"info[%04x][%d][%s]\r\n",*((uint16*)(bufRead)),*((uint16*)(bufRead+2)),(char*)(bufRead+4));
				HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
			}
		}
	}
	sprintf(strTemp_gen,"\r\n");
	HalUARTWrite(0,(uint8*)strTemp_gen,strlen(strTemp_gen));
	osal_mem_free(bufRead);
	#endif
}
/*********************************************************************
 */
